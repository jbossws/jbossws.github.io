<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-01-10T02:05:29+00:00</updated><id>/feed.xml</id><title type="html">JBossWS</title><entry><title type="html">JBossWS 7.3.1.Final is released!</title><link href="/2024/12/11/jbossws-731-release/" rel="alternate" type="text/html" title="JBossWS 7.3.1.Final is released!" /><published>2024-12-11T00:00:00+00:00</published><updated>2024-12-11T00:00:00+00:00</updated><id>/2024/12/11/jbossws-731-release</id><content type="html" xml:base="/2024/12/11/jbossws-731-release/"><![CDATA[<p>JBossWS-CXF 7.3.1.Final has been released. In this release, we mainly fixed issue: <a href="https://issues.redhat.com/browse/JBWS-4433">JBWS-4433:Don’t create JAXPDelegateClassLoader for each invocation in the CXFServletExt</a>
to improve the performance. For complete issue list, please check the <a href="https://issues.redhat.com/secure/ReleaseNote.jspa?projectId=12310050&amp;version=12439419">Release Notes</a>.</p>

<p>Please try out this release, and let us know if you have any issues or questions.</p>]]></content><author><name>Jim Ma</name></author><summary type="html"><![CDATA[JBossWS-CXF 7.3.1.Final has been released. In this release, we mainly fixed issue: JBWS-4433:Don’t create JAXPDelegateClassLoader for each invocation in the CXFServletExt to improve the performance. For complete issue list, please check the Release Notes.]]></summary></entry><entry><title type="html">JBossWS 7.3.0.Final is released!</title><link href="/2024/11/11/jbossws-730-release/" rel="alternate" type="text/html" title="JBossWS 7.3.0.Final is released!" /><published>2024-11-11T00:00:00+00:00</published><updated>2024-11-11T00:00:00+00:00</updated><id>/2024/11/11/jbossws-730-release</id><content type="html" xml:base="/2024/11/11/jbossws-730-release/"><![CDATA[<p>We are pleased to announce the release of JBossWS-CXF 7.3.0.Final. In this release,
we’ve upgraded CXF to version 4.0.5, woodstox-core from 6.4.0 to 7.0.0 and addressed several important issues, including
<a href="https://issues.redhat.com/browse/JBWS-4430">JBWS-4430</a>. For more details,
please see the <a href="https://issues.redhat.com/secure/ReleaseNote.jspa?projectId=12310050&amp;version=12431262">Release Notes</a>.</p>

<p>If you are currently using JBossWS 7.2.0.Final, we recommend upgrading to this version,
especially if you are using CDI in the SOAP handler or CXF interceptors.</p>

<p>Please try out this release, and let us know if you have any issues or questions.</p>]]></content><author><name>Jim Ma</name></author><summary type="html"><![CDATA[We are pleased to announce the release of JBossWS-CXF 7.3.0.Final. In this release, we’ve upgraded CXF to version 4.0.5, woodstox-core from 6.4.0 to 7.0.0 and addressed several important issues, including JBWS-4430. For more details, please see the Release Notes.]]></summary></entry><entry><title type="html">JBossWS 7.2.0.Final is released!</title><link href="/2024/08/08/jbossws-720-release/" rel="alternate" type="text/html" title="JBossWS 7.2.0.Final is released!" /><published>2024-08-08T00:00:00+00:00</published><updated>2024-08-08T00:00:00+00:00</updated><id>/2024/08/08/jbossws-720-release</id><content type="html" xml:base="/2024/08/08/jbossws-720-release/"><![CDATA[<p>JBossWS-CXF 7.2.0.Final has been released. In this release, we introduced the throttling feature to better control the number of requests a backend service can handle within a specified 
time frame. In addition to this new feature, we addressed several other issues, including a performance problem on the client side
<a href="https://issues.redhat.com/browse/JBWS-4424">JBWS-4424</a> and made a few enhancements.  For more detailed information and a full list of issues addressed in this release,
please check <a href="https://issues.redhat.com/secure/ReleaseNote.jspa?projectId=12310050&amp;version=12425135">release notes</a>.</p>

<p>Please try this release out and give us your feedback!</p>]]></content><author><name>Jim Ma</name></author><summary type="html"><![CDATA[JBossWS-CXF 7.2.0.Final has been released. In this release, we introduced the throttling feature to better control the number of requests a backend service can handle within a specified time frame. In addition to this new feature, we addressed several other issues, including a performance problem on the client side JBWS-4424 and made a few enhancements. For more detailed information and a full list of issues addressed in this release, please check release notes.]]></summary></entry><entry><title type="html">Throttle the webservice request with JBossWSThrottlingFeature</title><link href="/2024/05/31/new-throttling-feature/" rel="alternate" type="text/html" title="Throttle the webservice request with JBossWSThrottlingFeature" /><published>2024-05-31T00:00:00+00:00</published><updated>2024-05-31T00:00:00+00:00</updated><id>/2024/05/31/new-throttling-feature</id><content type="html" xml:base="/2024/05/31/new-throttling-feature/"><![CDATA[<p>To ensure the web service application can handle a large number of requests, we need to allocate 
sufficient resources and use load balancing approaches to distribute the requests
across different server instances. Besides providing enough resources for the web service 
application, we can still do more within the application server to help manage and control 
the flow of requests to the backend web services, ensuring the stability and performance of 
a certain web service application. In this blog, we will explore the newly added JBossWSThrottlingFeature 
and demonstrate this feature to limit web service requests with some configuration examples.</p>

<h3 id="understanding-throttling">Understanding Throttling</h3>
<p>Throttling is a technique to control the number of requests a backend service can handle within 
a specified time frame. For example, we can set a limit so that the service can only handle 
10,000 requests in 5 minutes. By limiting the rate of incoming requests, throttling helps prevent 
the server from being overwhelmed and protects it from potential crashes. This ensures that 
server resources are utilized within their designed capacity. Throttling is particularly 
important in environments where services are exposed to numerous clients and handle resource-intensive operations. 
It also acts as a protective measure against Denial of Service (DoS) attacks.</p>
<h3 id="jbosswsthrottlingfeature">JBossWSThrottlingFeature</h3>
<p>JBossWSThrottlingFeature is the new feature class to enable the throttling in JBossWS-CXF/WildFly which is introduced 
in jbossws-cxf-7.2.0. This class can allow the JBossWSThrottlingFeature to be configured in the jaxws-endpoint-config.xml.
Like CXF’s throttling feature, each JBossWSThrottlingFeature needs a ThrottlingManager to check if the request reaches the 
limit and should return the response immediately. The EndpointMetricsThrottlingManager is created to throttle the request 
based on JBossWS endpoint metrics. JBossWS EndpointMetrics collects the different metrics from each endpoint:</p>

<ul>
  <li>faultCount</li>
  <li>requestCount</li>
  <li>averageProcessingTime</li>
  <li>maxProcessingTime</li>
  <li>minProcessingTime</li>
  <li>totalProcessingTime</li>
</ul>

<p>User can define the limit number for each metric to limit the request to this endpoint.For example, if we define
the requests number reaches 5, it will throttle the request and return 429 (Server Busy) response to the client.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;

  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.cxf.throttling.HelloWorldImpl&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.JBossWSThrottlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature.throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.EndpointMetricsThrottlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager.requestPermit&lt;/property-name&gt;
      &lt;property-value&gt;5&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
</code></pre></div></div>
<p>There is another RateLimitThorttlingManager out-of-the-box to allow user to easily control the request traffic
by defining the <code class="language-plaintext highlighter-rouge">permitsPerMin</code>. This simply define the number of requests the server can handle in one minute.
Exceed this number of requests, the server will respond 429 immediately.Below is the configuration example which is
limiting the requests is 5 in one minute:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.cxf.throttling.HelloImpl&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.JBossWSThrottlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature.throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.RateLimitThorttlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager.permitsPerMin&lt;/property-name&gt;
      &lt;property-value&gt;5&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;
</code></pre></div></div>
<p>The other two options <code class="language-plaintext highlighter-rouge">peroid</code> and <code class="language-plaintext highlighter-rouge">permitsPerPeroid</code> in RateLimitThorttlingManager can be used to specify any peroid time and number of requests is allowed in this peroid 
time instead of defining the requests limit in one minute which is commonly used. For example, this jaxws-endpoint-config.xml can be used to limit the 5 requests in 30 seconds:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.cxf.throttling.HelloImpl&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.JBossWSThrottlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature.throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.RateLimitThorttlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager.period&lt;/property-name&gt;
      &lt;property-value&gt;30&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager.permitsPerPeriod&lt;/property-name&gt;
      &lt;property-value&gt;5&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;
</code></pre></div></div>
<p>Please note ,both these two ThrottlingManagers require the webservice subsystem’ statistics is enabled
to get the correct value from Endpoint metrics. To enable the webservice subsystem’s statistics, simply 
run the jboss-cli command:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./subsystem=webservices:write-attribute(name=statistics-enabled,value=true)
</code></pre></div></div>

<p>The key element of the throttling feature configuration is the jaxws-endpoint-config.xml, and this configuration file should be packaged directly in the WAR file, and ensure it’s not under META-INF or WEB-INF.</p>

<h3 id="summary">Summary</h3>
<p>The JBossWS throttling feature can be an easy approach to protect important web services from being 
overwhelmed or crashed. This feature can also be used to serve different user categories, 
such as paid and unpaid users. If you need this feature in your web service application, 
please give it a try. If you find that the out-of-the-box ThrottlingManager 
doesn’t meet your requirements, you can extend the throttling api and create 
your own ThrottlingManager. If your created ThrottlingManager could be useful 
for others and want to contribute, don’t forget to let us know.</p>]]></content><author><name>Jim Ma</name></author><summary type="html"><![CDATA[To ensure the web service application can handle a large number of requests, we need to allocate sufficient resources and use load balancing approaches to distribute the requests across different server instances. Besides providing enough resources for the web service application, we can still do more within the application server to help manage and control the flow of requests to the backend web services, ensuring the stability and performance of a certain web service application. In this blog, we will explore the newly added JBossWSThrottlingFeature and demonstrate this feature to limit web service requests with some configuration examples.]]></summary></entry><entry><title type="html">JBossWS 7.1.0.Final is released!</title><link href="/2024/03/27/jbossws-710-released/" rel="alternate" type="text/html" title="JBossWS 7.1.0.Final is released!" /><published>2024-03-27T00:00:00+00:00</published><updated>2024-03-27T00:00:00+00:00</updated><id>/2024/03/27/jbossws-710-released</id><content type="html" xml:base="/2024/03/27/jbossws-710-released/"><![CDATA[<p>JBossWS-CXF 7.1.0.Final has been released. This release contains several bug fixes, test enhancements and components upgrades.
The notable upgrades are the CXF 4.0.4 upgrade which resolved <a href="https://nvd.nist.gov/vuln/detail/CVE-2024-28752">CVE-2024-28752</a>
and XmlSec(santuario) 3.0.3 upgrade resolved <a href="https://nvd.nist.gov/vuln/detail/CVE-2023-44483">CVE-2023-44483</a>. The CXF upgrade introduced the new CXF http client which is using java.net.http.HttpClient 
from JDK to better support HTTP/2, but this is the preview feature and user can enable this new client by setting system property or bus property.
From 7.1.0.Final,we started to use Java 21 to build and run testsuite to make sure everything works with this latest version JDK.</p>

<p>For more detailed info and full list of issue in this release, please check <a href="https://issues.redhat.com/secure/ReleaseNote.jspa?projectId=12310050&amp;version=12414901">release notes</a>.
Please try this release out and give us your feedback!</p>]]></content><author><name>Jim Ma</name></author><summary type="html"><![CDATA[JBossWS-CXF 7.1.0.Final has been released. This release contains several bug fixes, test enhancements and components upgrades. The notable upgrades are the CXF 4.0.4 upgrade which resolved CVE-2024-28752 and XmlSec(santuario) 3.0.3 upgrade resolved CVE-2023-44483. The CXF upgrade introduced the new CXF http client which is using java.net.http.HttpClient from JDK to better support HTTP/2, but this is the preview feature and user can enable this new client by setting system property or bus property. From 7.1.0.Final,we started to use Java 21 to build and run testsuite to make sure everything works with this latest version JDK.]]></summary></entry><entry><title type="html">The new webserivce http client in jbossws-cxf-7.1.0.Final</title><link href="/2024/03/27/new-webservice-client/" rel="alternate" type="text/html" title="The new webserivce http client in jbossws-cxf-7.1.0.Final" /><published>2024-03-27T00:00:00+00:00</published><updated>2024-03-27T00:00:00+00:00</updated><id>/2024/03/27/new-webservice-client</id><content type="html" xml:base="/2024/03/27/new-webservice-client/"><![CDATA[<p>From jbossws-cxf-7.1.0.Final, we upgraded the CXF to 4.0.4. With this CXF upgrade, 
the new webservice client is included in jbossws-cxf-7.1.0.Final and WFLY 32.0.0.Beta1.
This new CXF webservice client is going to replace the old webservice http client which is 
using URLConnection with the new java.net.http.HttpClient. This new CXF http client mainly brings the HTTP/2 
support without other dependency, and user doesn’t need to set anything else if server supports HTTP/2.
Due to some important issues like the <a href="https://issues.apache.org/jira/browse/CXF-8951">massive threads created</a> and 
<a href="https://bugs.openjdk.org/browse/JDK-8277519">performance issue</a> in this new http client, 
jbossws-cxf disable this new webserivce http client by default and still switch to the old http client based on HTTPURLConnection.
To enable this new webservice client, user should explicitly set the <code class="language-plaintext highlighter-rouge">force.urlconnection.http.conduit</code> to <code class="language-plaintext highlighter-rouge">false</code> 
in system property or bus property like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> BusFactory.getDefaultBus().setProperty("force.urlconnection.http.conduit", false);
 BusFactory.getDefaultBus().setProperty("org.apache.cxf.transport.http.forceVersion", "2");
 HelloWorld port = getPort();
 String response = port.echo("hello");
</code></pre></div></div>

<p>Due to this isn’t mature and possibly more issues will be found by the community user.
It isn’t recommended to use this in production unless performance isn’t a factor and HTTP/2 is required to support.</p>]]></content><author><name>Jim Ma</name></author><summary type="html"><![CDATA[From jbossws-cxf-7.1.0.Final, we upgraded the CXF to 4.0.4. With this CXF upgrade, the new webservice client is included in jbossws-cxf-7.1.0.Final and WFLY 32.0.0.Beta1. This new CXF webservice client is going to replace the old webservice http client which is using URLConnection with the new java.net.http.HttpClient. This new CXF http client mainly brings the HTTP/2 support without other dependency, and user doesn’t need to set anything else if server supports HTTP/2. Due to some important issues like the massive threads created and performance issue in this new http client, jbossws-cxf disable this new webserivce http client by default and still switch to the old http client based on HTTPURLConnection. To enable this new webservice client, user should explicitly set the force.urlconnection.http.conduit to false in system property or bus property like:]]></summary></entry><entry><title type="html">JBossWS 7.0.0.Final is out !</title><link href="/2023/10/13/jbossws-7.0.0.final-is-released/" rel="alternate" type="text/html" title="JBossWS 7.0.0.Final is out !" /><published>2023-10-13T00:00:00+00:00</published><updated>2023-10-13T00:00:00+00:00</updated><id>/2023/10/13/jbossws-7.0.0.final-is-released</id><content type="html" xml:base="/2023/10/13/jbossws-7.0.0.final-is-released/"><![CDATA[<p>We are pleased to announce the release of JBossWS-CXF 7.0.0.Final. In this release, we created cloud test 
utils to help create JBossWS test on Kubernetes and added the tests and docker image to demonstrate how 
to create web service with JBossWS/WFLY on Kubernetes environment.
And another important change is we removed xerces dependency in JBossWS and now all uses the JAXP implementation
from JDK itself. In this release, we fixed an important security issue <a href="https://issues.redhat.com/browse/JBWS-4389">JBWS-4389</a> in WS-Security UsernameToken authentication
, special thanks to Diana Krepinska for the hard work on this issue,  and last but not least, all binaries will be built with JDK11 and plus from JBossWS 7.0.0.Final.
We already changed the CI build and release configuration to compile all things with JDK11 and JDK17 now.
For more detailed info and full list of issue in this release, please check <a href="https://issues.redhat.com/secure/ReleaseNote.jspa?projectId=12310050&amp;version=12409746">release notes</a>.
Please try this release out and give us your feedback!</p>]]></content><author><name>Jim Ma</name></author><summary type="html"><![CDATA[We are pleased to announce the release of JBossWS-CXF 7.0.0.Final. In this release, we created cloud test utils to help create JBossWS test on Kubernetes and added the tests and docker image to demonstrate how to create web service with JBossWS/WFLY on Kubernetes environment. And another important change is we removed xerces dependency in JBossWS and now all uses the JAXP implementation from JDK itself. In this release, we fixed an important security issue JBWS-4389 in WS-Security UsernameToken authentication , special thanks to Diana Krepinska for the hard work on this issue, and last but not least, all binaries will be built with JDK11 and plus from JBossWS 7.0.0.Final. We already changed the CI build and release configuration to compile all things with JDK11 and JDK17 now. For more detailed info and full list of issue in this release, please check release notes. Please try this release out and give us your feedback!]]></summary></entry><entry><title type="html">The New JBossWS Kubernetes/OpenShift Test Common Utilities</title><link href="/2023/09/08/jbossws-cloud-test-common-utilties/" rel="alternate" type="text/html" title="The New JBossWS Kubernetes/OpenShift Test Common Utilities" /><published>2023-09-08T00:00:00+00:00</published><updated>2023-09-08T00:00:00+00:00</updated><id>/2023/09/08/jbossws-cloud-test-common-utilties</id><content type="html" xml:base="/2023/09/08/jbossws-cloud-test-common-utilties/"><![CDATA[<p>When deploying a web service application to a cloud environment, such as a Kubernetes or OpenShift cluster, 
it’s essential to test if everything functions as expected. We now have plenty of JBossWS tests to deploy the webservice
deployment into WildFly server and check if the webservice application function as expected.
These tests make use of various tools and frameworks, including <a href="https://arquillian.org/modules/shrinkwrap-shrinkwrap/">ShrinkWrap</a> to package the deployment, 
<a href="https://arquillian.org/">Arquillian</a> to manage the WFLY instance lifecycle and deploy the application deployment into WFLY server,
and a web service client for sending requests and receiving responses.</p>

<p>To create tests that can run seamlessly within a Kubernetes environment, it needs to have the similar tool and framework for 
preparing the Kubernetes cluster, building container images,  deploying necessary resources (such as Services, Deployments, and Pods) to the cluster, 
and creating a client to validate the functionality of the web service running in the cloud environment.</p>

<p>In the following sections, we will delve into the preparation of the Kubernetes cluster, the packaging of the web service 
application into a container image, the deployment of various resources within the Kubernetes cluster, and 
the creation of a client to conduct comprehensive testing of the backend web service deployed in the Kubernetes cluster. 
Additionally, we will highlight newly developed cloud test common utilities to help create the cloud test with greater ease.</p>

<h4 id="prepare-the-kubernetes-test-environment">Prepare The Kubernetes Test Environment</h4>
<p>To test and run the cloud tests, we need have a simple Kubernetes environment. The MiniKube is the commonly used minimal 
Kubernetes cluster for test purpose. It’s easy to install and easy to start/stop. Follow <a href="https://minikube.sigs.k8s.io/docs/start/">the minikube instructions</a>,
to install minikube. After the minikube installation, start it with <code class="language-plaintext highlighter-rouge">minikube start</code>.
JBossWS cloud tests need to build container image and push the image to the local registry, so the minikube registry addon is required here.
<code class="language-plaintext highlighter-rouge">minikube addons enable registry</code> enables the container registry and exposes its port 5000 for local access.
After the registry is ready, the image with name and tag like <code class="language-plaintext highlighter-rouge">localhost:5000/wildfly-webservice:latest</code> can be pushed to this addon container
registry.</p>

<h4 id="build-container-image">Build Container Image</h4>
<p>Containerized application is the essential part to deploy the application to Kubernetes. 
There are a number of tools to build the container image like the Docker or CRI-O CLI tool. 
In a maven build project, it’s more convenient to use a maven plugin to build the image in the maven build
lifecycle. 
The <a href="https://dmp.fabric8.io/">fabric8 maven docker plugin</a> is a good fit for this job. 
Build and push images can all be completed by this maven plugin. This is an example we build the image with <code class="language-plaintext highlighter-rouge">docker-maven-plugin</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;plugin&gt;
    &lt;groupId&gt;io.fabric8&lt;/groupId&gt;
    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;build-images&lt;/id&gt;
            &lt;phase&gt;pre-integration-test&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;build&lt;/goal&gt;
                &lt;goal&gt;push&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;images&gt;
                    &lt;image&gt;
                        &lt;name&gt;localhost:5000/wildfly-webservice:latest&lt;/name&gt;
                        &lt;build&gt;
                            &lt;from&gt;quay.io/wildfly/wildfly-runtime:latest&lt;/from&gt;
                            &lt;assembly&gt;
                                &lt;mode&gt;dir&lt;/mode&gt;
                                &lt;user&gt;jboss:root&lt;/user&gt;
                                &lt;targetDir&gt;/opt/server&lt;/targetDir&gt;
                                &lt;inline&gt;
                                    &lt;formats&gt;
                                        &lt;format&gt;dir&lt;/format&gt;
                                    &lt;/formats&gt;
                                    &lt;fileSets&gt;
                                        &lt;fileSet&gt;
                                            &lt;directory&gt;target/server&lt;/directory&gt;
                                            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
                                            &lt;includes&gt;
                                                &lt;include&gt;**&lt;/include&gt;
                                            &lt;/includes&gt;
                                        &lt;/fileSet&gt;
                                    &lt;/fileSets&gt;
                                &lt;/inline&gt;
                            &lt;/assembly&gt;
                        &lt;/build&gt;
                    &lt;/image&gt;
                &lt;/images&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre></div></div>
<p>The build maven goal is responsible for packaging the local WFLY server instance under <code class="language-plaintext highlighter-rouge">target/server</code> into image directory <code class="language-plaintext highlighter-rouge">/opt/server</code>.
The <code class="language-plaintext highlighter-rouge">&lt;user&gt;jboss:root&lt;/user&gt;</code> corresponds to the USER Dockerfile directive to switch the jboss user and root group. This 
image is based on <code class="language-plaintext highlighter-rouge">quay.io/wildfly/wildfly-runtime:latest</code> and new output image is <code class="language-plaintext highlighter-rouge">localhost:5000/wildfly-webservice:latest</code>.
The push goal is taking care of the image push to the minikube’s registry.</p>

<h4 id="deploy-kubernetes-resources">Deploy Kubernetes Resources</h4>
<p>Like test against WFLY Server, the tests deploy the application deployment, JBossWS cloud tests need to deploy the various Kubernetes 
resources like and wait them ready before testing these resources are operational
as expected. In the coming JBossWS 7 release, we added these new test utils class based on <a href="https://junit.org/junit5/docs/current/user-guide/">Junit5 Jupiter</a>
and <a href="https://github.com/fabric8io/kubernetes-client">fabric8 kubernetes client</a> to deploy/delete Kubernetes resources before/after
cloud tests. These are the new created components in the test common utilities:</p>

<h5 id="jbosswskubernetesintegrationtest">@JBossWSKubernetesIntegrationTest</h5>
<p>This is the new added class to annotate the Test class and enable the JBossWSKubernetesExtension to 
deploy/undeploy the Kubernetes resources. It must be present for the JBossWS cloud test.
This annotation has only one value <code class="language-plaintext highlighter-rouge">kubernetesResource</code>
now to pass the kubernetes yaml resource file to create or delete Kubernetes resources for each test.</p>

<h5 id="jbosswskubernetesextension">JBossWSKubernetesExtension</h5>
<p>JBossWSKubernetesExtension is the junit5 extension and is activated by the
@JBossWSKubernetesIntegrationTest annotation. For jbossws cloud test user, although this class is 
an internal class, and user doesn’t need to import or directly use this class in the cloud test, but it’s good for user 
to know this class can help finishing these tasks :</p>
<ul>
  <li>Create the kubernetes client and inject it to the test instance.</li>
  <li>Read the <code class="language-plaintext highlighter-rouge">KubernetesResource</code> file defined in @JBossWSKubernetesIntegrationTest annotation</li>
  <li>Create and delete the loaded <code class="language-plaintext highlighter-rouge">KubernetesResource</code> in @BeforeAll and @AfterAll annotated method.</li>
</ul>

<h5 id="injectkubeclient">@InjectKubeClient</h5>
<p>This class to denote the field or the parameter to be injected with created KubernetesClient like:
<code class="language-plaintext highlighter-rouge">@InjectKubeClient
private KubernetesClient k8sClient;
</code>
or the parameter injection:
<code class="language-plaintext highlighter-rouge">public void  checkWSEndpoint(@InjectKubeClient KubernetesClient kubeClient) throws Exception {
</code></p>
<h5 id="jbosswskubernetestest">JBossWSKubernetesTest</h5>
<p>JBossWSKubernetesTest is the base class to provide the WildFly instance readiness check in the 
@BeforeEach annotated method. By checking the WildFly readiness <code class="language-plaintext highlighter-rouge">http://localhost:9990/health/ready</code>, it waits for the amount of time unless
the WildFly server is ready or the timeout . The cloud test can extend this base class to have the ability to wait for 
the WildFly server ready in the cloud environment. Here is an example of jbossws cloud test which uses these new created test common utilities classes:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@JBossWSKubernetesIntegrationTest(
kubernetesResource = "src/test/resources/kubernetes.yml"
)
public class EndpointTestCase extends JBossWSKubernetesTest {

    private final String APP_NAME = "jbossws-cxf-k8s-basic";
    @Test
    public void  checkWSEndpoint(@InjectKubeClient KubernetesClient kubeClient) throws Exception {
        List&lt;Pod&gt; lst = kubeClient.pods().withLabel("app.kubernetes.io/name", APP_NAME).list().getItems();
        Assertions.assertEquals(1, lst.size(), "More than one pod found with expected label " + lst);
        Pod first = lst.get(0);
        Assertions.assertNotNull(first, "pod isn't created");
        Assertions.assertEquals("Running", first.getStatus().getPhase(), "Pod isn't running");
        LocalPortForward p = kubeClient.services().withName(APP_NAME).portForward(8080);
        Assertions.assertTrue(p.isAlive());
        URL baseURL = new URL("http://localhost:" + p.getLocalPort() + "/" + APP_NAME + "/EndpointImpl");
        Endpoint endpoint = initPort(baseURL);
        String  echoed = endpoint.echo("from k8s pod");
        Assertions.assertEquals("Echo:from k8s pod", echoed);
    }
</code></pre></div></div>
<h4 id="check-deployed-webservice">Check Deployed WebService</h4>
<p>This is the client part to send the request to the deployed webservice and verify the response. 
It is quite same as the client for the deployed service in WildFly, the only difference is 
to get the accessible webservice url by invoking local port forward. The port forward means expose 
the service or pod to the local machine port that can be accessed by the created webservice in the test.
In the above example, the<code class="language-plaintext highlighter-rouge">LocalPortForward p = kubeClient.services().withName(APP_NAME).portForward(8080);</code>
expose the Kubernetes service port 8080 to a local random port like <code class="language-plaintext highlighter-rouge">54443</code>. The following service requests are 
all sent to this exposed port to call this service.</p>

<h4 id="summary">Summary</h4>
<p>In the new JBossWS release, the jbossws cloud tests will be added along with the new created test common utilities. To look at the complete jbossws
test case and the kuberentes yaml files, please go to https://github.com/jbossws/jbossws-cxf/tree/main/modules/testsuite/cloud-tests/k8s
and look at the <code class="language-plaintext highlighter-rouge">basic</code> folder for the basic could test, <code class="language-plaintext highlighter-rouge">wstrust</code> and <code class="language-plaintext highlighter-rouge">wsse</code> for the advanced webservice cloud tests.
For any issue, feedback and comments please let us know.</p>]]></content><author><name>Jim Ma</name></author><summary type="html"><![CDATA[When deploying a web service application to a cloud environment, such as a Kubernetes or OpenShift cluster, it’s essential to test if everything functions as expected. We now have plenty of JBossWS tests to deploy the webservice deployment into WildFly server and check if the webservice application function as expected. These tests make use of various tools and frameworks, including ShrinkWrap to package the deployment, Arquillian to manage the WFLY instance lifecycle and deploy the application deployment into WFLY server, and a web service client for sending requests and receiving responses.]]></summary></entry><entry><title type="html">Web Services testing in the cloud - Part II</title><link href="/2023/06/23/webservices-cloud-testing-p2/" rel="alternate" type="text/html" title="Web Services testing in the cloud - Part II" /><published>2023-06-23T00:00:00+00:00</published><updated>2023-06-23T00:00:00+00:00</updated><id>/2023/06/23/webservices-cloud-testing-p2</id><content type="html" xml:base="/2023/06/23/webservices-cloud-testing-p2/"><![CDATA[<p>This is the second article in a series about the web services team’s
exploration of technologies and strategies for running JBossWS-CXF integration tests in a cloud environment.
<a href="https://jbossws.github.io/2023/06/16/webservices-cloud-testing-p1/">Part I</a> describes the scope of this project.</p>

<h4 id="designing-a-testing-framework">Designing a Testing Framework</h4>

<p>One of the project objectives is to use Maven to generate the testable components and run the tests.  For this initial evaluation there are two test components, an image file containing a web service deployment archive (usually a WAR file) running in WildFly and a JUnit test class that runs outside the image file.  Future test cases will be more complex consisting of several web service images and a single test class.</p>

<p>In proto-typing the testing framework an exiting simple Arquillian based web service integration test will be migrated to this framework.  The complexity of the required modifications will be noted.  In my opinion the fewer the modifications the better.  I have considered creating a mock-arquillian archive that would allow the Arquillian classes referenced in the exiting test class to be ignored.  This would allow the test class to remain unaltered and useable in both Arquillian and the cloud test frameworks.  But it does not seem like a good idea for test clarity and long term code maintenance, so I will be making edits to the test class.</p>

<p>As noted in <a href="https://jbossws.github.io/2023/06/16/webservices-cloud-testing-p1/">Part I</a>, I think the framework should support testing both development and released versions of WildFly. There are 2 strategies that can be used to build the image file.  One is to use a WildFly image provided in <a href="https://quay.io/wildfly">quay.io/wildfly</a> and add the web service
deployment archive to it, creating a new image.  Two, is to generate a version of WildFly on local 
 disk, add the deployment archive to it, use a base <em>docker</em> image, add the WildFly build to that and finally create a new image.
In both test image building strategies the web service deployment archive must be 
available when building the image.  With Arquillian that file is defined within the test class.  It is generated using ShrinkWrap APIs and deployed when the test class runs.  In this image building process the <a href="https://maven.apache.org/plugins/maven-war-plugin/">maven-war-plugin</a> is used to generate the deployment archive.  The corresponding code is removed from the test class.  Generating the deployment archive in this manner also means every test must exist in its own project module.</p>

<p>In addressing the second strategy, generating a version of WildFly on local
disk, <a href="https://docs.wildfly.org/wildfly-maven-plugin/">org.wildfly.plugins:wildfly-maven-plugin</a> is used to generate WildFly from a WildFly feature pack.  To that, the deployment archive is copied into WildFly’s <code class="language-plaintext highlighter-rouge">standalone/deployment</code> directory by the plugin. The wildfly-maven-plugin has been enhanced to run WildFly CLI scripts.  A feature future web service cloud tests will need but is not required for this simple test case.  I find having the WildFly code that is used in the image available locally helpful.  It makes it easy to debug any server issue with the test.</p>

<p>For both strategies <a href="https://dmp.fabric8.io/">io.fabric8:docker-maven-plugin</a> is used to generate a <a href="https://www.docker.com/">docker</a> image from a <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a> provided in the project.  <em>docker-maven-plugin</em> is a versatile plugin with many features and options for generating <em>docker</em> images and configurating the image’s run parameters.  This plugin can be used for testing.  It can start the image in <em>docker</em>, run the test, stop the <em>docker</em> instance and cleanup after the test. However a more complex test case should be created to futher evaluate the capabilies of this plugin to meet the needs of our future test cases.</p>

<p>The plugin recommended using the <a href="https://maven.apache.org/surefire/maven-failsafe-plugin/">maven-failsafe-plugin</a> instead of <a href="https://maven.apache.org/surefire/maven-surefire-plugin/">maven-surefire-plugin</a> in running the integration test because on test failure <em>maven-failsafe-plugin</em> will clean up the <em>docker</em> process and <em>maven-surefire-plugin</em> will not. I encountered an issue using <em>maven-failsafe-plugin</em> in place of <em>maven-surefire-plugin</em>. <em>maven-surefire-plugin</em> runs as a default build process. In order to enable <em>maven-failsafe-plugin</em> to run I had to disable the running of surefire by excluding the test class in the plugin and including the test class in the <em>maven-failsafe-plugin</em>. Also maven-failsafe-plugin requires test method names to either start or end with “IT”, so the test class had to be adjusted accordingly.
While editing the test class I also removed the references to Arquillian annotations, <em>RunAsClient</em> and <em>Deployment</em>, and JUnit annotation <em>RunWith</em>.</p>

<p>A key objective of the testing framework is to be able to run the test suite on any Kubernetes compliant implementation. <em>io.fabric8:docker-maven-plugin</em> does not appear to provide that versatility.  It deploys images to <em>docker</em> only. However I have not found any other plugin that can deploy to any Kubernetes implementation either.</p>

<p>Let’s review the pros and cons of this framework:</p>

<p><em>Pros</em></p>
<ul>
  <li>The test can be built and run via maven.</li>
  <li>The test class does not need extensive editing.</li>
</ul>

<p><em>Cons</em></p>
<ul>
  <li>Each test will required its own project module because a deployment archive must be created.</li>
  <li>There will be a lot of duplicate boilerplate code in the <em>pom.xml</em> files.</li>
  <li>The test class requires some edits.</li>
  <li>There is no generic support for deploying the tests to any Kubernetes implementation.</li>
</ul>

<p>Source code for this proto-type project can be found <a href="https://github.com/rsearls/blog-posts/tree/master/blog-mvn-wfly-plugin">here</a>.</p>]]></content><author><name>Rebecca Searls</name></author><summary type="html"><![CDATA[This is the second article in a series about the web services team’s exploration of technologies and strategies for running JBossWS-CXF integration tests in a cloud environment. Part I describes the scope of this project.]]></summary></entry><entry><title type="html">Web Services testing in the cloud - Part I</title><link href="/2023/06/16/webservices-cloud-testing-p1/" rel="alternate" type="text/html" title="Web Services testing in the cloud - Part I" /><published>2023-06-16T00:00:00+00:00</published><updated>2023-06-16T00:00:00+00:00</updated><id>/2023/06/16/webservices-cloud-testing-p1</id><content type="html" xml:base="/2023/06/16/webservices-cloud-testing-p1/"><![CDATA[<p>The web services team is embarking on an exploration of technologies and strategies
for running the JBossWS-CXF integration tests in a cloud environment.
A series of blogs will follow that discuss the technologies
evaluated and strategies tried in this quest.</p>

<h4 id="working-on-requirements">Working on requirements</h4>

<h5 id="test-execution-architecture">Test execution architecture</h5>

<p>It is the team’s desire to use a framework that adheres to the Java maxim 
<em>“Write once. Run anywhere”</em>.  In this case, write the tests once and run them on
any Kubernetes based cloud environment.
I would add to that, the goal of leveraging what we can of the existing test
class format.  The web services integration test suites uses Arquillian / <a href="https://github.com/shrinkwrap">ShrinkWrap</a>
which provides a means for the test class itself to contain the definition of the
web service deployment archive (normally a WAR file) that is deployed and the client code used to call the service.
While I find it a convenience to have both key components co-located in a single file,
the team is still discussing whether the test suite shouldn’t instead follow the
classic cloud paradigm in which a testable image is created in a separate pre-test build step 
and the deployment archive would need to be available at that time in order to be
incorporated into the testing image.</p>

<p>Generally it is desirable to continue using Maven and its plugins to build the test images 
and run the test suites. As a matter of fact, Maven has been the dominant build tool of Red Hat shephered projects
for years.</p>

<h5 id="test-environment">Test environment</h5>

<p>At this time there are two environments in which we must be able to run the
test suite, one on our local machines for development purposes and two in the CIs we use.
This means running <a href="https://minikube.sigs.k8s.io/docs/">minikube</a> and/or <a href="https://docs.openshift.com/">OpenShift</a> on our personal machines.</p>

<p>JBossws-CXF continuous integration is currently run on GitHub.  It is yet to be determined what cloud
products GitHub CI can run. Jenkins supports testing in cloud environments but our team does
not currently use it.</p>

<p><a href="https://www.wildfly.org/">WildFly</a> will be the server used in a testable image.  In my opinion the test suite
should support generation of testable images of both development versions of WildFly and
released versions.  The WildFly team pushes images of released versions
of WildFly to the <a href="https://quay.io/">quay.io</a> repository.  An extra build step will be needed to generate an image containing a development version of WildFly.</p>

<h5 id="test-scenarios">Test scenarios</h5>

<p>Another issue under discussion is do we write only new tests or leverage
some or all the existing tests.  There is agreement that new tests need
to be written.  There are unique cloud based scenarios that should be
tested.  There is still an open discussion about testing any of the existing
integration tests in the cloud.  There is also a discussion whether the suite
of tests should reside in a separate project or in a new module within the existing projects.  I think the test suite location
will be determined once we have a better understanding of the framework(s)
for building and running the tests in the required environments.</p>

<p>These are the general parameters the team is using in evaluating technologies and strategies in writing and running web services tests in the cloud.  The coming blogs
will discuss what we are learning and the decisions made for our implementation.
If you’re willing to participate to the discussion or getting involved and contribute to effort in any way, feel free to reach out, for example by starting a thread in <a href="https://github.com/jbossws/jbossws-cxf/discussions">our discussion space on GitHub</a>.</p>

<p>The next part of this blog post series is available <a href="https://jbossws.github.io/2023/06/23/webservices-cloud-testing-p2/">here</a>.</p>]]></content><author><name>Rebecca Searls</name></author><summary type="html"><![CDATA[The web services team is embarking on an exploration of technologies and strategies for running the JBossWS-CXF integration tests in a cloud environment. A series of blogs will follow that discuss the technologies evaluated and strategies tried in this quest.]]></summary></entry></feed>