<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 5. Advanced User Guide</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="JBoss Web Services Documentation"/><link rel="up" href="index.html" title="JBoss Web Services Documentation"/><link rel="prev" href="sid-3866751.html" title="Chapter 4. JAX-WS Tools"/><link rel="next" href="sid-4784150.html" title="Chapter 6. JBoss Modules"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sid-3866751.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="sid-4784150.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866738"/>Chapter 5. Advanced User Guide</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-Logging">5.1. Logging</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-JAXWSHandlerapproach">5.1.1. JAX-WS Handler approach</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-ApacheCXFapproach">5.1.2. Apache CXF approach</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-WS%5Csupport">5.2. WS-* support</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-Addressrewrite">5.3. Address rewrite</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-Serverconfigurationoptions">5.3.1. Server configuration options</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-Dynamicrewrite">5.3.2. Dynamic rewrite</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-Configurationthroughdeploymentdescriptor">5.4. Configuration through deployment descriptor</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-contextrootelement">5.4.1. context-root element</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-confignameandconfigfileelements">5.4.2. config-name and config-file elements</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-propertyelement">5.4.3. property element</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-portcomponentelement">5.4.4. component element</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-webservicedescriptionelement">5.4.5. webservice-description element</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-SchemavalidationofSOAPmessages">5.5. Schema validation of SOAP messages</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-JAXBIntroductions">5.6. JAXB Introductions</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866738_AdvancedUserGuide-WSDLsystempropertiesexpansion">5.7. WSDL system properties expansion</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-41713670">5.8. Predefined client and endpoint configurations</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-41713670_Predefinedclientandendpointconfigurations-Overview">5.8.1. Overview</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-41713670_Predefinedclientandendpointconfigurations-Assigningconfigurations">5.8.2. Assigning configurations</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-3866749">5.9. Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-3866749_Authentication-Authentication">5.9.1. Authentication</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866749_Authentication-JASPIAuthentication">5.9.2. JASPI Authentication</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-3866786">5.10. Apache CXF integration</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-3866786_ApacheCXFintegration-JBossWSintegrationlayerwithApacheCXF">5.10.1. JBossWS integration layer with Apache CXF</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866786_ApacheCXFintegration-BuildingWSapplicationstheJBossway">5.10.2. Building WS applications the JBoss way</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866786_ApacheCXFintegration-Bususage">5.10.3. Bus usage</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866786_ApacheCXFintegration-ServerSideIntegrationCustomization">5.10.4. Server Side Integration Customization</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866786_ApacheCXFintegration-ApacheCXFinterceptors">5.10.5. Apache CXF interceptors</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866786_ApacheCXFintegration-ApacheCXFfeatures">5.10.6. Apache CXF features</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866786_ApacheCXFintegration-Propertiesdrivenbeancreation">5.10.7. Properties driven bean creation</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866786_ApacheCXFintegration-HTTPConduitconfiguration">5.10.8. HTTPConduit configuration</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-3866793">5.11. Addressing</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-3866793_WS-Addressing-EnablingWSAddressing">5.11.1. Enabling WS-Addressing</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866793_WS-Addressing-WSAddressingPolicy">5.11.2. Addressing Policy</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866793_WS-Addressing-Example">5.11.3. Example</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-3866795">5.12. WS-Security</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-3866795_WS-Security-">5.12.1. WS-Security overview</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866795_WS-Security-JBossWSSecuritysupport">5.12.2. JBoss WS-Security support</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866795_WS-Security-Examples">5.12.3. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-47972359">5.13. WS-Trust and STS</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-47972359_WS-TrustandSTS-WSTrustoverview">5.13.1. WS-Trust overview</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-47972359_WS-TrustandSTS-SecurityTokenService">5.13.2. Security Token Service</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-47972359_WS-TrustandSTS-ApacheCXFsupport">5.13.3. Apache CXF support</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-47972359_WS-TrustandSTS-ABasicWSTrustScenario">5.13.4. A Basic WS-Trust Scenario</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-78711224">5.13.5. ActAs WS-Trust Scenario</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-78906783">5.13.6. OnBehalfOf WS-Trust Scenario</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-78906786">5.13.7. SAML Bearer Assertion Scenario</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-78906915">5.13.8. SAML Holder-Of-Key Assertion Scenario</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-3866797">5.14. WS-Reliable Messaging</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-3866797_WS-ReliableMessaging-EnablingWSReliableMessaging">5.14.1. Enabling WS-Reliable Messaging</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866797_WS-ReliableMessaging-Example">5.14.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-3866801">5.15. SOAP over JMS</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-3866801_SOAPoverJMS-ConfiguringSOAPoverJMS">5.15.1. Configuring SOAP over JMS</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-3866801_SOAPoverJMS-Examples">5.15.2. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-4784141">5.16. HTTP Proxy</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-4784141_HTTPProxy-Configuration">5.16.1. Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-66486377">5.17. WS-Discovery</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-66486377_WS-Discovery-EnablingWSDiscovery">5.17.1. Enabling WS-Discovery</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-66486377_WS-Discovery-Probingservices">5.17.2. Probing services</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-68354567">5.18. WS-Policy</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-68354567_WS-Policy-ApacheCXFWSPolicysupport">5.18.1. Apache CXF WS-Policy support</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-68354567_WS-Policy-JBossWSadditions">5.18.2. JBossWS additions</a></span></dt></dl></dd><dt><span class="section"><a href="sid-3866738.html#sid-83919125">5.19. Published WSDL customization</a></span></dt><dd><dl><dt><span class="section"><a href="sid-3866738.html#sid-83919125_PublishedWSDLcustomization-Endpointaddressrewrite">5.19.1. Endpoint address rewrite</a></span></dt><dt><span class="section"><a href="sid-3866738.html#sid-83919125_PublishedWSDLcustomization-Systempropertyreferences">5.19.2. System property references</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866738_AdvancedUserGuide-Logging"/>5.1. Logging</h2></div></div></div><p>Logging of inbound and outbound messages is a common need. Different approaches are available for achieving that:</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866738_AdvancedUserGuide-JAXWSHandlerapproach"/>5.1.1. JAX-WS Handler approach</h3></div></div></div><p>
          A portable way of performing logging is writing a simple JAX-WS handler dumping the messages that are passed in it; the handler can be added to the desired client/endpoints (programmatically / using
          <code class="code">@HandlerChain</code>
          JAX-WS annotation).
        </p><p>
          The
          <a href="sid-3866738.html#sid-41713670" title="5.8. Predefined client and endpoint configurations">predefined client and endpoint configuration</a>
          mechanism allows user to add the logging handler to any client/endpoint or to some of them only (in which case the
          <code class="code">@EndpointConfig</code>
          annotation / JBossWS API is required though).
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866738_AdvancedUserGuide-ApacheCXFapproach"/>5.1.2. Apache CXF approach</h3></div></div></div><p>Apache CXF also comes with logging interceptors that can be easily used to log messages to the console or configured client/server log files. Those interceptors can be added to client, endpoint and buses in multiple ways:</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866738_AdvancedUserGuide-Systemproperty"/>5.1.2.1. System property</h4></div></div></div><p>
            Setting the
            <code class="code">org.apache.cxf.logging.enabled</code>
            system property to true causes the logging interceptors to be added to any
            <code class="code">Bus</code>
            instance being created on the JVM.
          </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>On WildFly, the system property is easily set by adding what follows to the standalone / domain server configuration just after the extensions section:</p><div class="informalexample"><pre xmlns="" class="">&lt;system-properties&gt;
  &lt;property name="org.apache.cxf.logging.enabled" value="true"/&gt;
&lt;/system-properties&gt;</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866738_AdvancedUserGuide-Manualinterceptoradditionandloggingfeature"/>5.1.2.2. Manual interceptor addition and logging feature</h4></div></div></div><p>
            Logging interceptors can be selectively added to endpoints using the Apache CXF annotations
            <code class="code">@org.apache.cxf.interceptor.InInterceptors</code>
            and
            <code class="code">@org.apache.cxf.interceptor.OutInterceptors</code>
            . The same is achieved on client side by programmatically adding new instances of the logging interceptors to the client or the bus.
          </p><p>
            Apache CXF 3.2 has designated <code class="code">@org.apache.cxf.feature.Features</code> the preferred
            annotation for adding logging capabilites to clients and endpoints. Annotation
            <code class="code">@org.apache.cxf.annotations.Logging</code> and class
            <code class="code">org.apache.cxf.feature.LoggingFeature</code>
            have been deprecated.
          </p><p>
            Also in Apache CXF 3.2 classes <code class="code">LoggingInInterceptor, LoggingOutInterceptor,</code> and
            <code class="code">AbstractLoggingInterceptor</code> have been assigned a new package name. The classes in
            package <code class="code">org.apache.cxf.interceptor</code> have been deprecated.  These classes can
            now be found in package <code class="code">org.apache.cxf.ext.logging</code>.
          </p><p>
            Please refer to the
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/debugging-and-logging.html#DebuggingandLogging-LoggingMessages">Apache CXF documentation</a>
            for more details.
          </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866738_AdvancedUserGuide-WS%5Csupport"/>5.2. WS-* support</h2></div></div></div><p>JBossWS includes most of the WS-* specification functionalities through the integration with Apache CXF. In particular, the whole WS-Security Policy framework is fully supported, enabling full contract driven configuration of complex features like WS-Security.</p><p>In details information available further down in this documentation book.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866738_AdvancedUserGuide-Addressrewrite"/>5.3. Address rewrite</h2></div></div></div><p>
        JBossWS allows users to configure the
        <span class="italics">soap:address</span>
        attribute in the wsdl contract of deployed services.
      </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866738_AdvancedUserGuide-Serverconfigurationoptions"/>5.3.1. Server configuration options</h3></div></div></div><p>
          The configuration options are part of the
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/AS71/Web+services+configuration">webservices subsystem section</a>
          of the WildFly domain model.
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;subsystem xmlns="urn:jboss:domain:webservices:1.1" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xmlns:jaxwsconfig="urn:jboss:jbossws-jaxws-config:4.0"&gt;
  &lt;wsdl-host&gt;localhost&lt;/wsdl-host&gt;
  &lt;modify-wsdl-address&gt;true&lt;/modify-wsdl-address&gt;
&lt;!--
  &lt;wsdl-port&gt;8080&lt;/wsdl-port&gt;
  &lt;wsdl-secure-port&gt;8443&lt;/wsdl-secure-port&gt;
--&gt;
&lt;/subsystem&gt;
</pre></div><p>
          If the content of
          <span class="italics">&lt;soap:address&gt;</span>
          in the wsdl is a valid URL, JBossWS will not rewrite it unless
          <span class="italics">modify-wsdl-address</span>
          is true. If the content of
          <span class="italics">&lt;soap:address&gt;</span>
          is not a valid URL instead, JBossWS will always rewrite it using the attribute values given below. Please note that the variable
          <span class="italics">${jboss.bind.address}</span>
          can be used to set the address which the application is bound to at each startup.
        </p><p>The wsdl-secure-port and wsdl-port attributes are used to explicitly define the ports to be used for rewriting the SOAP address. If these attributes are not set, the ports will be identified by querying the list of installed connectors. If multiple connectors are found the port of the first connector is used.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866738_AdvancedUserGuide-Dynamicrewrite"/>5.3.2. Dynamic rewrite</h3></div></div></div><p>
          When the application server is bound to multiple addresses or non-trivial real-world network architectures cause request for different external addresses to hit the same endpoint, a static rewrite of the soap:address may not be enough. JBossWS allows for both the soap:address in the wsdl and the wsdl address in the console to be rewritten with the host use in the client request. This way, users always get the right wsdl address assuming they're connecting to an instance having the endpoint they're looking for. To trigger this behaviour, the
          <span class="italics">jbossws.undefined.host</span>
          value has to be specified for the
          <span class="italics">wsdl-host</span>
          element.
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;wsdl-host&gt;jbossws.undefined.host&lt;/wsdl-host&gt;
&lt;modify-wsdl-address&gt;true&lt;/modify-wsdl-address&gt;</pre></div><p>Of course, when a confidential transport address is required, the addresses are always rewritten using https protocol and the port currently configured for the https/ssl connector.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866738_AdvancedUserGuide-Configurationthroughdeploymentdescriptor"/>5.4. Configuration through deployment descriptor</h2></div></div></div><p>
        The
        <code class="code">jboss-webservices.xml</code>
        deployment descriptor can be used to provide additional configuration for a given deployment. The expected location of it is:
      </p><div class="itemizedlist"><ul><li><p>
            <code class="code">META-INF/jboss-webservices.xml</code>
            for EJB webservice deployments (JAR archives)
          </p></li><li><p>
            <code class="code">WEB-INF/jboss-webservices.xml</code>
            for POJO webservice deployments and EJB webservice endpoints bundled in
            <code class="code">WAR</code>
            archives
          </p></li><li><p>META-INF/jboss-webservices.xml for EAR archives containing webservices deployment archives.</p></li></ul></div><p>In case of jboss-webservices.xml descriptor included in both EAR and included JAR/WAR archive, the contents of the descriptor included in the JAR/WAR archives override the contents of the descriptor in the parent EAR archive.</p><p>
        The structure of file is the following (schemas are available
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://anonsvn.jboss.org/repos/jbossws/spi/trunk/src/main/resources/schema/">here</a>
        ):
      </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;webservices&gt;
  &lt;context-root/&gt;?
  &lt;config-name/&gt;?
  &lt;config-file/&gt;?
  &lt;property&gt;*
    &lt;name/&gt;
    &lt;value/&gt;
  &lt;/property&gt;
  &lt;port-component&gt;*
    &lt;ejb-name/&gt;
    &lt;port-component-name/&gt;
    &lt;port-component-uri/&gt;?
    &lt;auth-method/&gt;?
    &lt;transport-guarantee/&gt;?
    &lt;secure-wsdl-access/&gt;?
  &lt;/port-component&gt;
  &lt;webservice-description&gt;*
    &lt;webservice-description-name/&gt;
    &lt;wsdl-publish-location/&gt;?
  &lt;/webservice-description&gt;
&lt;/webservices&gt;
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866738_AdvancedUserGuide-contextrootelement"/>5.4.1. context-root element</h3></div></div></div><p>
          Element
          <code class="code">&lt;context-root&gt;</code>
          can be used to customize context root of webservices deployment.
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;webservices&gt;
  &lt;context-root&gt;foo&lt;/context-root&gt;
&lt;/webservices&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866738_AdvancedUserGuide-confignameandconfigfileelements"/>5.4.2. config-name and config-file elements</h3></div></div></div><p>
          Elements
          <code class="code">&lt;config-name&gt;</code>
          and
          <code class="code">&lt;config-file&gt;</code>
          can be used to associate any endpoint provided in the deployment with a given
          <a href="sid-3866738.html#sid-41713670" title="5.8. Predefined client and endpoint configurations">endpoint configuration</a>
          . Endpoint configuration are either specified in the referenced config file or in the WildFly domain model (webservices subsystem). For further details on the endpoint configurations and their management in the domain model, please see the related
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/AS71/Web+services+configuration">documentation</a>
          .
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;webservices&gt;
  &lt;config-name&gt;Standard WSSecurity Endpoint&lt;/config-name&gt;
  &lt;config-file&gt;META-INF/custom.xml&lt;/config-file&gt;
&lt;/webservices&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866738_AdvancedUserGuide-propertyelement"/>5.4.3. property element</h3></div></div></div><p>
          <code class="code">&lt;property&gt;</code>
          elements can be used to setup simple property values to configure the ws stack behavior. Allowed property names and values are mentioned in the guide under related topics.
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;property&gt;
  &lt;name&gt;prop.name&lt;/name&gt;
  &lt;value&gt;prop.value&lt;/value&gt;
&lt;/property&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866738_AdvancedUserGuide-portcomponentelement"/>5.4.4. component element</h3></div></div></div><p>
          Element
          <code class="code">&lt;port-component&gt;</code>
          can be used to customize EJB endpoint target URI or to configure security related properties.
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;webservices&gt;
  &lt;port-component&gt;
    &lt;ejb-name&gt;TestService&lt;/ejb-name&gt;
    &lt;port-component-name&gt;TestServicePort&lt;/port-component-name&gt;
    &lt;port-component-uri&gt;/*&lt;/port-component-uri&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
    &lt;transport-guarantee&gt;NONE&lt;/transport-guarantee&gt;
    &lt;secure-wsdl-access&gt;true&lt;/secure-wsdl-access&gt;
  &lt;/port-component&gt;
&lt;/webservices&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866738_AdvancedUserGuide-webservicedescriptionelement"/>5.4.5. webservice-description element</h3></div></div></div><p>
          Element
          <code class="code">&lt;webservice-description&gt;</code>
          can be used to customize (override) webservice WSDL publish location.
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;webservices&gt;
  &lt;webservice-description&gt;
    &lt;webservice-description-name&gt;TestService&lt;/webservice-description-name&gt;
    &lt;wsdl-publish-location&gt;file:///bar/foo.wsdl&lt;/wsdl-publish-location&gt;
  &lt;/webservice-description&gt;
&lt;/webservices&gt;
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866738_AdvancedUserGuide-SchemavalidationofSOAPmessages"/>5.5. Schema validation of SOAP messages</h2></div></div></div><p>Apache CXF has a feature for validating incoming and outgoing SOAP messages on both client and server side. The validation is performed against the relevant schema in the endpoint wsdl contract (server side) or the wsdl contract used for building up the service proxy (client side).</p><p>Schema validation can be turned on programmatically on client side</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">((BindingProvider)proxy).getRequestContext().put("schema-validation-enabled", true);</pre></div><p>
        or using the
        <code class="code">@org.apache.cxf.annotations.SchemaValidation</code>
        annotation on server side
      </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">import javax.jws.WebService;
import org.apache.cxf.annotations.SchemaValidation;

@WebService(...)
@SchemaValidation
public class ValidatingHelloImpl implements Hello {
   ...
}</pre></div><p>
        Alternatively, any endpoint and client running in-container can be associated to a JBossWS
        <a href="sid-3866738.html#sid-41713670" title="5.8. Predefined client and endpoint configurations">predefined configuration</a>
        having the
        <code class="code">schema-validation-enabled</code>
        property set to
        <code class="code">true</code>
        in the referenced config file.
      </p><p>
        Finally, JBossWS also allows for server-wide (default) setup of schema validation by using the
        <span class="italics">Standard-Endpoint-Config</span>
        and
        <span class="italics">Standard-Client-Config</span>
        special configurations (which apply to any client / endpoint unless a different configuration is specified for them)
      </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;subsystem xmlns="urn:jboss:domain:webservices:1.2"&gt;
    ...
    &lt;endpoint-config name="Standard-Endpoint-Config"&gt;
        &lt;property name="schema-validation-enabled" value="true"/&gt;
    &lt;/endpoint-config&gt;
    ...
    &lt;client-config name="Standard-Client-Config"&gt;
        &lt;property name="schema-validation-enabled" value="true"/&gt;
    &lt;/client-config&gt;
&lt;/subsystem&gt;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866738_AdvancedUserGuide-JAXBIntroductions"/>5.6. JAXB Introductions</h2></div></div></div><p>
        As Kohsuke Kawaguchi wrote on
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://weblogs.java.net/blog/kohsuke/archive/2007/07/binding_3rd_par.html">his blog</a>
        , one common complaint from the JAXB users is the lack of support for binding 3rd party classes. The scenario is this:  you are trying to annotate your classes with JAXB annotations to make it XML bindable, but some of the classes are coming from libraries and JDK, and thus you cannot put necessary JAXB annotations on it.
      </p><p>To solve this JAXB has been designed to provide hooks for programmatic introduction of annotations to the runtime.</p><p>This is currently leveraged by the JBoss JAXB Introductions project, using which users can define annotations in XML and make JAXB see those as if those were in the class files (perhaps coming from 3rd party libraries).</p><p>
        Take a look at the
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://community.jboss.org/docs/DOC-10075">JAXB Introductions page</a>
        on the wiki and at the examples in the sources.
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866738_AdvancedUserGuide-WSDLsystempropertiesexpansion"/>5.7. WSDL system properties expansion</h2></div></div></div><p>
        See
        <a href="sid-3866738.html#sid-83919125" title="5.19. Published WSDL customization">Section 5.19, “Published WSDL customization”</a>
        .
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-41713670"/>5.8. Predefined client and endpoint configurations</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-Overview"/>5.8.1. Overview</h3></div></div></div><p>JBossWS permits extra setup configuration data to be predefined and  associated with an endpoint or a client. Configurations can include JAX-WS  handlers and key/value property declarations that control JBossWS and  Apache CXF internals. Predefined configurations can be used  for JAX-WS client and JAX-WS endpoint setup.</p><p>
          Configurations can be defined in the webservice subsystem  and in an application's deployment descriptor file. There can  be many configuration definitions in the webservice subsystem  and in an application. Each configuration must have a name  that is unique within the server.  Configurations defined in an  application are local to the application. Endpoint implementations  declare the use of a specific configuration through the use of the
          <code class="code">org.jboss.ws.api.annotation.EndpointConfig</code>
          annotation. An endpoint  configuration defined in the webservices subsystem is available to all  deployed applications on the server container and can be referenced by name in the  annotation. An endpoint configuration defined in an application must be  referenced by both deployment descriptor file name and configuration  name by the annotation.
        </p><p>
          <span class="strong"><strong>Handlers</strong></span>
        </p><p>Each endpoint configuration may be associated with zero or more PRE and   POST handler chains. Each handler chain may include JAXWS handlers.   For outbound messages the PRE handler chains are executed before any   handler that is attached to the endpoint using the standard means, such   as with annotation @HandlerChain, and POST handler chains are executed   after those objects have executed. For inbound messages the POST   handler chains are executed before any handler that is attached to the   endpoint using the standard means and the PRE handler chains are   executed after those objects have executed.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">* Server inbound messages
Client --&gt; ... --&gt; POST HANDLER --&gt; ENDPOINT HANDLERS --&gt; PRE HANDLERS --&gt; Endpoint

* Server outbound messages
Endpoint --&gt; PRE HANDLER --&gt; ENDPOINT HANDLERS --&gt; POST HANDLERS --&gt; ... --&gt; Client</pre></div><p>The same applies for client configurations.</p><p>
          <span class="strong"><strong>Properties</strong></span>
        </p><p>Key/value properties are used for controlling both some Apache CXF internals and some JBossWS options. Specific supported values are mentioned where relevant in the rest of the documentation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-Assigningconfigurations"/>5.8.2. Assigning configurations</h3></div></div></div><p>Endpoints and clients are assigned configuration through different means. Users can explicitly require a given configuration or rely on container defaults. The assignment process can be split up as follows:</p><div class="itemizedlist"><ul><li><p>Explicit assignment through annotations (for endpoints) or API programmatic usage (for clients)</p></li><li><p>Automatic assignment of configurations from default descriptors</p></li><li><p>Automatic assignment of configurations from container</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-Explicitconfigurationassignment"/>5.8.2.1. Explicit configuration assignment</h4></div></div></div><p>The explicit configuration assignment is meant for developer that know in advance their endpoint or client has to be setup according to a specified configuration. The configuration is either coming from a descriptor that is included in the application deployment, or is included in the application server webservices subsystem management model.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-ConfigurationDeploymentDescriptor"/>5.8.2.1.1. Configuration Deployment Descriptor</h5></div></div></div><p>
              Java EE archives that can contain JAX-WS client and endpoint implementations can  also contain predefined client and endpoint configuration declarations.  All endpoint/client  configuration definitions for a given archive must be provided in a  single deployment descriptor file, which must be an  implementation of schema
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://anonsvn.jboss.org/repos/jbossws/spi/tags/jbossws-spi-2.1.0.Final/src/main/resources/schema/jbossws-jaxws-config_4_0.xsd">jbossws-jaxws-config</a>
              . Many  endpoint/client configurations can be defined in the deployment  descriptor  file. Each configuration must have a name that is unique  within the  server on which the application is deployed. The  configuration name can't be referred to by endpoint/client implementations  outside the application. Here is an example of a descriptor, containing two endpoint configurations:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.jbws3282.Endpoint4Impl&lt;/config-name&gt;
    &lt;pre-handler-chains&gt;
      &lt;javaee:handler-chain&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Log Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.jbws3282.LogHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
      &lt;/javaee:handler-chain&gt;
    &lt;/pre-handler-chains&gt;
    &lt;post-handler-chains&gt;
      &lt;javaee:handler-chain&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Routing Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.jbws3282.RoutingHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
      &lt;/javaee:handler-chain&gt;
    &lt;/post-handler-chains&gt;
  &lt;/endpoint-config&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;EP6-config&lt;/config-name&gt;
    &lt;post-handler-chains&gt;
      &lt;javaee:handler-chain&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Authorization Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.jbws3282.AuthorizationHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
      &lt;/javaee:handler-chain&gt;
    &lt;/post-handler-chains&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;
</pre></div><p>Similarly, client configurations can be specified in descriptors (still implementing the schema mentioned above):</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;client-config&gt;
    &lt;config-name&gt;Custom Client Config&lt;/config-name&gt;
    &lt;pre-handler-chains&gt;
      &lt;javaee:handler-chain&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Routing Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.clientConfig.RoutingHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Custom Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.clientConfig.CustomHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
      &lt;/javaee:handler-chain&gt;
    &lt;/pre-handler-chains&gt;
  &lt;/client-config&gt;
  &lt;client-config&gt;
    &lt;config-name&gt;Another Client Config&lt;/config-name&gt;
    &lt;post-handler-chains&gt;
      &lt;javaee:handler-chain&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Routing Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.clientConfig.RoutingHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
      &lt;/javaee:handler-chain&gt;
    &lt;/post-handler-chains&gt;
  &lt;/client-config&gt;
&lt;/jaxws-config&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-Applicationserverconfigurations"/>5.8.2.1.2. Application server configurations</h5></div></div></div><p>
              WildFly allows declaring JBossWS client and server predefined configurations in the
              <span class="italics">webservices</span>
              subsystem section of the server model. As a consequence it is possible to declare server-wide handlers to be added to the chain of each endpoint or client assigned to a given configuration.
            </p><p>
              Please refer to the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/WFLY9/Web+services+configuration">WildFly documentation</a>
              for details on managing the
              <span class="italics">webservices</span>
              subsystem such as adding, removing and modifying handlers and properties.
            </p><p>
              The allowed contents in the
              <span class="italics">webservices</span>
              subsystem are defined by the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://github.com/jbossas/jboss-as/blob/7.2.0.Final/build/src/main/resources/docs/schema/jboss-as-webservices_1_2.xsd">schema</a>
              included in the application server.
            </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-Standardconfigurations"/>5.8.2.1.2.1. Standard configurations</h6></div></div></div><p>
                Clients running in-container as well as endpoints are assigned standard configurations by default. The defaults are used unless different configurations are set as described on this page. This enables administrators to tune the default handler chains for client and endpoint configurations. The names of the default client and endpoint configurations, used in the webservices subsystem are
                <code class="code">Standard-Client-Config</code>
                and
                <code class="code">Standard-Endpoint-Config</code>
                respectively.
              </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-Handlersclassloading"/>5.8.2.1.2.2. Handlers classloading</h6></div></div></div><p>
                When setting a server-wide handler, please note the handler class needs to be available through each ws deployment classloader. As a consequence proper module dependencies might need to be specified in the deployments that are going to leverage a given predefined configuration. A shortcut is to add a dependency to the module containing the handler class in one of the modules which are already automatically set as dependencies to any deployment, for instance
                <code class="code">org.jboss.ws.spi</code>
                .
              </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-Examples"/>5.8.2.1.2.3. Examples</h6></div></div></div><div class="example"><a id="d0e3383"/><p class="title"><b>Example 5.1. JBoss AS 7.2 default configurations</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;subsystem xmlns="urn:jboss:domain:webservices:2.0"&gt;
    &lt;!-- ... --&gt;
    &lt;endpoint-config name="Standard-Endpoint-Config"/&gt;
    &lt;endpoint-config name="Recording-Endpoint-Config"&gt;
        &lt;pre-handler-chain name="recording-handlers" protocol-bindings="##SOAP11_HTTP ##SOAP11_HTTP_MTOM ##SOAP12_HTTP ##SOAP12_HTTP_MTOM"&gt;
            &lt;handler name="RecordingHandler" class="org.jboss.ws.common.invocation.RecordingServerHandler"/&gt;
        &lt;/pre-handler-chain&gt;
    &lt;/endpoint-config&gt;
    &lt;client-config name="Standard-Client-Config"/&gt;
&lt;/subsystem&gt;</pre></div></div><br class="example-break"/><div class="example"><a id="d0e3388"/><p class="title"><b>Example 5.2. A configuration file for a deployment specific ws-security endpoint setup</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:javaee="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom WS-Security Endpoint&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.username&lt;/property-name&gt;
      &lt;property-value&gt;bob&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.username&lt;/property-name&gt;
      &lt;property-value&gt;alice&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.callback-handler&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.KeystorePasswordCallback&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre></div></div><br class="example-break"/><div class="example"><a id="d0e3393"/><p class="title"><b>Example 5.3. JBoss AS 7.2 default configurations modified to default to SOAP messages schema-validation on</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;subsystem xmlns="urn:jboss:domain:webservices:2.0"&gt;
    &lt;!-- ... --&gt;
    &lt;endpoint-config name="Standard-Endpoint-Config"&gt;
        &lt;property name="schema-validation-enabled" value="true"/&gt;
    &lt;/endpoint-config&gt;
    &lt;!-- ... --&gt;
    &lt;client-config name="Standard-Client-Config"&gt;
        &lt;property name="schema-validation-enabled" value="true"/&gt;
    &lt;/client-config&gt;
&lt;/subsystem&gt;</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-EndpointConfigannotation"/>5.8.2.1.3. EndpointConfig annotation</h5></div></div></div><p>
              Once a configuration is available to a given application, the
              <code class="code">org.jboss.ws.api.annotation.EndpointConfig</code>
              annotation is used to assign  an endpoint configuration to a JAX-WS endpoint implementation. When  assigning a configuration that is defined in the webservices subsystem  only the configuration name is specified.  When assigning a  configuration that is defined in the application, the relative path to  the deployment descriptor and the configuration name must be specified.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@EndpointConfig(configFile = "WEB-INF/my-endpoint-config.xml", configName = "Custom WS-Security Endpoint")
public class ServiceImpl implements ServiceIface
{
   public String sayHello()
   {
      return "Secure Hello World!";
   }
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-JAXWSFeature"/>5.8.2.1.4. JAXWS Feature</h5></div></div></div><p>
              The most practical way of setting a configuration is using
              <code class="code">org.jboss.ws.api.configuration.ClientConfigFeature</code>
              , a JAXWS
              <code class="code">Feature</code>
              extension provided by JBossWS:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
import org.jboss.ws.api.configuration.ClientConfigFeature;

...

Service service = Service.create(wsdlURL, serviceName);
Endpoint port = service.getPort(Endpoint.class, new ClientConfigFeature("META-INF/my-client-config.xml", "Custom Client Config"));
port.echo("Kermit");

... or ....

port = service.getPort(Endpoint.class, new ClientConfigFeature("META-INF/my-client-config.xml", "Custom Client Config"), true); //setup properties too from the configuration
port.echo("Kermit");
... or ...

port = service.getPort(Endpoint.class, new ClientConfigFeature(null, testConfigName)); //reads from current container configurations if available
port.echo("Kermit");
</pre></div><p>
              JBossWS parses the specified configuration file.  The configuration file  must be found as a resource by the classloader of the current thread. The
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://anonsvn.jboss.org/repos/jbossws/spi/tags/jbossws-spi-2.1.0.Beta1/src/main/resources/schema/jbossws-jaxws-config_4_0.xsd">jbossws-jaxws-config schema</a>
              defines the descriptor contents and is included in the
              <span class="italics">jbossws-spi</span>
              artifact.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-ExplicitsetupthroughAPI"/>5.8.2.1.5. Explicit setup through API</h5></div></div></div><p>Alternatively, JBossWS API comes with facility classes that can be used  for assigning configurations when building a client. JAXWS handlers  read from client configurations as follows:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">import org.jboss.ws.api.configuration.ClientConfigUtil;
import org.jboss.ws.api.configuration.ClientConfigurer;

...

Service service = Service.create(wsdlURL, serviceName);
Endpoint port = service.getPort(Endpoint.class);
BindingProvider bp = (BindingProvider)port;
ClientConfigUtil.setConfigHandlers(bp, "META-INF/my-client-config.xml", "Custom Client Config 1");
port.echo("Kermit");

...

ClientConfigurer configurer = ClientConfigUtil.resolveClientConfigurer();
configurer.setConfigHandlers(bp, "META-INF/my-client-config.xml", "Custom Client Config 2");
port.echo("Kermit");

...

configurer.setConfigHandlers(bp, "META-INF/my-client-config.xml", "Custom Client Config 3");
port.echo("Kermit");


...

configurer.setConfigHandlers(bp, null, "Container Custom Client Config"); //reads from current container configurations if available
port.echo("Kermit");
</pre></div><p>... similarly, properties are read from client configurations as follows:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">import org.jboss.ws.api.configuration.ClientConfigUtil;
import org.jboss.ws.api.configuration.ClientConfigurer;

...

Service service = Service.create(wsdlURL, serviceName);
Endpoint port = service.getPort(Endpoint.class);

ClientConfigUtil.setConfigProperties(port, "META-INF/my-client-config.xml", "Custom Client Config 1");
port.echo("Kermit");

...

ClientConfigurer configurer = ClientConfigUtil.resolveClientConfigurer();
configurer.setConfigProperties(port, "META-INF/my-client-config.xml", "Custom Client Config 2");
port.echo("Kermit");

...

configurer.setConfigProperties(port, "META-INF/my-client-config.xml", "Custom Client Config 3");
port.echo("Kermit");


...

configurer.setConfigProperties(port, null, "Container Custom Client Config"); //reads from current container configurations if available
port.echo("Kermit");
</pre></div><p>
              The default
              <code class="code">ClientConfigurer</code>
              implementation parses the specified configuration file, if any, after having resolved it as a resources using the current thread context classloader. The
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://anonsvn.jboss.org/repos/jbossws/spi/tags/jbossws-spi-2.1.0.Beta1/src/main/resources/schema/jbossws-jaxws-config_4_0.xsd">jbossws-jaxws-config schema</a>
              defines the descriptor contents and is included in the
              <span class="italics">jbossws-spi</span>
              artifact.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-Automaticconfigurationfromdefaultdescriptors"/>5.8.2.2. Automatic configuration from default descriptors</h4></div></div></div><p>
            In some cases, the application developer might not be aware of the configuration that will need to be used for its client and endpoint implementation, perhaps because that's a concern of the application deployer. In other cases, explicit usage (compile time dependency) of JBossWS API might not be accepted. To cope with such scenarios, JBossWS allows including default client (
            <code class="code">jaxws-client-config.xml</code>
            ) and endpoint (
            <code class="code">jaxws-endpoint-config.xml</code>
            ) descriptor within the application (in its root), which are parsed for getting configurations any time a configuration file name is not specified.
          </p><p>If the configuration name is also not specified, JBossWS automatically looks for a configuration named the same as</p><div class="itemizedlist"><ul><li><p>the endpoint implementation class (full qualified name), in case of JAX-WS endpoints;</p></li><li><p>the service endpoint interface (full qualified name), in case of JAX-WS clients.</p></li></ul></div><p>
            No automatic configuration name is selected for
            <code class="code">Dispatch</code>
            clients.
          </p><p>
            So, for instance, an endpoint implementation class
            <code class="code">org.foo.bar.EndpointImpl</code>
            for which no pre-defined configuration is explicitly set will cause JBossWS to look for a
            <span class="italics">org.foo.bar.EndpointImpl</span>
            named configuration within a
            <span class="italics">jaxws-endpoint-config.xml</span>
            descriptor in the root of the application deployment. Similarly, on client side, a client proxy implementing
            <code class="code">org.foo.bar.Endpoint</code>
            interface (SEI) will have the setup read from a
            <span class="italics">org.foo.bar.Endpoint</span>
            named configuration in
            <span class="italics">jaxws-client-config.xml</span>
            descriptor.
          </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-41713670_Predefinedclientandendpointconfigurations-Automaticconfigurationassignmentfromcontainersetup"/>5.8.2.3. Automatic configuration assignment from container setup</h4></div></div></div><p>JBossWS fall-backs to getting predefined configurations from the container setup whenever no explicit configuration has been provided and the default descriptors are either not available or do not contain relevant configurations. This gives additional control on the JAX-WS client and endpoint setup to administrators, as the container setup can be managed independently from the deployed applications.</p><p>JBossWS hence accesses the webservices subsystem the same as explained above for explicitly named configuration; the default configuration names used for look are</p><div class="itemizedlist"><ul><li><p>the endpoint implementation class (full qualified name), in case of JAX-WS endpoints;</p></li><li><p>the service endpoint interface (full qualified name), in case of JAX-WS clients.</p></li></ul></div><p>
            <code class="code">Dispatch</code>
            clients are not automatically configured. If no configuration is found using names computed as above, the
            <code class="code">Standard-Client-Config</code>
            and
            <code class="code">Standard-Endpoint-Config</code>
            configurations are used for clients and endpoints respectively
          </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866749"/>5.9. Authentication</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866749_Authentication-Authentication"/>5.9.1. Authentication</h3></div></div></div><p>Here the simplest way to authenticate a web service user with JBossWS is explained.</p><p>First  we secure the access to the SLSB as we would do for normal (non web  service) invocations: this can be easily done through the @RolesAllowed,  @PermitAll, @DenyAll annotation. The allowed user roles can be set with  these annotations both on the bean class and on any of its business  methods.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Stateless
@RolesAllowed("friend")
public class EndpointEJB implements EndpointInterface
{
  ...
}</pre></div><p>Similarly POJO endpoints are secured the same way as we do for normal web applications in web.xml:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;security-constraint&gt;
  &lt;web-resource-collection&gt;
    &lt;web-resource-name&gt;All resources&lt;/web-resource-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/web-resource-collection&gt;
  &lt;auth-constraint&gt;
    &lt;role-name&gt;friend&lt;/role-name&gt;
  &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;

&lt;security-role&gt;
  &lt;role-name&gt;friend&lt;/role-name&gt;
&lt;/security-role&gt;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866749_Authentication-Specifythesecuritydomain"/>5.9.1.1. Specify the security domain</h4></div></div></div><p>
            Next, specify the security domain for this deployment. This is performed using the
            <code class="code">@SecurityDomain</code>
            annotation for EJB3 endpoints
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Stateless
@SecurityDomain("JBossWS")
@RolesAllowed("friend")
public class EndpointEJB implements EndpointInterface
{
  ...
}</pre></div><p>or modifying the jboss-web.xml for POJO endpoints</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;jboss-web&gt;
&lt;security-domain&gt;JBossWS&lt;/security-domain&gt;
&lt;/jboss-web&gt;
</pre></div><p>The security domain as well as its the authentication and authorization mechanisms are defined differently depending on the server in use.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866749_Authentication-UseBindingProvidertosetprincipal%2Fcredential"/>5.9.1.2. Use BindingProvider to set principal/credential</h4></div></div></div><p>
            A web service client may use the
            <code class="code">javax.xml.ws.BindingProvider</code>
            interface to set the username/password combination
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">URL wsdlURL = new File("resources/jaxws/samples/context/WEB-INF/wsdl/TestEndpoint.wsdl").toURL();
QName qname = new QName("http://org.jboss.ws/jaxws/context", "TestEndpointService");
Service service = Service.create(wsdlURL, qname);
port = (TestEndpoint)service.getPort(TestEndpoint.class);

BindingProvider bp = (BindingProvider)port;
bp.getRequestContext().put(BindingProvider.USERNAME_PROPERTY, "kermit");
bp.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY, "thefrog");</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866749_Authentication-UsingHTTPBasicAuthforsecurity"/>5.9.1.3. Using HTTP Basic Auth for security</h4></div></div></div><p>
            To enable HTTP Basic authentication you use the
            <code class="code">@WebContext</code>
            annotation on the bean class
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Stateless
@SecurityDomain("JBossWS")
@RolesAllowed("friend")
@WebContext(contextRoot="/my-cxt", urlPattern="/*", authMethod="BASIC", transportGuarantee="NONE", secureWSDLAccess=false)
public class EndpointEJB implements EndpointInterface
{
  ...
}</pre></div><p>
            For POJO endpoints, we modify the
            <span class="italics">web.xml</span>
            adding the auth-method element:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;login-config&gt;
  &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
  &lt;realm-name&gt;Test Realm&lt;/realm-name&gt;
&lt;/login-config&gt;</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866749_Authentication-JASPIAuthentication"/>5.9.2. JASPI Authentication</h3></div></div></div><p>A Java Authentication SPI (JASPI) provider can be configured in WildFly security subsystem to authenticate SOAP messages:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;security-domain name="jaspi"&gt;
      &lt;authentication-jaspi&gt;
          &lt;login-module-stack name="jaas-lm-stack"&gt;
             &lt;login-module code="UsersRoles" flag="required"&gt;
                  &lt;module-option name="usersProperties" value="jbossws-users.properties"/&gt;
                  &lt;module-option name="rolesProperties" value="jbossws-roles.properties"/&gt;
             &lt;/login-module&gt;
          &lt;/login-module-stack&gt;
          &lt;auth-module code="org.jboss.wsf.stack.cxf.jaspi.module.UsernameTokenServerAuthModule" login-module-stack-ref="jaas-lm-stack"/&gt;
     &lt;/authentication-jaspi&gt;
 &lt;/security-domain&gt;
</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
            For further information on configuring security domains in WildFly, please refer to
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/WFLY9/Security+subsystem+configuration">here</a>
            .
          </p></div><p>
          Here
          <code class="code">org.jboss.wsf.stack.cxf.jaspi.module.UsernameTokenServerAuthModule</code>
          is the class implementing
          <code class="code">javax.security.auth.message.module.ServerAuthModule</code>
          ,  which delegates to the proper login module to perform authentication using the credentials from WS-Security UsernameToken in the incoming SOAP message. Alternative implementations of
          <code class="code">ServerAuthModule</code>
          can be implemented and configured.
        </p><p>To enable JASPI authentication, the endpoint deployment needs to specify the security domain to use; that can be done in two different ways:</p><div class="itemizedlist"><ul><li><p>
              Setting the
              <code class="code">jaspi.security.domain</code>
              property in the
              <code class="code">jboss-webservices.xml</code>
              descriptor
            </p></li></ul></div><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.1" encoding="UTF-8"?&gt;
&lt;webservices
  xmlns="http://www.jboss.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="1.2"
  xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;

  &lt;property&gt;
    &lt;name&gt;jaspi.security.domain&lt;/name&gt;
    &lt;value&gt;jaspi&lt;/value&gt;
  &lt;/property&gt;

&lt;/webservices&gt;
</pre></div><div class="itemizedlist"><ul><li><p>
              Referencing (through
              <code class="code">@EndpointConfig</code>
              annotation) an endpoint config that sets the
              <code class="code">jaspi.security.domain</code>
              property
            </p></li></ul></div><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@EndpointConfig(configFile = "WEB-INF/jaxws-endpoint-config.xml", configName = "jaspiSecurityDomain")
public class ServiceEndpointImpl implements ServiceIface {
</pre></div><p>
          The
          <code class="code">jaspi.security.domain</code>
          property is specified as follows in the referenced descriptor:
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
	xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
	&lt;endpoint-config&gt;
		&lt;config-name&gt;jaspiSecurityDomain&lt;/config-name&gt;
		&lt;property&gt;
			&lt;property-name&gt;jaspi.security.domain&lt;/property-name&gt;
			&lt;property-value&gt;jaspi&lt;/property-value&gt;
		&lt;/property&gt;
	&lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;
</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
            If the JASPI security domain is specified in both
            <code class="code">jboss-webservices.xml</code>
            and config file referenced by
            <code class="code">@EndpointConfig</code>
            annotation, the JASPI security domain specified in
            <code class="code">jboss-webservices.xml</code>
            will take precedence.
          </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866786"/>5.10. Apache CXF integration</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866786_ApacheCXFintegration-JBossWSintegrationlayerwithApacheCXF"/>5.10.1. JBossWS integration layer with Apache CXF</h3></div></div></div><p>
          All JAX-WS functionalities provided by JBossWS on top of WildFly are currently served through a proper integration of the JBoss Web Services stack with most of the
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/">Apache CXF</a>
          project modules.
        </p><p>Apache CXF is an open source services framework. It allows building and developing services using frontend programming APIs (including JAX-WS), with services speaking a variety of protocols such as SOAP and XML/HTTP over a variety of transports such as HTTP and JMS.</p><p>
          The integration layer (
          <span class="italics">JBossWS-CXF</span>
          in short hereafter) is mainly meant for:
        </p><div class="itemizedlist"><ul><li><p>allowing using standard webservices APIs (including JAX-WS) on WildFly; this is performed internally leveraging Apache CXF without requiring the user to deal with it;</p></li><li><p>allowing using Apache CXF advanced features (including WS-*) on top of WildFly without requiring the user to deal with / setup / care about the required integration steps for running in such a container.</p></li></ul></div><p>In order for achieving the goals above, the JBossWS-CXF integration supports the JBoss ws endpoint deployment mechanism and comes with many internal customizations on top of Apache CXF.</p><p>
          In the next sections a list of technical suggestions and notes on the integration is provided; please also refer to the
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/index.html">Apache CXF official documentation</a>
          for in-depth details on the CXF architecture.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866786_ApacheCXFintegration-BuildingWSapplicationstheJBossway"/>5.10.2. Building WS applications the JBoss way</h3></div></div></div><p>
          The Apache CXF client and endpoint configuration as explained in the
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/index.html">Apache CXF official user guide</a>
          is heavily based on Spring. Apache CXF basically parses Spring
          <code class="code">cxf.xml</code>
          descriptors; those may contain any basic bean plus specific ws client and endpoint beans which CXF has custom parsers for. Apache CXF can be used to deploy webservice endpoints on any servlet container by including its libraries in the deployment; in such a scenario Spring basically serves as a convenient configuration option, given direct Apache CXF API usage won't be very handy. Similar reasoning applies on client side, where a Spring based descriptor offers a shortcut for setting up Apache CXF internals.
        </p><p>This said, nowadays almost any Apache CXF functionality can be configured and used through direct API usage, without Spring. As a consequence of that and given the considerations in the sections below, the JBossWS integration with Apache CXF does not rely on Spring descriptors.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866786_ApacheCXFintegration-Portableapplications"/>5.10.2.1. Portable applications</h4></div></div></div><p>WildFly is much more then a servlet container; it actually provides users with a fully compliant target platform for Java EE applications.</p><p>
            Generally speaking,
            <span class="italics">users are encouraged to write portable applications</span>
            by relying only on
            <span class="italics">JAX-WS specification</span>
            whenever possible. That would by the way ensure easy migrations to and from other compliant platforms. Being a Java EE container, WildFlt already comes with a JAX-WS compliant implementation, which is basically Apache CXF plus the JBossWS-CXF integration layer. So users just need to write their JAX-WS application;
            <span class="italics">no need for embedding any Apache CXF or any ws related dependency library in user deployments</span>
            . Please refer to the
            <a href="sid-3866716.html" title="Chapter 3. JAX-WS User Guide">Chapter 3, <i xmlns:xlink="http://www.w3.org/1999/xlink">JAX-WS User Guide</i></a>
            section of the documentation for getting started.
          </p><p>
            WS-* usage (including WS-Security, WS-Addressing, WS-ReliableMessaging, ...) should also be configured in the most portable way; that is by
            <span class="italics">relying on proper WS-Policy assertions</span>
            on the endpoint WSDL contracts, so that client and endpoint configuration is basically a matter of setting few ws context properties. The WS-* related sections of this documentation cover all the details on configuring applications making use of WS-* through policies.
          </p><p>
            As a consequence of the reasoning above, the JBossWS-CXF integration is currently built directly on the Apache CXF API and aims at allowing users to configure webservice clients and endpoints
            <span class="italics">without Spring descriptors</span>
            .
          </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866786_ApacheCXFintegration-DirectApacheCXFAPIusage"/>5.10.2.2. Direct Apache CXF API usage</h4></div></div></div><p>Whenever users can't really meet their application requirements with JAX-WS plus WS-Policy, it is of course still possible to rely on direct Apache CXF API usage (given that's included in the AS), loosing the Java EE portability of the application. That could be the case of a user needing specific Apache CXF functionalities, or having to consume WS-* enabled endpoints advertised through legacy wsdl contracts without WS-Policy assertions.</p><p>
            On server side, direct Apache CXF API usage might not be always possible or end up being not very easy. For this reason, the JBossWS integration comes with a convenient alternative through customization options in the
            <code class="code">jboss-webservices.xml</code>
            descriptor described below on this page. Properties can be declared in
            <code class="code">jboss-webservices.xml</code>
            to control Apache CXF internals like
            <span class="italics">interceptors</span>
            ,
            <span class="italics">features</span>
            , etc.
          </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866786_ApacheCXFintegration-Bususage"/>5.10.3. Bus usage</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866786_ApacheCXFintegration-CreatingaBusinstance"/>5.10.3.1. Creating a Bus instance</h4></div></div></div><p>
            Most of the Apache CXF features are configurable using the
            <code class="code">org.apache.cxf.Bus</code>
            class. While for basic JAX-WS usage the user might never need to explicitly deal with Bus, using Apache CXF specific features generally requires getting a handle to a
            <code class="code">org.apache.cxf.Bus</code>
            instance. This can happen on client side as well as in a ws endpoint or handler business code.
          </p><p>
            New Bus instances are produced by the currently configured
            <code class="code">org.apache.cxf.BusFactory</code>
            implementation the following way:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Bus bus = BusFactory.newInstance().createBus();</pre></div><p>
            The algorithm for selecting the actual implementation of
            <code class="code">BusFactory</code>
            to be used leverages the Service API, basically looking for optional configurations in
            <span class="italics">META-INF/services/...</span>
            location using the current thread context classloader. JBossWS-CXF integration comes with its own implementation of
            <code class="code">BusFactory</code>
            ,
            <code class="code">org.jboss.wsf.stack.cxf.client.configuration.JBossWSBusFactory</code>
            , that allows for seamless setup of JBossWS customizations on top of Apache CXF. So, assuming the JBossWS-CXF libraries are available in the current thread context classloader, the
            <code class="code">JBossWSBusFactory</code>
            is
            <span class="italics">automatically</span>
            retrieved by the
            <code class="code">BusFactory.newInstance()</code>
            call above.
          </p><p>
            JBossWS users willing to explicitly use functionalities of
            <code class="code">org.apache.cxf.bus.CXFBusFactory</code>
            <span class="italics">,</span>
            get the same API with JBossWS additions through
            <code class="code">JBossWSBusFactory</code>
            :
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Map&lt;Class, Object&gt; myExtensions = new HashMap&lt;Class, Object&gt;();
myExtensions.put(...);
Bus bus = new JBossWSBusFactory().createBus(myExtensions);</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866786_ApacheCXFintegration-UsingexistingBusinstances"/>5.10.3.2. Using existing Bus instances</h4></div></div></div><p>
            Apache CXF keeps reference to a global default
            <code class="code">Bus</code>
            instance as well as to a thread default bus for each thread. That is performed through static members in
            <code class="code">org.apache.cxf.BusFactory</code>
            <span class="italics">,</span>
            which also comes with the following methods in the public API:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
public static synchronized Bus getDefaultBus()
public static synchronized Bus getDefaultBus(boolean createIfNeeded)
public static synchronized void setDefaultBus(Bus bus)
public static Bus getThreadDefaultBus()
public static Bus getThreadDefaultBus(boolean createIfNeeded)
public static void setThreadDefaultBus(Bus bus)
</pre></div><p>
            Please note that the default behaviour of
            <code class="code">getDefaultBus()</code>
            <span class="italics">/</span>
            <code class="code">getDefaultBus(true)</code>
            <span class="italics">/</span>
            <code class="code">getThreadDefaultBus()</code>
            <span class="italics">/</span>
            <code class="code">getThreadDefaultBus(true)</code>
            is to create a new Bus instance if that's not set yet. Moreover
            <span class="italics">getThreadDefaultBus()</span>
            and
            <span class="italics">getThreadDefaultBus(true)</span>
            first fallback to retrieving the configured global default bus before actually trying creating a new instance (and the created new instance is set as global default bus if that was not set there yet).
          </p><p>The drawback of this mechanism (which is basically fine in JSE environment) is that when running in WildFly container you need to be careful in order not to (mis)use a bus over multiple applications (assuming the Apache CXF classes are loaded by the same classloader, which is currently the case with WildFly).</p><p>Here is a list of general suggestions to avoid problems when running in-container:</p><div class="itemizedlist"><ul><li><p>
                forget about the global default bus; you don't need that, so don't do
                <code class="code">getDefaultBus()</code>
                <span class="italics">/</span>
                <code class="code">getDefaultBus(true)</code>
                <span class="italics">/</span>
                <code class="code">setDefaultBus()</code>
                in your code;
              </p></li><li><p>
                avoid
                <code class="code">getThreadDefaultBus()</code>
                <span class="italics">/</span>
                <code class="code">getThreadDefaultBus(true)</code>
                unless you already know for sure the default bus is already set;
              </p></li><li><p>keep in mind thread pooling whenever you customize a thread default bus instance (for instance adding bus scope interceptors, ...), as that thread and bus might be later reused; so either shutdown the bus when you're done or explicitly remove it from the BusFactory thread association.</p></li></ul></div><p>Finally, remember that each time you explictly create a new Bus instance (factory.createBus()) that is set as thread default bus and global default bus if those are not set yet.</p><p>
            The JAXWS
            <code class="code">Provider</code>
            implementation also creates
            <code class="code">Bus</code>
            instances internally, in particular the JBossWS version of JAXWS
            <code class="code">Provider</code>
            makes sure the default bus is never internally used and instead a new
            <code class="code">Bus</code>
            is created if required (more details on this in the next paragraph).
          </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866786_ApacheCXFintegration-BusselectionstrategiesforJAXWSclients"/>5.10.3.3. Bus selection strategies for JAXWS clients</h4></div></div></div><p>
            JAXWS clients require an Apache CXF Bus to be available; the client is registered within the Bus and the Bus affects the client behavior (e.g. through the configured CXF interceptors). The way a bus is internally selected for serving a given JAXWS client is very important, especially for in-container clients; for this reason, JBossWS users can choose the preferred Bus selection strategy. The strategy is enforced in the
            <code class="code">javax.xml.ws.spi.Provider</code>
            implementation from the JBossWS integration, being that called whenever a JAXWS
            <code class="code">Service</code>
            (client) is requested.
          </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-Threadbusstrategy%28THREADBUS%29"/>5.10.3.3.1. Thread bus strategy (THREAD_BUS)</h5></div></div></div><p>Each time the vanilla JAXWS api is used to create a Bus, the JBossWS-CXF integration will automatically make sure a Bus is currently associated to the current thread in the BusFactory. If that's not the case, a new Bus is created and linked to the current thread (to prevent the user from relying on the default Bus). The Apache CXF engine will then create the client using the current thread Bus.</p><p>This is the default strategy, and the most straightforward one in Java SE environments; it lets users automatically reuse a previously created Bus instance and allows using customized Bus that can possibly be created and associated to the thread before building up a JAXWS client.</p><p>The drawback of the strategy is that the link between the Bus instance and the thread needs to be eventually cleaned up (when not needed anymore). This is really evident in a Java EE environment (hence when running in-container), as threads from pools (e.g. serving web requests) are re-used.</p><p>
              When relying on this strategy, the safest approach to be sure of cleaning up the link is to surround the JAXWS client with a
              <code class="code">try/finally</code>
              block as below:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">try {
  Service service = Service.create(wsdlURL, serviceQName);
  MyEndpoint port = service.getPort(MyEndpoint.class);
  //...
} finally {
  BusFactory.setThreadDefaultBus(null);
  // OR (if you don't need the bus and the client anymore)
  Bus bus = BusFactory.getThreadDefaultBus(false);
  bus.shutdown(true);
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-Newbusstrategy%28NEWBUS%29"/>5.10.3.3.2. New bus strategy (NEW_BUS)</h5></div></div></div><p>Another strategy is to have the JAXWS Provider from the JBossWS integration create a new Bus each time a JAXWS client is built. The main benefit of this approach is that a fresh bus won't rely on any formerly cached information (e.g. cached WSDL / schemas) which might have changed after the previous client creation. The main drawback is of course worse performance as the Bus creation takes time.</p><p>If there's a bus already associated to the current thread before the JAXWS client creation, that is automatically restored when returning control to the user; in other words, the newly created bus will be used only for the created JAXWS client but won't stay associated to the current thread at the end of the process. Similarly, if the thread was not associated to any bus before the client creation, no bus will be associated to the thread at the end of the client creation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-Threadcontextclassloaderbusstrategy%28TCCLBUS%29"/>5.10.3.3.3. Thread context classloader bus strategy (TCCL_BUS)</h5></div></div></div><p>The last strategy is to have the bus created for serving the client be associated to the current thread context classloader (TCCL). That basically means the same Bus instance is shared by JAXWS clients running when the same TCCL is set. This is particularly interesting as each web application deployment usually has its own context classloader, so this strategy is possibly a way to keep the number of created Bus instances bound to the application number in a WildFly container.</p><p>If there's a bus already associated to the current thread before the JAXWS client creation, that is automatically restored when returning control to the user; in other words, the bus corresponding to the current thread context classloader will be used only for the created JAXWS client but won't stay associated to the current thread at the end of the process. If the thread was not associated to any bus before the client creation, a new bus will be created (and later user for any other client built with this strategy and the same TCCL in place); no bus will be associated to the thread at the end of the client creation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-Strategyconfiguration"/>5.10.3.3.4. Strategy configuration</h5></div></div></div><p>
              Users can request a given Bus selection strategy to be used for the client being built by specifying one of the following JBossWS features (which extend
              <code class="code">javax</code>
              <code class="code">.</code>
              <code class="code">xml</code>
              <code class="code">.</code>
              <code class="code">ws</code>
              <code class="code">.</code>
              <code class="code">WebServiceFeature</code>
              ):
            </p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                      <p>Feature</p>
                    </th><th>
                      <p>Strategy</p>
                    </th></tr></thead><tbody><tr><td>
                      <p>
                        <code class="code">org.jboss.wsf.stack.cxf.client.UseThreadBusFeature</code>
                      </p>
                    </td><td>
                      <p>THREAD_BUS</p>
                    </td></tr><tr><td>
                      <p>
                        <code class="code">org</code>
                        <code class="code">.</code>
                        <code class="code">jboss</code>
                        <code class="code">.</code>
                        <code class="code">wsf</code>
                        <code class="code">.</code>
                        <code class="code">stack</code>
                        <code class="code">.</code>
                        <code class="code">cxf</code>
                        <code class="code">.</code>
                        <code class="code">client.</code>
                        <code class="code">UseNewBusFeature</code>
                      </p>
                    </td><td>
                      <p>NEW_BUS</p>
                    </td></tr><tr><td>
                      <p>
                        <code class="code">org</code>
                        <code class="code">.</code>
                        <code class="code">jboss</code>
                        <code class="code">.</code>
                        <code class="code">wsf</code>
                        <code class="code">.</code>
                        <code class="code">stack</code>
                        <code class="code">.</code>
                        <code class="code">cxf</code>
                        <code class="code">.</code>
                        <code class="code">client.</code>
                        <code class="code">UseTCCLBusFeature</code>
                      </p>
                    </td><td>
                      <p>TCCL_BUS</p>
                    </td></tr></tbody></table></div><p>The feature is specified as follows:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Service service = Service.create(wsdlURL, serviceQName, new UseThreadBusFeature());</pre></div><p>
              If no feature is explicitly specified, the system default strategy is used, which can be modified through the
              <code class="code">org.jboss.ws.cxf.jaxws-client.bus.strategy</code>
              system property when starting the JVM. The valid values for the property are
              <code class="code">THREAD_BUS</code>
              ,
              <code class="code">NEW_BUS</code>
              and
              <code class="code">TCCL_BUS</code>
              . The default is
              <code class="code">THREAD_BUS</code>
              .
            </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866786_ApacheCXFintegration-ServerSideIntegrationCustomization"/>5.10.4. Server Side Integration Customization</h3></div></div></div><p>
          The JBossWS-CXF server side integration takes care of internally creating proper Apache CXF structures (including a
          <code class="code">Bus</code>
          instance, of course) for the provided ws deployment. Should the deployment include multiple endpoints, those would all live within the same Apache CXF Bus, which would of course be completely separated by the other deployments' bus instances.
        </p><p>
          While JBossWS sets sensible defaults for most of the Apache CXF configuration options on server side, users might want to fine tune the
          <code class="code">Bus</code>
          instance that's created for their deployment; a
          <code class="code">jboss-webservices.xml</code>
          descriptor can be used for deployment level customizations.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866786_ApacheCXFintegration-Deploymentdescriptorproperties"/>5.10.4.1. Deployment descriptor properties</h4></div></div></div><p>
            The
            <code class="code">jboss-webservices.xml</code>
            descriptor can be used to
            <a href="sid-3866738.html" title="Chapter 5. Advanced User Guide">provide property values</a>
            .
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;webservices xmlns="http://www.jboss.com/xml/ns/javaee" version="1.2"&gt;
  ...
  &lt;property&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;value&gt;...&lt;/value&gt;
  &lt;/property&gt;
  ...
&lt;/webservices&gt;</pre></div><p>JBossWS-CXF integration comes with a set of allowed property names to control Apache CXF internals.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-WorkQueueconfiguration"/>5.10.4.1.1. WorkQueue configuration</h5></div></div></div><p>
              Apache CXF uses WorkQueue instances for dealing with some operations (e.g. @Oneway requests processing). A
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/javadoc/latest-2.5.x/org/apache/cxf/workqueue/WorkQueueManager.html">WorkQueueManager</a>
              is installed in the Bus as an extension and allows for adding / removing queues as well as controlling the existing ones.
            </p><p>
              On server side, queues can be provided by using the
              <code class="code">cxf.queue.&lt;queue-name&gt;.*</code>
              properties in
              <code class="code">jboss-webservices.xml</code>
              (e.g.
              <code class="code">cxf.queue.default.maxQueueSize</code>
              for controlling the max queue size of the
              <code class="code">default</code>
              workqueue). At deployment time, the JBossWS integration can add new instances of
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/javadoc/latest-2.5.x/org/apache/cxf/workqueue/AutomaticWorkQueueImpl.html">AutomaticWorkQueueImpl</a>
              to the currently configured WorkQueueManager; the properties below are used to fill in parameter into the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/javadoc/latest-2.5.x/org/apache/cxf/workqueue/AutomaticWorkQueueImpl.html#AutomaticWorkQueueImpl(int, int, int, int, long, java.lang.String)">AutomaticWorkQueueImpl constructor</a>
              :
            </p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                      <p>Property</p>
                    </th><th>
                      <p>Default value</p>
                    </th></tr></thead><tbody><tr><td>
                      <p>
                        <code class="code">cxf.queue.&lt;queue-name&gt;.maxQueueSize</code>
                      </p>
                    </td><td>
                      <p>256</p>
                    </td></tr><tr><td>
                      <p>
                        <code class="code">cxf.queue.&lt;queue-name&gt;.initialThreads</code>
                        
                      </p>
                    </td><td>
                      <p>0</p>
                    </td></tr><tr><td>
                      <p>
                        <code class="code">cxf.queue.&lt;queue-name&gt;.highWaterMark</code>
                        
                      </p>
                    </td><td>
                      <p>25</p>
                    </td></tr><tr><td>
                      <p>
                        <code class="code">cxf.queue.&lt;queue-name&gt;.lowWaterMark</code>
                        
                      </p>
                    </td><td>
                      <p>5</p>
                    </td></tr><tr><td>
                      <p>
                        <code class="code">cxf.queue.&lt;queue-name&gt;.dequeueTimeout</code>
                        
                      </p>
                    </td><td>
                      <p>120000</p>
                    </td></tr></tbody></table></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-Policyalternativeselector"/>5.10.4.1.2. Policy alternative selector</h5></div></div></div><p>
              The Apache CXF policy engine supports different strategies to deal with policy alternatives. JBossWS-CXF integration currently defaults to the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/javadoc/latest-2.5.x/org/apache/cxf/ws/policy/selector/MaximalAlternativeSelector.html">MaximalAlternativeSelector</a>
              , but still allows for setting different selector implementation using the
              <code class="code">cxf.policy.alternativeSelector</code>
              property in
              <code class="code">jboss-webservices.xml</code>
              .
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-MBeanmanagement"/>5.10.4.1.3. MBean management</h5></div></div></div><p>
              Apache CXF allows managing its MBean objects that are installed into the WildFly MBean server. The feature is enabled on a deployment basis through the
              <code class="code">cxf.management.enabled</code>
              property in
              <code class="code">jboss-webservices.xml</code>
              . The
              <code class="code">cxf.management.installResponseTimeInterceptors</code>
              property can also be used to control installation of CXF response time interceptors, which are added by default when enabling MBean management, but might not be desired in some cases. Here is an example:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;webservices xmlns="http://www.jboss.com/xml/ns/javaee" version="1.2"&gt;
  &lt;property&gt;
    &lt;name&gt;cxf.management.enabled&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;cxf.management.installResponseTimeInterceptors&lt;/name&gt;
    &lt;value&gt;false&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-Schemavalidation"/>5.10.4.1.4. Schema validation</h5></div></div></div><p>
              Schema validation of exchanged messages can also be enabled in
              <code class="code">jboss-webservices.xml</code>
              . Further details available
              <a href="sid-3866738.html" title="Chapter 5. Advanced User Guide">here</a>
              .
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-Interceptors"/>5.10.4.1.5. Interceptors</h5></div></div></div><p>
              The
              <code class="code">jboss-webservices.xml</code>
              descriptor also allows specifying the
              <code class="code">cxf.interceptors.in</code>
              and
              <code class="code">cxf.interceptors.out</code>
              properties; those allows declaring interceptors to be attached to the Bus instance that's created for serving the deployment.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.1" encoding="UTF-8"?&gt;
&lt;webservices
  xmlns="http://www.jboss.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="1.2"
  xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;

  &lt;property&gt;
    &lt;name&gt;cxf.interceptors.in&lt;/name&gt;
    &lt;value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.BusInterceptor&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;cxf.interceptors.out&lt;/name&gt;
    &lt;value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.BusCounterInterceptor&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-Features"/>5.10.4.1.6. Features</h5></div></div></div><p>
              The
              <code class="code">jboss-webservices.xml</code>
              descriptor also allows specifying the
              <code class="code">cxf.features</code>
              property; that allows declaring features to be attached to any endpoint belonging to the Bus instance that's created for serving the deployment.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.1" encoding="UTF-8"?&gt;
&lt;webservices
  xmlns="http://www.jboss.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="1.2"
  xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;

  &lt;property&gt;
    &lt;name&gt;cxf.features&lt;/name&gt;
    &lt;value&gt;org.apache.cxf.feature.FastInfosetFeature&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866786_ApacheCXFintegration-WSDiscoveryenablement"/>5.10.4.1.7. Discovery enablement</h5></div></div></div><p>
              WS-Discovery support can be turned on in
              <code class="code">jboss-webservices</code>
              for the current deployment. Further details available
              <a href="sid-3866738.html#sid-66486377" title="5.17. WS-Discovery">here</a>
              .
            </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866786_ApacheCXFintegration-ApacheCXFinterceptors"/>5.10.5. Apache CXF interceptors</h3></div></div></div><p>Apache CXF supports declaring interceptors using one of the following approaches:</p><div class="itemizedlist"><ul><li><p>
              Annotation usage on endpoint classes (
              <code class="code">@org.apache.cxf.interceptor.InInterceptor</code>
              ,
              <code class="code">@org.apache.cxf.interceptor.OutInterceptor</code>
              )
            </p></li><li><p>
              Direct API usage on client side (through the
              <code class="code">org.apache.cxf.interceptor.InterceptorProvider</code>
              interface)
            </p></li><li><p>
              Spring descriptor usage (
              <span class="italics">cxf.xml</span>
              )
            </p></li></ul></div><p>
          As the Spring descriptor usage is not supported, the JBossWS integration adds an additional descriptor based approach to avoid requiring modifications to the actual client/endpoint code. Users can declare interceptors within
          <a href="sid-3866738.html#sid-41713670" title="5.8. Predefined client and endpoint configurations">predefined client and endpoint configurations</a>
          by specifying a list of interceptor class names for the
          <code class="code">cxf.interceptors.in</code>
          and
          <code class="code">cxf.interceptors.out</code>
          properties.
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.cxf.interceptors.EndpointImpl&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.interceptors.in&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.EndpointInterceptor,org.jboss.test.ws.jaxws.cxf.interceptors.FooInterceptor&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.interceptors.out&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.EndpointCounterInterceptor&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre></div><p>A new instance of each specified interceptor class will be added to the client or endpoint the configuration is assigned to. The interceptor classes must have a no-argument constructor.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866786_ApacheCXFintegration-ApacheCXFfeatures"/>5.10.6. Apache CXF features</h3></div></div></div><p>Apache CXF supports declaring features using one of the following approaches:</p><div class="itemizedlist"><ul><li><p>
              Annotation usage on endpoint classes (
              <code class="code">@org.apache.cxf.feature.Features</code>
              )
            </p></li><li><p>
              Direct API usage on client side (through extensions of the
              <code class="code">org.apache.cxf.feature.AbstractFeature</code>
              class)
            </p></li><li><p>
              Spring descriptor usage (
              <span class="italics">cxf.xml</span>
              )
            </p></li></ul></div><p>
          As the Spring descriptor usage is not supported, the JBossWS integration adds an additional descriptor based approach to avoid requiring modifications to the actual client/endpoint code. Users can declare features within
          <a href="sid-3866738.html#sid-41713670" title="5.8. Predefined client and endpoint configurations">predefined client and endpoint configurations</a>
          by specifying a list of feature class names for the
          <code class="code">cxf.features</code>
          property.
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom FI Config&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;org.apache.cxf.feature.FastInfosetFeature&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre></div><p>A new instance of each specified feature class will be added to the client or endpoint the configuration is assigned to. The feature classes must have a no-argument constructor.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866786_ApacheCXFintegration-Propertiesdrivenbeancreation"/>5.10.7. Properties driven bean creation</h3></div></div></div><p>
          Sections above explain how to declare CXF interceptors and features through properties either in a client/endpoint predefined configuration or in a
          <code class="code">jboss-webservices.xml</code>
          descriptor. By getting the feature/interceptor class name only specified, the container simply tries to create a bean instance using the class default constructor. This sets a limitation on the feature/interceptor configuration, unless custom extensions of vanilla CXF classes are provided, with the default constructor setting properties before eventually using the super constructor.
        </p><p>
          To cope with this issue, JBossWS integration comes with a mechanism for configuring simple bean hierarchies when building them up from properties. Properties can have bean reference values, that is strings starting with
          <code class="code">##</code>
          . Property reference keys are used to specify the bean class name and the value for for each attribute. So for instance the following properties:
        </p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                  <p>
                    Key
                    
                  </p>
                </th><th>
                  <p>
                    Value
                    
                  </p>
                </th></tr></thead><tbody><tr><td>
                  <p>
                    cxf.features
                    
                  </p>
                </td><td>
                  <p>
                    ##foo, ##bar
                    
                  </p>
                </td></tr><tr><td>
                  <p>
                    ##foo
                    
                  </p>
                </td><td>
                  <p>
                    org.jboss.Foo
                    
                  </p>
                </td></tr><tr><td>
                  <p>
                    ##foo.par
                    
                  </p>
                </td><td>
                  <p>
                    34
                    
                  </p>
                </td></tr><tr><td>
                  <p>
                    ##bar
                    
                  </p>
                </td><td>
                  <p>
                    org.jboss.Bar
                    
                  </p>
                </td></tr><tr><td>
                  <p>
                    ##bar.color
                    
                  </p>
                </td><td>
                  <p>
                    blue
                    
                  </p>
                </td></tr></tbody></table></div><p>would result into the stack installing two feature instances, the same that would have been created by</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">import org.Bar;
import org.Foo;

...

Foo foo = new Foo();
foo.setPar(34);
Bar bar = new Bar();
bar.setColor("blue");</pre></div><p>The mechanism assumes that the classes are valid beans with proper getter and setter methods; value objects are cast to the correct primitive type by inspecting the class definition. Nested beans can of course be configured.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866786_ApacheCXFintegration-HTTPConduitconfiguration"/>5.10.8. HTTPConduit configuration</h3></div></div></div><p>
          HTTP transport setup in Apache CXF is achieved through
          <code class="code">org.apache.cxf.transport.http.HTTPConduit</code>
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/client-http-transport-including-ssl-support.html">configurations</a>
          . When running on top of the JBossWS integration, conduits can be programmatically modified using the Apache CXF API as follows:
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">import org.apache.cxf.frontend.ClientProxy;
import org.apache.cxf.transport.http.HTTPConduit;
import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;

//set chunking threshold before using a JAX-WS port client
...
HTTPConduit conduit = (HTTPConduit)ClientProxy.getClient(port).getConduit();
HTTPClientPolicy client = conduit.getClient();

client.setChunkingThreshold(8192);
...
</pre></div><p>Users can also control the default values for the most common HTTPConduit parameters by setting specific system properties; the provided values will override Apache CXF defaut values.</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                  <p>
                    Property
                    
                  </p>
                </th><th>
                  <p>
                    Description
                    
                  </p>
                </th></tr></thead><tbody><tr><td>
                  <p>cxf.client.allowChunking</p>
                </td><td>
                  <p>
                    A boolean to tell Apache CXF whether to allow send messages using chunking.
                    
                  </p>
                </td></tr><tr><td>
                  <p>cxf.client.chunkingThreshold</p>
                </td><td>
                  <p>
                    An integer value to tell Apache CXF the threshold at which switching from non-chunking to chunking mode.
                    
                  </p>
                </td></tr><tr><td>
                  <p>cxf.client.connectionTimeout</p>
                </td><td>
                  <p>
                    A long value to tell Apache CXF how many milliseconds to set the connection timeout to
                    
                  </p>
                </td></tr><tr><td>
                  <p>cxf.client.receiveTimeout</p>
                </td><td>
                  <p>A long value to tell Apache CXF how many milliseconds to set the receive timeout to</p>
                </td></tr><tr><td>
                  <p>cxf.client.connection</p>
                </td><td>
                  <p>
                    A string to tell Apache CXF to use
                    <code class="code">Keep-Alive</code>
                    or
                    <code class="code">close</code>
                    connection type
                    
                  </p>
                </td></tr><tr><td>
                  <p>cxf.tls-client.disableCNCheck</p>
                </td><td>
                  <p>
                    A boolean to tell Apache CXF whether disabling CN host name check or not
                    
                  </p>
                </td></tr></tbody></table></div><p>The vanilla Apache CXF defaults apply when the system properties above are not set.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866793"/>5.11. Addressing</h2></div></div></div><p>
        JBoss Web Services inherits full WS-Addressing capabilities from the underlying Apache CXF implementation. Apache CXF provides support for 2004-08 and
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/ws-addr-core/">1.0</a>
        versions of WS-Addressing.
      </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866793_WS-Addressing-EnablingWSAddressing"/>5.11.1. Enabling WS-Addressing</h3></div></div></div><p>WS-Addressing can be turned on in multiple standard ways:</p><div class="itemizedlist"><ul><li><p>consuming a WSDL contract that specifies a WS-Addressing assertion / policy</p></li><li><p>
              using the
              <code class="code">@javax.xml.ws.soap.Addressing</code>
              annotation
            </p></li><li><p>
              using the
              <code class="code">javax.xml.ws.soap.AddressingFeature</code>
              feature
            </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>The supported addressing policy elements are:</p><div class="informalexample"><pre xmlns="" class="">[http://www.w3.org/2005/02/addressing/wsdl]UsingAddressing
[http://schemas.xmlsoap.org/ws/2004/08/addressing/policy]UsingAddressing
[http://www.w3.org/2006/05/addressing/wsdl]UsingAddressing
[http://www.w3.org/2007/05/addressing/metadata]Addressing</pre></div></div><p>Alternatively, Apache CXF proprietary ways are also available:</p><div class="itemizedlist"><ul><li><p>
              specifying the ﻿
              <span class="italics">[http://cxf.apache.org/ws/addressing]addressing</span>
              feature for a given client/endpoint
            </p></li><li><p>
              using the
              <code class="code">org.apache.cxf.ws.addressing.WSAddressingFeature</code>
              feature through the API
            </p></li><li><p>
              manually configuring the Apache CXF addressing interceptors (
              <code class="code">org.apache.cxf.ws.addressing.MAPAggregator</code>
              and
              <code class="code">org.apache.cxf.ws.addressing.soap.MAPCodec</code>
              )
            </p></li><li><p>
              setting the
              <span class="italics">org.apache.cxf.ws.addressing.using</span>
              property in the message context
            </p></li></ul></div><p>
          Please refer to the the Apache CXF documentation for further information on the proprietary
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/ws-addressing.html">WS-Addressing setup</a>
          and
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/wsaconfiguration.html">configuration details</a>
          .
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866793_WS-Addressing-WSAddressingPolicy"/>5.11.2. Addressing Policy</h3></div></div></div><p>The WS-Addressing support is also perfectly integrated with the Apache CXF WS-Policy engine.</p><p>
          This basically means that the WSDL contract generation for code-first endpoint deployment is policy-aware: users can annotate endpoints with the
          <code class="code">@</code>
          <code class="code">javax.xml.ws.soap.</code>
          <code class="code">Addressing</code>
          annotation and expect the published WSDL contract to contain proper WS-Addressing policy (assuming no
          <code class="code">wsdlLocation</code>
          is specified in the endpoint's
          <code class="code">@WebService</code>
          annotation).
        </p><p>
          Similarly, on client side users do not need to manually specify the
          <code class="code">javax.xml.ws.soap.AddressingFeature</code>
          feature, as the policy engine is able to properly process the WS-Addressing policy in the consumed WSDL and turn on addressing as requested.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866793_WS-Addressing-Example"/>5.11.3. Example</h3></div></div></div><p>Here is an example showing how to simply enable WS-Addressing through WS-Policy.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866793_WS-Addressing-Endpoint"/>5.11.3.1. Endpoint</h4></div></div></div><p>
            A simple JAX-WS endpoint is prepared using a java-first approach; WS-Addressing is enforced through
            <code class="code">@Addressing</code>
            annotation and no
            <code class="code">wsdlLocation</code>
            is provided in
            <code class="code">@WebService</code>
            :
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.jboss.test.ws.jaxws.samples.wsa;

import javax.jws.WebService;
import javax.xml.ws.soap.Addressing;
import org.jboss.logging.Logger;

@WebService
(
   portName = "AddressingServicePort",
   serviceName = "AddressingService",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wsaddressing",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsa.ServiceIface"
)
@Addressing(enabled=true, required=true)
public class ServiceImpl implements ServiceIface
{
   private Logger log = Logger.getLogger(this.getClass());

   public String sayHello(String name)
   {
      return "Hello " + name + "!";
   }
}</pre></div><p>The WSDL contract that's generated at deploy time and published looks like this:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;wsdl:definitions ....&gt;
...
  &lt;wsdl:binding name="AddressingServiceSoapBinding" type="tns:ServiceIface"&gt;
    &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsaw:UsingAddressing wsdl:required="true"/&gt;
    &lt;wsp:PolicyReference URI="#AddressingServiceSoapBinding_WSAM_Addressing_Policy"/&gt;

    &lt;wsdl:operation name="sayHello"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="sayHello"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="sayHelloResponse"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;

  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="AddressingService"&gt;
    &lt;wsdl:port binding="tns:AddressingServiceSoapBinding" name="AddressingServicePort"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-samples-wsa"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
    &lt;wsp:Policy wsu:Id="AddressingServiceSoapBinding_WSAM_Addressing_Policy"
       xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"&gt;
      &lt;wsam:Addressing xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"&gt;
        &lt;wsp:Policy/&gt;
      &lt;/wsam:Addressing&gt;
    &lt;/wsp:Policy&gt;
&lt;/wsdl:definitions&gt;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866793_WS-Addressing-Client"/>5.11.3.2. Client</h4></div></div></div><p>Since the WS-Policy engine is on by default, the client side code is basically a pure JAX-WS client app:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wsaddressing", "AddressingService");
URL wsdlURL = new URL("http://localhost:8080/jaxws-samples-wsa?wsdl");
Service service = Service.create(wsdlURL, serviceName);
ServiceIface proxy = (ServiceIface)service.getPort(ServiceIface.class);
proxy.sayHello("World");</pre></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866795"/>5.12. WS-Security</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866795_WS-Security-"/>5.12.1. WS-Security overview</h3></div></div></div><p>
          WS-Security provides the means to secure your services beyond transport level protocols such as
          <span class="italics">HTTPS</span>
          . Through a number of standards such as
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xmlenc-core/">XML-Encryption</a>
          , and headers defined in the
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=wss">WS-Security</a>
          standard, it allows you to:
        </p><div class="itemizedlist"><ul><li><p>Pass authentication tokens between services.</p></li><li><p>Encrypt messages or parts of messages.</p></li><li><p>Sign messages.</p></li><li><p>Timestamp messages.</p></li></ul></div><p>WS-Security makes heavy use of public and private key cryptography.  It is helpful to understand these basics to really understand how to  configure WS-Security. With public key cryptography, a user has a pair  of public and private keys. These are generated using a large prime  number and a key function.</p><p>
          </p><div class="figure"><a id="d0e4801"/><div class="figure-contents"><div class="mediaobject"><img src="author/download/attachments/3866795/Public_key_making.png" alt="TODO InformalFigure image title empty"/></div></div><p class="title"><b>Figure 5.1. TODO InformalFigure image title empty</b></p></div><p><br class="figure-break"/>
        </p><p>The keys are related mathematically, but cannot be derived from one  another. With these keys we can encrypt messages. For example, if Bob  wants to send a message to Alice, he can encrypt a message using her  public key. Alice can then decrypt this message using her private key.  Only Alice can decrypt this message as she is the only one with the  private key.</p><p>
          </p><div class="figure"><a id="d0e4812"/><div class="figure-contents"><div class="mediaobject"><img src="author/download/attachments/3866795/Public_key_encryption-mod.svg.png" alt="TODO InformalFigure image title empty"/></div></div><p class="title"><b>Figure 5.2. TODO InformalFigure image title empty</b></p></div><p><br class="figure-break"/>
        </p><p>Messages can also be signed. This allows you to ensure the  authenticity of the message. If Alice wants to send a message to Bob,  and Bob wants to be sure that it is from Alice, Alice can sign the  message using her private key. Bob can then verify that the message is  from Alice by using her public key.</p><p>
          </p><div class="figure"><a id="d0e4823"/><div class="figure-contents"><div class="mediaobject"><img src="author/download/attachments/3866795/250px-Public_key_making.svg.png" alt="TODO InformalFigure image title empty"/></div></div><p class="title"><b>Figure 5.3. TODO InformalFigure image title empty</b></p></div><p><br class="figure-break"/>
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866795_WS-Security-JBossWSSecuritysupport"/>5.12.2. JBoss WS-Security support</h3></div></div></div><p>
          JBoss Web Services supports many real world scenarios requiring WS-Security functionalities. This includes signature and encryption support through X509 certificates, authentication and authorization through username tokens as well as all ws-security configurations covered by WS-
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/v1.3/ws-securitypolicy.html">SecurityPolicy</a>
          specification.
        </p><p>
          <a href="sid-3866738.html#sid-3866786" title="5.10. Apache CXF integration">As well as for other WS-* features</a>
          , the core of WS-Security functionalities is provided through the Apache CXF engine. On top of that the JBossWS integration adds few configuration enhancements to simplify the setup of WS-Security enabled endpoints.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866795_WS-Security-ApacheCXFWSSecurityimplementation"/>5.12.2.1. Apache CXF WS-Security implementation</h4></div></div></div><p>Apache CXF features a top class WS-Security module supporting multiple configurations and easily extendible.</p><p>
            The system is based on
            <span class="italics">interceptors</span>
            that delegate to
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://ws.apache.org/wss4j">Apache WSS4J</a>
            for the low level security operations. Interceptors can be configured in different ways, either through Spring configuration files or directly using Apache CXF client API. Please refer to the
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/ws-security.html">Apache CXF documentation</a>
            if you're looking for more details.
          </p><p>Recent versions of Apache CXF, however, introduced support for WS-Security Policy, which aims at moving most of the security configuration into the service contract (through policies), so that clients can easily be configured almost completely automatically from that. This way users do not need to manually deal with configuring / installing the required interceptors; the Apache CXF WS-Policy engine internally takes care of that instead.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866795_WS-Security-WSSecurityPolicysupport"/>5.12.2.1.1. WS-Security Policy support</h5></div></div></div><p>
              WS-SecurityPolicy describes the actions that are required to securely communicate with a service advertised in a given WSDL contract. The WSDL bindings / operations reference WS-Policy fragments with the security requirements to interact with the service. The
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/v1.3/ws-securitypolicy.html">WS-SecurityPolicy specification</a>
              allows for specifying things like asymmetric/symmetric keys, using   transports (https) for encryption, which parts/headers to encrypt or   sign, whether to sign then encrypt or encrypt then sign, whether to   include timestamps, whether to use derived keys, etc.
            </p><p>However some mandatory configuration elements are not covered by WS-SecurityPolicy, basically because they're not meant to be public / part of the published endpoint contract; those include things such as keystore locations, usernames and passwords, etc. Apache CXF allows configuring these elements either through Spring xml descriptors or using the client API / annotations. Below is the list of supported configuration properties:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                      <p>ws-security.username</p>
                    </th><th>
                      <p>The username used for UsernameToken policy assertions</p>
                    </th></tr></thead><tbody><tr><td>
                      <p>ws-security.password</p>
                    </td><td>
                      <p>The password used for UsernameToken policy assertions.   If not specified, the callback handler will be called.</p>
                    </td></tr><tr><td>
                      <p>ws-security.callback-handler</p>
                    </td><td>
                      <p>The WSS4J security CallbackHandler that will be used to retrieve passwords for keystores and UsernameTokens.</p>
                    </td></tr><tr><td>
                      <p>ws-security.signature.properties</p>
                    </td><td>
                      <p>The properties file/object that contains the WSS4J properties for configuring the signature keystore and crypto objects</p>
                    </td></tr><tr><td>
                      <p>ws-security.encryption.properties</p>
                    </td><td>
                      <p>The properties file/object that contains the WSS4J properties for configuring the encryption keystore and crypto objects</p>
                    </td></tr><tr><td>
                      <p>ws-security.signature.username</p>
                    </td><td>
                      <p>The username or alias for the key in the signature keystore that will  be used.   If not specified, it uses the the default alias set in the  properties file.  If that's also not set, and the keystore only contains  a single key, that key will be used.</p>
                    </td></tr><tr><td>
                      <p>ws-security.encryption.username</p>
                    </td><td>
                      <p>The username or alias for the key in the encryption keystore that will  be used.   If not specified, it uses the the default alias set in the  properties file.  If that's also not set, and the keystore only contains  a single key, that key will be used.  For the web service provider, the  useReqSigCert keyword can be used to accept (encrypt to) any client  whose public key is in the service's truststore (defined in  ws-security.encryption.properties.)</p>
                    </td></tr><tr><td>
                      <p>ws-security.signature.crypto</p>
                    </td><td>
                      <p>
                        Instead of specifying the signature properties, this can point to the full
                        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://ws.apache.org/wss4j/apidocs/org/apache/ws/security/components/crypto/Crypto.html">WSS4J Crypto</a>
                        object.  This can allow easier "programmatic" configuration of the Crypto information."
                      </p>
                    </td></tr><tr><td>
                      <p>ws-security.encryption.crypto</p>
                    </td><td>
                      <p>
                        Instead of specifying the encryption properties, this can point to the full
                        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://ws.apache.org/wss4j/apidocs/org/apache/ws/security/components/crypto/Crypto.html">WSS4J Crypto</a>
                        object.  This can allow easier "programmatic" configuration of the Crypto information."
                      </p>
                    </td></tr><tr><td>
                      <p>ws-security.enable.streaming</p>
                    </td><td>
                      <p>
                        Enable
                        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://ws.apache.org/wss4j/streaming.html">streaming</a>
                        (StAX based) processing of WS-Security messages
                        
                      </p>
                    </td></tr></tbody></table></div><p>Here is an example of configuration using the client API:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Map&lt;String, Object&gt; ctx = ((BindingProvider)port).getRequestContext();
ctx.put("ws-security.encryption.properties", properties);
port.echoString("hello");
</pre></div><p>
              Please refer to the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/ws-securitypolicy.html">Apache CXF documentation</a>
              for additional configuration details.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866795_WS-Security-JBossWSconfigurationadditions"/>5.12.2.2. JBossWS configuration additions</h4></div></div></div><p>
            In order for removing the need of Spring on server side for setting up WS-Security configuration properties not covered by policies, the JBossWS integration allows for getting those pieces of information from a defined
            <span class="italics">endpoint configuration</span>
            .
            <a href="sid-3866738.html#sid-41713670" title="5.8. Predefined client and endpoint configurations">Endpoint configurations</a>
            can include property declarations and endpoint implementations can be associated with a given endpoint configuration using the
            <code class="code">@EndpointConfig</code>
            annotation.
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:javaee="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom WS-Security Endpoint&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.username&lt;/property-name&gt;
      &lt;property-value&gt;bob&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.username&lt;/property-name&gt;
      &lt;property-value&gt;alice&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.callback-handler&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.KeystorePasswordCallback&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre></div><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">import javax.jws.WebService;
import org.jboss.ws.api.annotation.EndpointConfig;

@WebService
(
   portName = "SecurityServicePort",
   serviceName = "SecurityService",
   wsdlLocation = "WEB-INF/wsdl/SecurityService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.basic.ServiceIface"
)
@EndpointConfig(configFile = "WEB-INF/jaxws-endpoint-config.xml", configName = "Custom WS-Security Endpoint")
public class ServiceImpl implements ServiceIface
{
   public String sayHello()
   {
      return "Secure Hello World!";
   }
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866795_WS-Security-ApacheCXFannotations"/>5.12.2.3. Apache CXF annotations</h4></div></div></div><p>
            The JBossWS configuration additions allow for a descriptor approach to the WS-Security Policy engine configuration. If you prefer to provide the same information through an annotation approach, you can leverage the Apache CXF
            <code class="code">@org.apache.cxf.annotations.EndpointProperties</code>
            annotation:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@WebService(
   ...
)
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.properties", value = "bob.properties"),
      @EndpointProperty(key = "ws-security.encryption.properties", value = "bob.properties"),
      @EndpointProperty(key = "ws-security.signature.username", value = "bob"),
      @EndpointProperty(key = "ws-security.encryption.username", value = "alice"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.basic.KeystorePasswordCallback")
      }
)
public class ServiceImpl implements ServiceIface {
   ...
}</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866795_WS-Security-Examples"/>5.12.3. Examples</h3></div></div></div><p>In this section some sample of WS-Security service endpoints and clients are provided. Please note they're only meant as tutorials; you should really careful isolate the ws-security policies / assertion that best suite your security needs before going to production environment.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>The following sections provide directions and examples on understanding some of the configuration options for WS-Security engine. Please note the implementor remains responsible for assessing the application requirements and choosing the most suitable security policy for them.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866795_WS-Security-Signatureandencryption"/>5.12.3.1. Signature and encryption</h4></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866795_WS-Security-Endpoint"/>5.12.3.1.1. Endpoint</h5></div></div></div><p>First of all you need to create the web service endpoint using  JAX-WS. While this can generally be achieved in different ways, it's required to use a contract-first approach when using WS-Security, as the policies declared in the wsdl are parsed by the Apache CXF engine on both server and client sides. So, here is an example of WSDL contract enforcing signature and encryption using X 509 certificates (the referenced schema is omitted):</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" name="SecurityService"
		xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy"
		xmlns:xsd="http://www.w3.org/2001/XMLSchema"
		xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
		xmlns="http://schemas.xmlsoap.org/wsdl/"
		xmlns:wsp="http://www.w3.org/ns/ws-policy"
        xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
        xmlns:wsaws="http://www.w3.org/2005/08/addressing"
        xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" schemaLocation="SecurityService_schema1.xsd"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="sayHello"&gt;
    &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;
  &lt;message name="sayHelloResponse"&gt;
    &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;
  &lt;portType name="ServiceIface"&gt;
    &lt;operation name="sayHello"&gt;
      &lt;input message="tns:sayHello"/&gt;
      &lt;output message="tns:sayHelloResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
  &lt;binding name="SecurityServicePortBinding" type="tns:ServiceIface"&gt;
    &lt;wsp:PolicyReference URI="#SecurityServiceSignThenEncryptPolicy"/&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="sayHello"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;
  &lt;service name="SecurityService"&gt;
    &lt;port name="SecurityServicePort" binding="tns:SecurityServicePortBinding"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-samples-wssePolicy-sign-encrypt"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;

  &lt;wsp:Policy wsu:Id="SecurityServiceSignThenEncryptPolicy" xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;sp:AsymmetricBinding xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:InitiatorToken&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:X509Token sp:IncludeToken="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy/IncludeToken/AlwaysToRecipient"&gt;
                  &lt;wsp:Policy&gt;
                    &lt;sp:WssX509V1Token11/&gt;
                  &lt;/wsp:Policy&gt;
                  &lt;/sp:X509Token&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:InitiatorToken&gt;
            &lt;sp:RecipientToken&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:X509Token sp:IncludeToken="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy/IncludeToken/Never"&gt;
                  &lt;wsp:Policy&gt;
                    &lt;sp:WssX509V1Token11/&gt;
                  &lt;/wsp:Policy&gt;
                &lt;/sp:X509Token&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:RecipientToken&gt;
            &lt;sp:AlgorithmSuite&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:TripleDesRsa15/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:AlgorithmSuite&gt;
            &lt;sp:Layout&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Lax/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:Layout&gt;
            &lt;sp:IncludeTimestamp/&gt;
            &lt;sp:EncryptSignature/&gt;
            &lt;sp:OnlySignEntireHeadersAndBody/&gt;
            &lt;sp:SignBeforeEncrypting/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:AsymmetricBinding&gt;
        &lt;sp:SignedParts xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
          &lt;sp:Body/&gt;
        &lt;/sp:SignedParts&gt;
        &lt;sp:EncryptedParts xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
          &lt;sp:Body/&gt;
        &lt;/sp:EncryptedParts&gt;
        &lt;sp:Wss10 xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportRefIssuerSerial/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Wss10&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;
&lt;/definitions&gt;</pre></div><p>
              The service endpoint can be generated using the
              <code class="code">wsconsume</code>
              tool and then enriched with a
              <code class="code">@EndpointConfig</code>
              annotation:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.jboss.test.ws.jaxws.samples.wsse.policy.basic;

import javax.jws.WebService;
import org.jboss.ws.api.annotation.EndpointConfig;

@WebService
(
   portName = "SecurityServicePort",
   serviceName = "SecurityService",
   wsdlLocation = "WEB-INF/wsdl/SecurityService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.basic.ServiceIface"
)
@EndpointConfig(configFile = "WEB-INF/jaxws-endpoint-config.xml", configName = "Custom WS-Security Endpoint")
public class ServiceImpl implements ServiceIface
{
   public String sayHello()
   {
      return "Secure Hello World!";
   }
}</pre></div><p>
              The referenced
              <span class="italics">jaxws-endpoint-config.xml</span>
              descriptor is used to provide a custom endpoint configuration with the required server side configuration properties; this tells the engine which certificate / key to use for signature / signature verification and for encryption / decryption:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:javaee="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom WS-Security Endpoint&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.username&lt;/property-name&gt;
      &lt;property-value&gt;bob&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.username&lt;/property-name&gt;
      &lt;property-value&gt;alice&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.callback-handler&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.KeystorePasswordCallback&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre></div><p>
              ... the
              <span class="italics">bob.properties</span>
              configuration file is also referenced above; it includes the WSS4J Crypto properties which in turn link to the keystore file, type and the alias/password to use for accessing it:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=password
org.apache.ws.security.crypto.merlin.keystore.alias=bob
org.apache.ws.security.crypto.merlin.keystore.file=bob.jks</pre></div><p>A callback handler for the letting Apache CXF access the keystore is also provided:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.jboss.test.ws.jaxws.samples.wsse.policy.basic;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.ws.security.WSPasswordCallback;

public class KeystorePasswordCallback implements CallbackHandler {
   private Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();

   public KeystorePasswordCallback() {
      passwords.put("alice", "password");
      passwords.put("bob", "password");
   }

   /**
    * It attempts to get the password from the private
    * alias/passwords map.
    */
   public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      for (int i = 0; i &lt; callbacks.length; i++) {
         WSPasswordCallback pc = (WSPasswordCallback)callbacks[i];

         String pass = passwords.get(pc.getIdentifier());
         if (pass != null) {
            pc.setPassword(pass);
            return;
         }
      }
   }

   /**
    * Add an alias/password pair to the callback mechanism.
    */
   public void setAliasPassword(String alias, String password) {
      passwords.put(alias, password);
   }
}</pre></div><p>
              Assuming the
              <span class="italics">bob.jks</span>
              keystore has been properly generated and contains Bob's (server) full key (private/certificate + public key) as well as Alice's (client) public key, we can proceed to packaging the endpoint. Here is the expected content (the endpoint is a
              <span class="italics">POJO</span>
              one in a
              <span class="italics">war</span>
              archive, but
              <span class="italics">EJB3</span>
              endpoints in
              <span class="italics">jar</span>
              archives are of course also supported):
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">alessio@inuyasha /dati/jbossws/stack/cxf/trunk $ jar -tvf ./modules/testsuite/cxf-tests/target/test-libs/jaxws-samples-wsse-policy-sign-encrypt.war
     0 Thu Jun 16 18:50:48 CEST 2011 META-INF/
   140 Thu Jun 16 18:50:46 CEST 2011 META-INF/MANIFEST.MF
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/
   586 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/web.xml
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/basic/
  1687 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/basic/KeystorePasswordCallback.class
   383 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/basic/ServiceIface.class
  1070 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/basic/ServiceImpl.class
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/
   705 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/SayHello.class
  1069 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/SayHelloResponse.class
  1225 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/jaxws-endpoint-config.xml
     0 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/
  4086 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/SecurityService.wsdl
   653 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/SecurityService_schema1.xsd
  1820 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/classes/bob.jks
   311 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/classes/bob.properties</pre></div><p>
              As you can see, the jaxws classes generated by the tools are of course also included, as well as a basic
              <span class="italics">web.xml</span>
              referencing the endpoint bean:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app
   version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.ServiceImpl&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
                If you're deploying the endpoint archive to WildFly, remember to add a dependency to
                <span class="italics">org.apache.ws.security</span>
                module in the MANIFEST.MF file.
              </p><div class="informalexample"><pre xmlns="" class="">Manifest-Version: 1.0
Ant-Version: Apache Ant 1.7.1
Created-By: 17.0-b16 (Sun Microsystems Inc.)
Dependencies: org.apache.ws.security</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866795_WS-Security-Client"/>5.12.3.1.2. Client</h5></div></div></div><p>
              You start by consuming the published WSDL contract using the
              <span class="italics">wsconsume</span>
              tool on client side too. Then you simply invoke the the endpoint as a standard JAX-WS one:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy", "SecurityService");
URL wsdlURL = new URL(serviceURL + "?wsdl");
Service service = Service.create(wsdlURL, serviceName);
ServiceIface proxy = (ServiceIface)service.getPort(ServiceIface.class);

((BindingProvider)proxy).getRequestContext().put(SecurityConstants.CALLBACK_HANDLER, new KeystorePasswordCallback());
((BindingProvider)proxy).getRequestContext().put(SecurityConstants.SIGNATURE_PROPERTIES,
     Thread.currentThread().getContextClassLoader().getResource("META-INF/alice.properties"));
((BindingProvider)proxy).getRequestContext().put(SecurityConstants.ENCRYPT_PROPERTIES,
     Thread.currentThread().getContextClassLoader().getResource("META-INF/alice.properties"));
((BindingProvider)proxy).getRequestContext().put(SecurityConstants.SIGNATURE_USERNAME, "alice");
((BindingProvider)proxy).getRequestContext().put(SecurityConstants.ENCRYPT_USERNAME, "bob");

proxy.sayHello();</pre></div><p>
              As you can see, the WS-Security properties are set in the request context. Here the
              <code class="code">KeystorePasswordCallback</code>
              is the same as on server side above, you might want/need different implementation in real world scenarios, of course.
              
              The
              <span class="italics">alice.properties</span>
              file is the client side equivalent of the server side
              <span class="italics">bob.properties</span>
              and references the
              <span class="italics">alice.jks</span>
              keystore file, which has been populated with Alice's (client) full key (private/certificate + public key) as well as Bob's (server) public key.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=password
org.apache.ws.security.crypto.merlin.keystore.alias=alice
org.apache.ws.security.crypto.merlin.keystore.file=META-INF/alice.jks</pre></div><p>The Apache CXF WS-Policy engine will digest the security requirements in the contract and ensure a valid secure communication is in place for interacting with the server endpoint.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866795_WS-Security-Endpointservingmultipleclients"/>5.12.3.1.3. Endpoint serving multiple clients</h5></div></div></div><p>
              The server side configuration described above implies the endpoint is configured for serving a given client which a service agreement has been established for. In some real world scenarios though, the same server might be expected to be able to deal with (including decrypting and encrypting) messages coming from and being sent to multiple clients. Apache CXF supports that through the
              <code class="code">useReqSigCert</code>
              value for the
              <code class="code">ws-security.encryption.username</code>
              configuration parameter.
            </p><p>Of course the referenced server side keystore then needs to contain the public key of all the clients that are expected to be served.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866795_WS-Security-Authenticationandauthorization"/>5.12.3.2. Authentication and authorization</h4></div></div></div><p>The Username Token Profile can be used to provide client's credentials to a WS-Security enabled target endpoint.</p><p>
            Apache CXF provides means for setting basic
            <span class="italics">password callback handlers</span>
            on both client and server sides to set/check passwords; the
            <span class="italics">ws-security.username</span>
            and
            <span class="italics">ws-security.callback-handler</span>
            properties can be used similarly as shown in the signature and encryption example. Things become more interesting when requiring a given user to be authenticated (and authorized) against a security domain on the target WildFly server.
          </p><p>On server side, you need to install two additional interceptors that act as bridges towards the application server authentication layer:</p><div class="itemizedlist"><ul><li><p>
                an  interceptor for performing authentication and populating a valid  SecurityContext; the provided interceptor should extend  org.apache.cxf.ws.interceptor.security.AbstractUsernameTokenInInterceptor,  in particular JBossWS integration comes with
                <span class="italics">org.jboss.wsf.stack.cxf.security.authentication.SubjectCreatingInterceptor</span>
                for this;
              </p></li><li><p>
                an  interceptor for performing authorization; CXF requires that to extend  org.apache.cxf.interceptor.security.AbstractAuthorizingInInterceptor,  for instance the
                <span class="italics">SimpleAuthorizingInterceptor</span>
                can be used for simply mapping endpoint operations to allowed roles.
              </p></li></ul></div><p>So, here follows an example of WS-SecurityPolicy endpoint using Username Token Profile for authenticating through the WildFly security domain system.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866795_WS-Security-Endpointx"/>5.12.3.2.1. Endpoint</h5></div></div></div><p>As in the other example, we start with a wsdl contract containing the proper WS-Security Policy:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" name="SecurityService"
		xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy"
		xmlns:xsd="http://www.w3.org/2001/XMLSchema"
		xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
		xmlns="http://schemas.xmlsoap.org/wsdl/"
		xmlns:wsp="http://schemas.xmlsoap.org/ws/2004/09/policy"
        xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
        xmlns:wsaws="http://www.w3.org/2005/08/addressing"&gt;
  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" schemaLocation="SecurityService_schema1.xsd"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="sayHello"&gt;
    &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;
  &lt;message name="sayHelloResponse"&gt;
    &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;
  &lt;message name="greetMe"&gt;
    &lt;part name="parameters" element="tns:greetMe"/&gt;
  &lt;/message&gt;
  &lt;message name="greetMeResponse"&gt;
    &lt;part name="parameters" element="tns:greetMeResponse"/&gt;
  &lt;/message&gt;
  &lt;portType name="ServiceIface"&gt;
    &lt;operation name="sayHello"&gt;
      &lt;input message="tns:sayHello"/&gt;
      &lt;output message="tns:sayHelloResponse"/&gt;
    &lt;/operation&gt;
    &lt;operation name="greetMe"&gt;
      &lt;input message="tns:greetMe"/&gt;
      &lt;output message="tns:greetMeResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
  &lt;binding name="SecurityServicePortBinding" type="tns:ServiceIface"&gt;
    &lt;wsp:PolicyReference URI="#SecurityServiceUsernameUnsecureTransportPolicy"/&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="sayHello"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
    &lt;operation name="greetMe"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;
  &lt;service name="SecurityService"&gt;
    &lt;port name="SecurityServicePort" binding="tns:SecurityServicePortBinding"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-samples-wsse-username-jaas"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;

  &lt;wsp:Policy wsu:Id="SecurityServiceUsernameUnsecureTransportPolicy"&gt;
        &lt;wsp:ExactlyOne&gt;
            &lt;wsp:All&gt;
                &lt;sp:SupportingTokens xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
                    &lt;wsp:Policy&gt;
                        &lt;sp:UsernameToken sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
                            &lt;wsp:Policy&gt;
                                &lt;sp:WssUsernameToken10/&gt;
                            &lt;/wsp:Policy&gt;
                        &lt;/sp:UsernameToken&gt;
                    &lt;/wsp:Policy&gt;
                &lt;/sp:SupportingTokens&gt;
            &lt;/wsp:All&gt;
        &lt;/wsp:ExactlyOne&gt;
    &lt;/wsp:Policy&gt;

&lt;/definitions&gt;</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>If you want to send hash / digest passwords, you can use a policy such as what follows:</p><div class="informalexample"><pre xmlns="" class="">&lt;wsp:Policy wsu:Id="SecurityServiceUsernameHashPasswordPolicy"&gt;
    &lt;wsp:ExactlyOne&gt;
        &lt;wsp:All&gt;
            &lt;sp:SupportingTokens xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
                &lt;wsp:Policy&gt;
                    &lt;sp:UsernameToken sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
                        &lt;wsp:Policy&gt;
                            &lt;sp:HashPassword/&gt;
                        &lt;/wsp:Policy&gt;
                    &lt;/sp:UsernameToken&gt;
                &lt;/wsp:Policy&gt;
            &lt;/sp:SupportingTokens&gt;
        &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
&lt;/wsp:Policy&gt;</pre></div><p>Please note the specified JBoss security domain needs to be properly configured for computing digests.</p></div><p>
              The service endpoint can be generated using the
              <code class="code">wsconsume</code>
              tool and then enriched with a
              <code class="code">@EndpointConfig</code>
              annotation and
              <code class="code">@InInterceptors</code>
              annotation to add the two interceptors mentioned above for JAAS integration:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.jboss.test.ws.jaxws.samples.wsse.policy.jaas;

import javax.jws.WebService;
import org.apache.cxf.interceptor.InInterceptors;
import org.jboss.ws.api.annotation.EndpointConfig;

@WebService
(
   portName = "SecurityServicePort",
   serviceName = "SecurityService",
   wsdlLocation = "WEB-INF/wsdl/SecurityService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.jaas.ServiceIface"
)
@EndpointConfig(configFile = "WEB-INF/jaxws-endpoint-config.xml", configName = "Custom WS-Security Endpoint")
@InInterceptors(interceptors = {
      "org.jboss.wsf.stack.cxf.security.authentication.SubjectCreatingPolicyInterceptor",
      "org.jboss.test.ws.jaxws.samples.wsse.policy.jaas.POJOEndpointAuthorizationInterceptor"}
)
public class ServiceImpl implements ServiceIface
{
   public String sayHello()
   {
      return "Secure Hello World!";
   }

   public String greetMe()
   {
      return "Greetings!";
   }
}</pre></div><p>
              The
              <code class="code">POJOEndpointAuthorizationInterceptor</code>
              is included into the deployment and deals with the roles cheks:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.jboss.test.ws.jaxws.samples.wsse.policy.jaas;

import java.util.HashMap;
import java.util.Map;
import org.apache.cxf.interceptor.security.SimpleAuthorizingInterceptor;

public class POJOEndpointAuthorizationInterceptor extends SimpleAuthorizingInterceptor
{

   public POJOEndpointAuthorizationInterceptor()
   {
      super();
      readRoles();
   }

   private void readRoles()
   {
      //just an example, this might read from a configuration file or such
      Map&lt;String, String&gt; roles = new HashMap&lt;String, String&gt;();
      roles.put("sayHello", "friend");
      roles.put("greetMe", "snoopies");
      setMethodRolesMap(roles);
   }
}</pre></div><p>
              The
              <span class="italics">jaxws-endpoint-config.xml</span>
              descriptor is used to provide a custom endpoint configuration with the required server side configuration properties; in particular for this Username Token case that's just a CXF configuration option for leaving the username token validation to the configured interceptors:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:javaee="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom WS-Security Endpoint&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.validate.token&lt;/property-name&gt;
      &lt;property-value&gt;false&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre></div><p>
              In order for requiring a given JBoss security domain to be used to protect access to the endpoint (a POJO one in this case), we declare that in a
              <span class="italics">jboss-web.xml</span>
              descriptor (the
              <span class="italics">JBossWS</span>
              security domain is used):
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE jboss-web PUBLIC "-//JBoss//DTD Web Application 2.4//EN" "http://www.jboss.org/j2ee/dtd/jboss-web_4_0.dtd"&gt;
&lt;jboss-web&gt;
   &lt;security-domain&gt;java:/jaas/JBossWS&lt;/security-domain&gt;
&lt;/jboss-web</pre></div><p>
              Finally, the
              <span class="italics">web.xml</span>
              is as simple as usual:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app
   version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.jaas.ServiceImpl&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div><p>The endpoint is packaged into a war archive, including the JAXWS classes generated by wsconsume:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">alessio@inuyasha /dati/jbossws/stack/cxf/trunk $ jar -tvf ./modules/testsuite/cxf-tests/target/test-libs/jaxws-samples-wsse-policy-username-jaas.war
     0 Thu Jun 16 18:50:48 CEST 2011 META-INF/
   155 Thu Jun 16 18:50:46 CEST 2011 META-INF/MANIFEST.MF
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/
   585 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/web.xml
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaas/
   982 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaas/POJOEndpointAuthorizationInterceptor.class
   412 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaas/ServiceIface.class
  1398 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaas/ServiceImpl.class
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/
   701 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/GreetMe.class
  1065 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/GreetMeResponse.class
   705 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/SayHello.class
  1069 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/SayHelloResponse.class
   556 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/jaxws-endpoint-config.xml
   241 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/jboss-web.xml
     0 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/
  3183 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/SecurityService.wsdl
  1012 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/SecurityService_schema1.xsd</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
                If you're deploying the endpoint archive to WildFly, remember to add a dependency to
                <span class="italics">org.apache.ws.security</span>
                and
                <span class="italics">org.apache.cxf</span>
                module (due to the
                <code class="code">@InInterceptor</code>
                annotation) in the MANIFEST.MF file.
              </p><div class="informalexample"><pre xmlns="" class="">Manifest-Version: 1.0
Ant-Version: Apache Ant 1.7.1
Created-By: 17.0-b16 (Sun Microsystems Inc.)
Dependencies: org.apache.ws.security,org.apache.cxf</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-3866795_WS-Security-Clientx"/>5.12.3.2.2. Client</h5></div></div></div><p>
              Here too you start by consuming the published WSDL contract using the
              <span class="italics">wsconsume</span>
              tool. Then you simply invoke the the endpoint as a standard JAX-WS one:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy", "SecurityService");
URL wsdlURL = new URL(serviceURL + "?wsdl");
Service service = Service.create(wsdlURL, serviceName);
ServiceIface proxy = (ServiceIface)service.getPort(ServiceIface.class);

((BindingProvider)proxy).getRequestContext().put(SecurityConstants.USERNAME, "kermit");
((BindingProvider)proxy).getRequestContext().put(SecurityConstants.CALLBACK_HANDLER,
      "org.jboss.test.ws.jaxws.samples.wsse.policy.jaas.UsernamePasswordCallback");

proxy.sayHello();</pre></div><p>
              The
              <code class="code">UsernamePasswordCallback</code>
              class is shown below and is responsible for setting the passwords on client side just before performing the invocations:
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.jboss.test.ws.jaxws.samples.wsse.policy.jaas;

import java.io.IOException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.ws.security.WSPasswordCallback;

public class UsernamePasswordCallback implements CallbackHandler
{
   public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException
   {
      WSPasswordCallback pc = (WSPasswordCallback)callbacks[0];
      if ("kermit".equals(pc.getIdentifier()))
         pc.setPassword("thefrog");
   }
}</pre></div><p>
              If everything has been done properly, you should expect to calls to
              <code class="code">sayHello()</code>
              fail when done with user "snoopy" and pass with user "kermit" (and credential "thefrog"); moreover, you should get an authorization error when trying to call
              <code class="code">greetMe()</code>
              with user "kermit", as that does not have the "snoopies" role.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866795_WS-Security-Securetransport"/>5.12.3.3. Secure transport</h4></div></div></div><p>Another quite common use case is using WS-Security Username Token Profile over a secure transport (HTTPS). A scenario like this is implemented similarly to what's described in the previous example, except for few differences explained below.</p><p>First of all, here is an excerpt of a wsdl wth a sample security policy for Username Token over HTTPS:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">...

&lt;binding name="SecurityServicePortBinding" type="tns:ServiceIface"&gt;
  &lt;wsp:PolicyReference URI="#SecurityServiceBindingPolicy"/&gt;
  &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
  &lt;operation name="sayHello"&gt;
    &lt;soap:operation soapAction=""/&gt;
    &lt;input&gt;
      &lt;soap:body use="literal"/&gt;
    &lt;/input&gt;
    &lt;output&gt;
      &lt;soap:body use="literal"/&gt;
    &lt;/output&gt;
  &lt;/operation&gt;
&lt;/binding&gt;
&lt;service name="SecurityService"&gt;
   &lt;port name="SecurityServicePort" binding="tns:SecurityServicePortBinding"&gt;
      &lt;soap:address location="https://localhost:8443/jaxws-samples-wsse-policy-username"/&gt;
   &lt;/port&gt;
&lt;/service&gt;

&lt;wsp:Policy wsu:Id="SecurityServiceBindingPolicy"&gt;
   &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
         &lt;foo:unknownPolicy xmlns:foo="http://cxf.apache.org/not/a/policy"/&gt;
      &lt;/wsp:All&gt;
      &lt;wsp:All&gt;
         &lt;wsaws:UsingAddressing xmlns:wsaws="http://www.w3.org/2006/05/addressing/wsdl"/&gt;
         &lt;sp:TransportBinding&gt;
            &lt;wsp:Policy&gt;
               &lt;sp:TransportToken&gt;
                  &lt;wsp:Policy&gt;
                     &lt;sp:HttpsToken RequireClientCertificate="false"/&gt;
                  &lt;/wsp:Policy&gt;
               &lt;/sp:TransportToken&gt;
               &lt;sp:Layout&gt;
                  &lt;wsp:Policy&gt;
                     &lt;sp:Lax/&gt;
                  &lt;/wsp:Policy&gt;
               &lt;/sp:Layout&gt;
               &lt;sp:IncludeTimestamp/&gt;
               &lt;sp:AlgorithmSuite&gt;
                  &lt;wsp:Policy&gt;
                     &lt;sp:Basic128/&gt;
                  &lt;/wsp:Policy&gt;
               &lt;/sp:AlgorithmSuite&gt;
            &lt;/wsp:Policy&gt;
         &lt;/sp:TransportBinding&gt;
         &lt;sp:Wss10&gt;
            &lt;wsp:Policy&gt;
               &lt;sp:MustSupportRefKeyIdentifier/&gt;
            &lt;/wsp:Policy&gt;
         &lt;/sp:Wss10&gt;
         &lt;sp:SignedSupportingTokens&gt;
            &lt;wsp:Policy&gt;
               &lt;sp:UsernameToken sp:IncludeToken="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy/IncludeToken/AlwaysToRecipient"&gt;
                  &lt;wsp:Policy&gt;
                     &lt;sp:WssUsernameToken10/&gt;
                  &lt;/wsp:Policy&gt;
               &lt;/sp:UsernameToken&gt;
            &lt;/wsp:Policy&gt;
         &lt;/sp:SignedSupportingTokens&gt;
      &lt;/wsp:All&gt;
   &lt;/wsp:ExactlyOne&gt;
&lt;/wsp:Policy&gt;</pre></div><p>
            The endpoint then needs of course to be actually available on HTTPS only, so we have a
            <span class="italics">web.xml</span>
            setting the
            <span class="italics">transport-guarantee</span>
            such as below:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app
   version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.ServiceImpl&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;

   &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;TestService&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;user-data-constraint&gt;
      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
  &lt;/security-constraint&gt;
&lt;/web-app&gt;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866795_WS-Security-Secureconversation"/>5.12.3.4. Secure conversation</h4></div></div></div><p>
            Apache CXF supports
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/ws-secureconversation-1.3-os.html">WS-SecureConversation</a>
            specification, which is about improving performance by allowing client and server to negotiate initial security keys to be used for later communication encryption/signature. This is done by having two policies in the wsdl contract, an outer one setting the security requirements to actually communicate with the endpoint and a bootstrap one, related to the communication for establishing the secure conversation keys. The client will be automatically sending an initial message to the server for negotiating the keys, then the actual communication to the endpoint takes place. As a consequence, Apache CXF needs a way to specify which WS-Security configuration properties are intended for the bootstrap policy and which are intended for the actual service policy. To accomplish this, properties intended for the bootstrap policy are appended with
            <code class="code">.sct</code>
            .
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">...
((BindingProvider)proxy).getRequestContext().put("ws-security.signature.username.sct", "alice");
((BindingProvider)proxy).getRequestContext().put("ws-security.encryption.username.sct", "bob");
...</pre></div><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@WebService(
   ...
)
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.encryption.properties.sct", value = "bob.properties"),
      @EndpointProperty(key = "ws-security.signature.properties.sct", value = "bob.properties"),
      ...
      }
)
public class ServiceImpl implements ServiceIface {
   ...
}</pre></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-47972359"/>5.13. WS-Trust and STS</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-47972359_WS-TrustandSTS-WSTrustoverview"/>5.13.1. WS-Trust overview</h3></div></div></div><p>
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.oasis-open.org/standards#wstrustv1.4">WS-Trust</a>
          is a Web service specification that defines extensions to  WS-Security.  It is a general framework for implementing security in a  distributed system.  The standard is based on a centralized Security  Token Service, STS, which is capable of authenticating clients and  issuing tokens containing various kinds of authentication and  authorization data.  The specification describes a protocol used for  issuance, exchange, and validation of security tokens, however the  following specifications play an important role in the WS-Trust  architecture:
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/ws-securitypolicy-1.2-spec-os.html">WS-SecurityPolicy 1.2</a>
          ,
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">SAML 2.0</a>
          ,
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.oasis-open.org/wss/v1.1/wss-v1.1-spec-os-UsernameTokenProfile.pdf">Username Token Profile</a>
          ,
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.oasis-open.org/wss-m/wss/v1.1.1/wss-x509TokenProfile-v1.1.1.html">X.509 Token Profile</a>
          ,
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.oasis-open.org/committees/download.php/16768/wss-v1.1-spec-os-SAMLTokenProfile.pdf">SAML Token Profile</a>
          , and
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.oasis-open.org/wss/v1.1/wss-v1.1-spec-os-KerberosTokenProfile.pdf">Kerberos Token Profile</a>
          .
          
        </p><p>
          The  WS-Trust extensions address the needs of applications that span  multiple domains and requires the sharing of security keys by providing a  standards based trusted third party web service (STS) to broker trust  relationships between a Web service requester and a Web service  provider.  This architecture also alleviates the pain of service updates  that require credential changes by providing a common location for this  information. The STS is the common access point from which both the  requester and provider retrieves and verifies security tokens.
          
        </p><p>There are three main components of the WS-Trust specification.</p><div class="itemizedlist"><ul><li><p>The Security Token Service (STS), a web service that issues, renews, and validates security tokens.</p></li><li><p>The message formats for security token requests and responses.</p></li><li><p>The mechanisms for key exchange</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-47972359_WS-TrustandSTS-SecurityTokenService"/>5.13.2. Security Token Service</h3></div></div></div><p>
          The Security Token Service, STS, is the core of the WS-Trust  specification.  It is a standards based mechanism for authentication and  authorization.  The STS is an implementation of the WS-Trust  specification's protocol for issuing, exchanging, and validating  security tokens, based on token format, namespace, or trust boundaries.   The STS is a web service that acts as a trusted third party to broker  trust relationships between a Web service requester and a Web service  provider.  It is a common access point trusted by both requester and  provider to provide interoperable security tokens.  It removes the need  for a direct relationship between the two.  Because the STS is a  standards based mechanism for authentication, it helps ensure  interoperability across realms and between different platforms.
          
        </p><p>The  STS's WSDL contract defines how other applications and processes  interact with it.  In particular the WSDL defines the WS-Trust and  WS-Security policies that a requester must fulfill in order to  successfully communicate with the STS's endpoints.  A web service  requester consumes the STS's WSDL and with the aid of an STSClient  utility, generates a message request compliant with the stated security  policies and submits it to the STS endpoint.  The STS validates the  request and returns an appropriate response.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-47972359_WS-TrustandSTS-ApacheCXFsupport"/>5.13.3. Apache CXF support</h3></div></div></div><p>Apache CXF is an open-source, fully featured Web services framework.   The JBossWS open source project integrates the JBoss Web Services  (JBossWS) stack with the Apache CXF project modules thus providing  WS-Trust and other JAX-WS functionality in WildFly.  This integration makes it easy to deploy CXF STS  implementations, however WildFly can run any WS-Trust  compliant STS.  In addition the Apache CXF API provides a STSClient  utility to facilitate web service requester communication with its STS.</p><p>
          Detailed information about the Apache CXF's WS-Trust implementation can be found
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://coheigea.blogspot.it/2011/10/apache-cxf-sts-documentation-part-i.html">here</a>
          .
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-47972359_WS-TrustandSTS-ABasicWSTrustScenario"/>5.13.4. A Basic WS-Trust Scenario</h3></div></div></div><p>
          Here is an example of a basic WS-Trust scenario.  It is comprised of a  Web service requester (ws-requester),  a Web service provider  (ws-provider), and a Security Token Service (STS).  The ws-provider  requires a SAML 2.0 token issued from a designed STS to be presented by  the ws-requester using asymmetric binding.  These communication  requirements are declared in the ws-provider's WSDL.  The STS requires  ws-requester credentials be provided in a WSS UsernameToken format  request using symmetric binding.  The STS's response is provided  containing a SAML 2.0 token.  These communication requirements are  declared in the STS's WSDL.
          
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>A  ws-requester contacts the ws-provider and consumes its WSDL.  Upon  finding the security token issuer requirement, it creates and configures  a STSClient with the information it requires to generate a proper  request.</p></li><li><p>The STSClient contacts the STS and consumes its WSDL.   The security policies are discovered.  The STSClient creates and sends  an authentication request, with appropriate credentials.</p></li><li><p>The STS verifies the credentials.</p></li><li><p>In response, the STS issues a security token that provides proof that the ws-requester has authenticated with the STS.</p></li><li><p>The STClient presents a message with the security token to the ws-provider.</p></li><li><p>The  ws-provider verifies the token was issued by the STS, thus proving the  ws-requester has successfully authenticated with the STS.</p></li><li><p>The ws-provider executes the requested service and returns the results to the the ws-requester.</p></li></ol></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-47972359_WS-TrustandSTS-Webserviceprovider"/>5.13.4.1. Web service provider</h4></div></div></div><p>This section examines the crucial elements in providing endpoint  security in the web service provider described in the basic WS-Trust  scenario.  The components that will be discussed are.</p><div class="itemizedlist"><ul><li><p>web service provider's WSDL</p></li><li><p>web service provider's Interface and Implementation classes.</p></li><li><p>ServerCallbackHandler class</p></li><li><p>Crypto properties and keystore files</p></li><li><p>MANIFEST.MF</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-WebserviceproviderWSDL"/>5.13.4.1.1. Web service provider WSDL</h5></div></div></div><p>The web service provider is a contract-first endpoint.  All the WS-trust  and security policies for it are declared in the WSDL,  SecurityService.wsdl.  For this scenario a ws-requester is required to  present a SAML 2.0 token issued from a designed STS. The address of the  STS is provided in the WSDL.  An asymmetric binding policy is used to  encrypt and sign the SOAP body of messages that pass back and forth  between ws-requester and ws-provider.  X.509 certificates are use for  the asymmetric binding.  The rules for sharing the public and private  keys in the SOAP request and response messages are declared.  A detailed explanation of the security  settings are provided in the comments in the listing below.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
 &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" name="SecurityService"
        xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
        xmlns="http://schemas.xmlsoap.org/wsdl/"
        xmlns:wsp="http://www.w3.org/ns/ws-policy"
        xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"
        xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
        xmlns:wsaws="http://www.w3.org/2005/08/addressing"
        xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"
        xmlns:t="http://docs.oasis-open.org/ws-sx/ws-trust/200512"&gt;
  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" schemaLocation="SecurityService_schema1.xsd"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="sayHello"&gt;
    &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;
  &lt;message name="sayHelloResponse"&gt;
    &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;
  &lt;portType name="ServiceIface"&gt;
    &lt;operation name="sayHello"&gt;
      &lt;input message="tns:sayHello"/&gt;
      &lt;output message="tns:sayHelloResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
  &lt;!--
        The wsp:PolicyReference binds the security requirments on all the STS endpoints.
        The wsp:Policy wsu:Id="#AsymmetricSAML2Policy" element is defined later in this file.
  --&gt;
  &lt;binding name="SecurityServicePortBinding" type="tns:ServiceIface"&gt;
    &lt;wsp:PolicyReference URI="#AsymmetricSAML2Policy" /&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="sayHello"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
        &lt;wsp:PolicyReference URI="#Input_Policy" /&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
        &lt;wsp:PolicyReference URI="#Output_Policy" /&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;
  &lt;service name="SecurityService"&gt;
    &lt;port name="SecurityServicePort" binding="tns:SecurityServicePortBinding"&gt;
      &lt;soap:address location="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust/SecurityService"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;
 
  &lt;wsp:Policy wsu:Id="AsymmetricSAML2Policy"&gt;
        &lt;wsp:ExactlyOne&gt;
            &lt;wsp:All&gt;
  &lt;!--
        The wsam:Addressing element, indicates that the endpoints of this
        web service MUST conform to the WS-Addressing specification.  The
        attribute wsp:Optional="false" enforces this assertion.
  --&gt;               
                &lt;wsam:Addressing wsp:Optional="false"&gt;
                    &lt;wsp:Policy /&gt;
                &lt;/wsam:Addressing&gt;
  &lt;!--
        The sp:AsymmetricBinding element indicates that security is provided
        at the SOAP layer. A public/private key combinations is required to
        protect the message.  The initiator will use it’s private key to sign
        the message and the recipient’s public key is used to encrypt the message.
        The recipient of the message will use it’s private key to decrypt it and
        initiator’s public key to verify the signature.
  --&gt;              
                &lt;sp:AsymmetricBinding&gt;
                    &lt;wsp:Policy&gt;
  &lt;!--
        The sp:InitiatorToken element specifies the elements required in
        generating the initiator request to the ws-provider's service.
  --&gt;                              
                        &lt;sp:InitiatorToken&gt;
                            &lt;wsp:Policy&gt;
  &lt;!--
        The sp:IssuedToken element asserts that a SAML 2.0 security token is
        expected from the STS using a public key type.  The
        sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
        attribute instructs the runtime to include the initiator's public key
        with every message sent to the recipient.
        
        The sp:RequestSecurityTokenTemplate element directs that all of the
        children of this element will be copied directly into the body of the
        RequestSecurityToken (RST) message that is sent to the STS when the
        initiator asks the STS to issue a token.
  --&gt;
                                &lt;sp:IssuedToken
                                    sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
                                    &lt;sp:RequestSecurityTokenTemplate&gt;
                                        &lt;t:TokenType&gt;http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0&lt;/t:TokenType&gt;
                                        &lt;t:KeyType&gt;http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey&lt;/t:KeyType&gt;
                                    &lt;/sp:RequestSecurityTokenTemplate&gt;
                                    &lt;wsp:Policy&gt;
                                        &lt;sp:RequireInternalReference /&gt;
                                    &lt;/wsp:Policy&gt;
  &lt;!--
        The sp:Issuer element defines the STS's address and endpoint information
        This information is used by the STSClient.
  --&gt;                                   
                                    &lt;sp:Issuer&gt;
                                        &lt;wsaws:Address&gt;http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts/SecurityTokenService&lt;/wsaws:Address&gt;
                                        &lt;wsaws:Metadata xmlns:wsdli="http://www.w3.org/2006/01/wsdl-instance"
                                                        wsdli:wsdlLocation="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts/SecurityTokenService?wsdl"&gt;
                                            &lt;wsaw:ServiceName xmlns:wsaw="http://www.w3.org/2006/05/addressing/wsdl"
                                                            xmlns:stsns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
                                                            EndpointName="UT_Port"&gt;stsns:SecurityTokenService&lt;/wsaw:ServiceName&gt;
                                        &lt;/wsaws:Metadata&gt;
                                    &lt;/sp:Issuer&gt;
                                &lt;/sp:IssuedToken&gt;
                            &lt;/wsp:Policy&gt;
                        &lt;/sp:InitiatorToken&gt;
  &lt;!--
        The sp:RecipientToken element asserts the type of public/private key-pair
        expected from the recipient.  The
        sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
        attribute indicates that the initiator's public key will never be included
        in the reply messages.  

        The sp:WssX509V3Token10 element indicates that an X509 Version 3 token
        should be used in the message.
  --&gt;                       
                        &lt;sp:RecipientToken&gt;
                            &lt;wsp:Policy&gt;
                                &lt;sp:X509Token
                                    sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
                                    &lt;wsp:Policy&gt;
                                        &lt;sp:WssX509V3Token10 /&gt;
                                        &lt;sp:RequireIssuerSerialReference /&gt;
                                    &lt;/wsp:Policy&gt;
                                &lt;/sp:X509Token&gt;
                            &lt;/wsp:Policy&gt;
                        &lt;/sp:RecipientToken&gt;
&lt;!--
     The sp:Layout element,  indicates the layout rules to apply when adding
     items to the security header.  The sp:Lax sub-element indicates items
     are added to the security header in any order that conforms to
     WSS: SOAP Message Security.
--&gt;                       
                        &lt;sp:Layout&gt;
                            &lt;wsp:Policy&gt;
                                &lt;sp:Lax /&gt;
                            &lt;/wsp:Policy&gt;
                        &lt;/sp:Layout&gt;
                        &lt;sp:IncludeTimestamp /&gt;
                        &lt;sp:OnlySignEntireHeadersAndBody /&gt;
 &lt;!--
     The sp:AlgorithmSuite element, requires the Basic256 algorithm suite
     be used in performing cryptographic operations.
--&gt;                      
                        &lt;sp:AlgorithmSuite&gt;
                            &lt;wsp:Policy&gt;
                                &lt;sp:Basic256 /&gt;
                            &lt;/wsp:Policy&gt;
                        &lt;/sp:AlgorithmSuite&gt;
                    &lt;/wsp:Policy&gt;
                &lt;/sp:AsymmetricBinding&gt;
&lt;!--
    The sp:Wss11 element declares WSS: SOAP Message Security 1.1 options
    to be supported by the STS.  These particular elements generally refer
    to how keys are referenced within the SOAP envelope.  These are normally
    handled by CXF.
--&gt;               
                &lt;sp:Wss11&gt;
                    &lt;wsp:Policy&gt;
                        &lt;sp:MustSupportRefIssuerSerial /&gt;
                        &lt;sp:MustSupportRefThumbprint /&gt;
                        &lt;sp:MustSupportRefEncryptedKey /&gt;
                    &lt;/wsp:Policy&gt;
                &lt;/sp:Wss11&gt;
&lt;!--
    The sp:Trust13 element declares controls for WS-Trust 1.3 options.  
    They are policy assertions related to exchanges specifically with
    client and server challenges and entropy behaviors.  Again these are
    normally handled by CXF.
--&gt;               
                &lt;sp:Trust13&gt;
                    &lt;wsp:Policy&gt;
                        &lt;sp:MustSupportIssuedTokens /&gt;
                        &lt;sp:RequireClientEntropy /&gt;
                        &lt;sp:RequireServerEntropy /&gt;
                    &lt;/wsp:Policy&gt;
                &lt;/sp:Trust13&gt;
            &lt;/wsp:All&gt;
        &lt;/wsp:ExactlyOne&gt;
    &lt;/wsp:Policy&gt;
    
    &lt;wsp:Policy wsu:Id="Input_Policy"&gt;
        &lt;wsp:ExactlyOne&gt;
            &lt;wsp:All&gt;
                &lt;sp:EncryptedParts&gt;
                    &lt;sp:Body /&gt;
                &lt;/sp:EncryptedParts&gt;
                &lt;sp:SignedParts&gt;
                    &lt;sp:Body /&gt;
                    &lt;sp:Header Name="To" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="From" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="FaultTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="ReplyTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="MessageID" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="RelatesTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="Action" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                &lt;/sp:SignedParts&gt;
            &lt;/wsp:All&gt;
        &lt;/wsp:ExactlyOne&gt;
    &lt;/wsp:Policy&gt;
    
    &lt;wsp:Policy wsu:Id="Output_Policy"&gt;
        &lt;wsp:ExactlyOne&gt;
            &lt;wsp:All&gt;
                &lt;sp:EncryptedParts&gt;
                    &lt;sp:Body /&gt;
                &lt;/sp:EncryptedParts&gt;
                &lt;sp:SignedParts&gt;
                    &lt;sp:Body /&gt;
                    &lt;sp:Header Name="To" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="From" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="FaultTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="ReplyTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="MessageID" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="RelatesTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="Action" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                &lt;/sp:SignedParts&gt;
            &lt;/wsp:All&gt;
        &lt;/wsp:ExactlyOne&gt;
    &lt;/wsp:Policy&gt;
&lt;/definitions&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-WebserviceproviderInterface"/>5.13.4.1.2. Web service provider Interface</h5></div></div></div><p>The web service provider interface class, ServiceIface, is a simple straight forward web service definition.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service;

import javax.jws.WebMethod;
import javax.jws.WebService;

@WebService
(
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy"
)
public interface ServiceIface
{
   @WebMethod
   String sayHello();
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-WebserviceproviderImplementation"/>5.13.4.1.3. Web service provider Implementation</h5></div></div></div><p>
              The web service provider implementation class, ServiceImpl, is a  simple POJO.  It uses the standard WebService annotation to define the  service endpoint.  In addition there are two Apache CXF annotations,  EndpointProperties and EndpointProperty used for configuring the  endpoint for the CXF runtime.  These annotations come from the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://ws.apache.org/wss4j/">Apache WSS4J project</a>
              ,  which provides a Java implementation of the primary WS-Security  standards for Web Services.  These annotations are programmatically  adding properties to the endpoint. With plain Apache CXF, these properties are often set via the  &lt;jaxws:properties&gt; element on the   &lt;jaxws:endpoint&gt; element  in the Spring config; these   annotations allow the properties to be  configured in the code.
            </p><p>WSS4J  uses the Crypto interface to get keys and certificates for  encryption/decryption and for signature creation/verification.  As is  asserted by the WSDL, X509 keys and certificates are required for this  service.  The WSS4J configuration information being provided by  ServiceImpl is for Crypto's Merlin implementation.  More information  will be provided about this in the keystore section.</p><p>The first EndpointProperty statement in the listing is declaring the user's name to use for the message  signature.  It is used as the alias name in the keystore to get the  user's cert and private key for signature.  The next two EndpointProperty statements declares the Java properties file that contains the (Merlin)  crypto configuration information.  In this case both for signing and  encrypting the messages.  WSS4J reads this file and extra required  information for message handling.  The last EndpointProperty statement declares the ServerCallbackHandler implementation class.  It is used  to obtain the user's password for the certificates in the keystore  file.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service;

import javax.jws.WebService;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;

@WebService
(
   portName = "SecurityServicePort",
   serviceName = "SecurityService",
   wsdlLocation = "WEB-INF/wsdl/SecurityService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service.ServiceIface"
)
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "myservicekey"),
      @EndpointProperty(key = "ws-security.signature.properties", value = "serviceKeystore.properties"),
      @EndpointProperty(key = "ws-security.encryption.properties", value = "serviceKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service.ServerCallbackHandler")
})
public class ServiceImpl implements ServiceIface
{
   public String sayHello()
   {
      return "WS-Trust Hello World!";
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-ServerCallbackHandler"/>5.13.4.1.4. ServerCallbackHandler</h5></div></div></div><p>ServerCallbackHandler is a callback handler for the WSS4J Crypto API.   It is used to obtain the password for the private key in the keystore.   This class enables CXF to retrieve the password of the user name to use  for the message signature.  A certificates' password is not  discoverable.  The creator of the certificate must record the password  he assigns and provide it when requested through the CallbackHandler.   In this scenario skpass is the password for user myservicekey.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
 package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service;

import java.util.HashMap;
import java.util.Map;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;

public class ServerCallbackHandler extends PasswordCallbackHandler
{

   public ServerCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("myservicekey", "skpass");
      return passwords;
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-Cryptopropertiesandkeystorefiles"/>5.13.4.1.5. Crypto properties and keystore files</h5></div></div></div><p>WSS4J's Crypto implementation is loaded and configured via a Java  properties file that contains Crypto configuration data.  The file  contains implementation-specific properties such as a keystore location,  password, default alias and the like.  This application is using the  Merlin implementation. File serviceKeystore.properties contains this  information.</p><p>
              File  servicestore.jks, is a Java KeyStore (JKS) repository.  It contains  self signed certificates for myservicekey and mystskey.
              <span class="italics">Self signed certificates are not appropriate for production use.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=sspass
org.apache.ws.security.crypto.merlin.keystore.alias=myservicekey
org.apache.ws.security.crypto.merlin.keystore.file=servicestore.jks
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-MANIFEST.MF"/>5.13.4.1.6. MANIFEST.MF</h5></div></div></div><p>When deployed on WildFly this application requires  access to the JBossWS and Apache CXF APIs provided in module  org.jboss.ws.cxf.jbossws-cxf-client.  The dependency statement directs the server to provide them at deployment.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Manifest-Version: 1.0  
Ant-Version: Apache Ant 1.8.2  
Created-By: 1.7.0_25-b15 (Oracle Corporation)  
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-47972359_WS-TrustandSTS-SecurityTokenService%28STS%29"/>5.13.4.2. Security Token Service (STS)</h4></div></div></div><p>This section examines the crucial elements in providing the Security  Token Service functionality described in the basic WS-Trust scenario.   The components that will be discussed are.</p><div class="itemizedlist"><ul><li><p>STS's WSDL</p></li><li><p>STS's implementation class.</p></li><li><p>STSCallbackHandler class</p></li><li><p>Crypto properties and keystore files</p></li><li><p>MANIFEST.MF</p></li><li><p>Server configuration files</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-STSWSDL"/>5.13.4.2.1. STS WSDL</h5></div></div></div><p>The STS is a contract-first endpoint.  All the WS-trust and security  policies for it are declared in the WSDL, ws-trust-1.4-service.wsdl.  A  symmetric binding policy is used to encrypt and sign the SOAP body of  messages that pass back and forth between ws-requester and the STS.  The  ws-requester is required to authenticate itself by providing WSS  UsernameToken credentials.  The rules for sharing the public and private  keys in the SOAP request and response messages are declared.  A detailed explanation of the security  settings are provided in the comments in the listing below.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
 &lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;wsdl:definitions
        targetNamespace="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
        xmlns:tns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
        xmlns:wstrust="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
        xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
        xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
        xmlns:wsap10="http://www.w3.org/2006/05/addressing/wsdl"
        xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
        xmlns:wsp="http://www.w3.org/ns/ws-policy"
    xmlns:wst="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"&gt;

  &lt;wsdl:types&gt;
    &lt;xs:schema elementFormDefault="qualified" targetNamespace='http://docs.oasis-open.org/ws-sx/ws-trust/200512'&gt;

      &lt;xs:element name='RequestSecurityToken' type='wst:AbstractRequestSecurityTokenType' /&gt;
      &lt;xs:element name='RequestSecurityTokenResponse' type='wst:AbstractRequestSecurityTokenType' /&gt;

      &lt;xs:complexType name='AbstractRequestSecurityTokenType' &gt;
        &lt;xs:sequence&gt;
          &lt;xs:any namespace='##any' processContents='lax' minOccurs='0' maxOccurs='unbounded' /&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name='Context' type='xs:anyURI' use='optional' /&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax' /&gt;
      &lt;/xs:complexType&gt;
      &lt;xs:element name='RequestSecurityTokenCollection' type='wst:RequestSecurityTokenCollectionType' /&gt;
      &lt;xs:complexType name='RequestSecurityTokenCollectionType' &gt;
        &lt;xs:sequence&gt;
          &lt;xs:element name='RequestSecurityToken' type='wst:AbstractRequestSecurityTokenType' minOccurs='2' maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name='RequestSecurityTokenResponseCollection' type='wst:RequestSecurityTokenResponseCollectionType' /&gt;
      &lt;xs:complexType name='RequestSecurityTokenResponseCollectionType' &gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref='wst:RequestSecurityTokenResponse' minOccurs='1' maxOccurs='unbounded' /&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax' /&gt;
      &lt;/xs:complexType&gt;

    &lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;

  &lt;!-- WS-Trust defines the following GEDs --&gt;
  &lt;wsdl:message name="RequestSecurityTokenMsg"&gt;
    &lt;wsdl:part name="request" element="wst:RequestSecurityToken" /&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseMsg"&gt;
    &lt;wsdl:part name="response"
            element="wst:RequestSecurityTokenResponse" /&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenCollectionMsg"&gt;
    &lt;wsdl:part name="requestCollection"
            element="wst:RequestSecurityTokenCollection"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseCollectionMsg"&gt;
    &lt;wsdl:part name="responseCollection"
            element="wst:RequestSecurityTokenResponseCollection"/&gt;
  &lt;/wsdl:message&gt;

  &lt;!-- This portType an example of a Requestor (or other) endpoint that
         Accepts SOAP-based challenges from a Security Token Service --&gt;
  &lt;wsdl:portType name="WSSecurityRequestor"&gt;
    &lt;wsdl:operation name="Challenge"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;


  &lt;!-- This portType is an example of an STS supporting full protocol --&gt;
&lt;!--
    The wsdl:portType and data types are XML elements defined by the
    WS_Trust specification.  The wsdl:portType defines the endpoints
    supported in the STS implementation.  This WSDL defines all operations
    that an STS implementation can support.
--&gt;      
  &lt;wsdl:portType name="STS"&gt;
    &lt;wsdl:operation name="Cancel"&gt;
      &lt;wsdl:input wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/CancelFinal" message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Issue"&gt;
      &lt;wsdl:input wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTRC/IssueFinal" message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Renew"&gt;
      &lt;wsdl:input wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/RenewFinal" message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Validate"&gt;
      &lt;wsdl:input wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/ValidateFinal" message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="KeyExchangeToken"&gt;
      &lt;wsdl:input wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KET" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/KETFinal" message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="RequestCollection"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenCollectionMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!-- This portType is an example of an endpoint that accepts
         Unsolicited RequestSecurityTokenResponse messages --&gt;
  &lt;wsdl:portType name="SecurityTokenResponseService"&gt;
    &lt;wsdl:operation name="RequestSecurityTokenResponse"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

&lt;!--
    The wsp:PolicyReference binds the security requirments on all the STS endpoints.
    The wsp:Policy wsu:Id="UT_policy" element is later in this file.
--&gt;
  &lt;wsdl:binding name="UT_Binding" type="wstrust:STS"&gt;
    &lt;wsp:PolicyReference URI="#UT_policy" /&gt;
      &lt;soap:binding style="document"
          transport="http://schemas.xmlsoap.org/soap/http" /&gt;
      &lt;wsdl:operation name="Issue"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue" /&gt;
          &lt;wsdl:input&gt;
              &lt;wsp:PolicyReference
               URI="#Input_policy" /&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;wsp:PolicyReference
               URI="#Output_policy" /&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
      &lt;wsdl:operation name="Validate"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate" /&gt;
          &lt;wsdl:input&gt;
              &lt;wsp:PolicyReference
               URI="#Input_policy" /&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;wsp:PolicyReference
               URI="#Output_policy" /&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
      &lt;wsdl:operation name="Cancel"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel" /&gt;
          &lt;wsdl:input&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
      &lt;wsdl:operation name="Renew"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew" /&gt;
          &lt;wsdl:input&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
      &lt;wsdl:operation name="KeyExchangeToken"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KeyExchangeToken" /&gt;
          &lt;wsdl:input&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
      &lt;wsdl:operation name="RequestCollection"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/RequestCollection" /&gt;
          &lt;wsdl:input&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
 
  &lt;wsdl:service name="SecurityTokenService"&gt;
      &lt;wsdl:port name="UT_Port" binding="tns:UT_Binding"&gt;
         &lt;soap:address location="http://localhost:8080/SecurityTokenService/UT" /&gt;
      &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
 
  &lt;wsp:Policy wsu:Id="UT_policy"&gt;
      &lt;wsp:ExactlyOne&gt;
         &lt;wsp:All&gt;
&lt;!--
    The sp:UsingAddressing element, indicates that the endpoints of this
    web service conforms to the WS-Addressing specification.  More detail
    can be found here: [http://www.w3.org/TR/2006/CR-ws-addr-wsdl-20060529]
--&gt;  
            &lt;wsap10:UsingAddressing/&gt;
&lt;!--
    The sp:SymmetricBinding element indicates that security is provided
    at the SOAP layer and any initiator must authenticate itself by providing
    WSS UsernameToken credentials.
--&gt;            
            &lt;sp:SymmetricBinding
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
&lt;!--
    In a symmetric binding, the keys used for encrypting and signing in both
    directions are derived from a single key, the one specified by the
    sp:ProtectionToken element.  The sp:X509Token sub-element declares this
    key to be a X.509 certificate and the
    IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"
    attribute adds the requirement that the token MUST NOT be included in
    any messages sent between the initiator and the recipient; rather, an
    external reference to the token should be used.  Lastly the WssX509V3Token10
    sub-element declares that the Username token presented by the initiator
    should be compliant with Web Services Security UsernameToken Profile
    1.0 specification. [ http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0.pdf ]
--&gt;                      
                  &lt;sp:ProtectionToken&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:X509Token
                           sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
                           &lt;wsp:Policy&gt;
                              &lt;sp:RequireDerivedKeys /&gt;
                              &lt;sp:RequireThumbprintReference /&gt;
                              &lt;sp:WssX509V3Token10 /&gt;
                           &lt;/wsp:Policy&gt;
                        &lt;/sp:X509Token&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:ProtectionToken&gt;
&lt;!--
    The sp:AlgorithmSuite element, requires the Basic256 algorithm suite
    be used in performing cryptographic operations.
--&gt;                  
                  &lt;sp:AlgorithmSuite&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:Basic256 /&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:AlgorithmSuite&gt;
&lt;!--
    The sp:Layout element,  indicates the layout rules to apply when adding
    items to the security header.  The sp:Lax sub-element indicates items
    are added to the security header in any order that conforms to
    WSS: SOAP Message Security.
--&gt;                 
                  &lt;sp:Layout&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:Lax /&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:Layout&gt;
                  &lt;sp:IncludeTimestamp /&gt;
                  &lt;sp:EncryptSignature /&gt;
                  &lt;sp:OnlySignEntireHeadersAndBody /&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:SymmetricBinding&gt;
&lt;!--
    The sp:SignedSupportingTokens element declares that the security header
    of messages must contain a sp:UsernameToken and the token must be signed.  
    The attribute IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"
    on sp:UsernameToken indicates that the token MUST be included in all
    messages sent from initiator to the recipient and that the token MUST
    NOT be included in messages sent from the recipient to the initiator.  
    And finally the element sp:WssUsernameToken10 is a policy assertion
    indicating the Username token should be as defined in  Web Services
    Security UsernameToken Profile 1.0
--&gt;            
            &lt;sp:SignedSupportingTokens
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
                  &lt;sp:UsernameToken
                     sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:WssUsernameToken10 /&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:UsernameToken&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:SignedSupportingTokens&gt;
&lt;!--
    The sp:Wss11 element declares WSS: SOAP Message Security 1.1 options
    to be supported by the STS.  These particular elements generally refer
    to how keys are referenced within the SOAP envelope.  These are normally
    handled by CXF.
--&gt;            
            &lt;sp:Wss11
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
                  &lt;sp:MustSupportRefKeyIdentifier /&gt;
                  &lt;sp:MustSupportRefIssuerSerial /&gt;
                  &lt;sp:MustSupportRefThumbprint /&gt;
                  &lt;sp:MustSupportRefEncryptedKey /&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:Wss11&gt;
&lt;!--
    The sp:Trust13 element declares controls for WS-Trust 1.3 options.  
    They are policy assertions related to exchanges specifically with
    client and server challenges and entropy behaviors.  Again these are
    normally handled by CXF.
--&gt;            
            &lt;sp:Trust13
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
                  &lt;sp:MustSupportIssuedTokens /&gt;
                  &lt;sp:RequireClientEntropy /&gt;
                  &lt;sp:RequireServerEntropy /&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:Trust13&gt;
         &lt;/wsp:All&gt;
      &lt;/wsp:ExactlyOne&gt;
   &lt;/wsp:Policy&gt;
   
   &lt;wsp:Policy wsu:Id="Input_policy"&gt;
      &lt;wsp:ExactlyOne&gt;
         &lt;wsp:All&gt;
            &lt;sp:SignedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
               &lt;sp:Header Name="To"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="From"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="FaultTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="ReplyTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="MessageID"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="RelatesTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="Action"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
            &lt;/sp:SignedParts&gt;
            &lt;sp:EncryptedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
            &lt;/sp:EncryptedParts&gt;
         &lt;/wsp:All&gt;
      &lt;/wsp:ExactlyOne&gt;
   &lt;/wsp:Policy&gt;
   
   &lt;wsp:Policy wsu:Id="Output_policy"&gt;
      &lt;wsp:ExactlyOne&gt;
         &lt;wsp:All&gt;
            &lt;sp:SignedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
               &lt;sp:Header Name="To"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="From"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="FaultTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="ReplyTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="MessageID"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="RelatesTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="Action"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
            &lt;/sp:SignedParts&gt;
            &lt;sp:EncryptedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
            &lt;/sp:EncryptedParts&gt;
         &lt;/wsp:All&gt;
      &lt;/wsp:ExactlyOne&gt;
   &lt;/wsp:Policy&gt;

&lt;/wsdl:definitions&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-STSImplementation"/>5.13.4.2.2. STS Implementation</h5></div></div></div><p>
              The Apache CXF's STS, SecurityTokenServiceProvider, is a web service  provider that is compliant with the protocols and functionality defined  by the WS-Trust specification.  It has a modular architecture. Many of  its components are configurable or replaceable and there are many  optional features that are enabled by implementing and configuring  plug-ins.  Users can customize their own STS by extending from  SecurityTokenServiceProvider and overriding the default settings.   Extensive information about the CXF's STS configurable and pluggable  components can be found
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://coheigea.blogspot.com/2011/11/apache-cxf-sts-documentation-part-viii_10.html">here</a>
              .
            </p><p>This STS implementation class, SimpleSTS, is a POJO that extends from  SecurityTokenServiceProvider.  Note that the class is defined with a  WebServiceProvider annotation and not a WebService  annotation.  This annotation defines the service as a Provider-based  endpoint, meaning it supports a more messaging-oriented approach to Web  services.  In particular, it signals that the exchanged messages will be  XML documents of some type.  SecurityTokenServiceProvider is an  implementation of the javax.xml.ws.Provider interface.  In comparison  the WebService annotation defines a (service endpoint interface)  SEI-based endpoint which supports message exchange via SOAP envelopes.</p><p>
              As was  done in the ServiceImpl class, the WSS4J annotations EndpointProperties  and EndpointProperty are providing endpoint configuration  for the CXF runtime.  This was previous described
              <a href="sid-3866738.html#sid-47972359_WS-TrustandSTS-WebserviceproviderImplementation" title="5.13.4.1.3. Web service provider Implementation">here</a>
              .
            </p><p>The  InInterceptors annotation is used to specify a JBossWS  integration interceptor to be used for authenticating incoming requests;  JAAS integration is used here for authentication, the  username/passoword coming from the UsernameToken in the ws-requester  message are used for authenticating the requester against a security  domain on the application server hosting the STS deployment.</p><p>In this implementation we are customizing the operations of token issuance, token validation and their static properties.</p><p>StaticSTSProperties is used to set select properties for configuring resources  in the STS.  You may think this is a duplication of the settings made  with the WSS4J annotations.  The values are the same but the underlaying  structures being set are different, thus this information must be  declared in both places.</p><p>The  setIssuer setting is important because it uniquely identifies  the issuing STS.  The issuer string is embedded in issued tokens and,  when validating tokens, the STS checks the issuer string value.  Consequently, it is important to use the issuer string in a consistent  way, so that the STS can recognize the tokens that it has issued.</p><p>The setEndpoints call allows the declaration of a set  of allowed token recipients by address.  The addresses are specified  as reg-ex patterns.</p><p>TokenIssueOperation  and TokenValidateOperation  have a modular structure.   This allows custom behaviors to be injected into the processing of  messages.  In this case we are overriding the  SecurityTokenServiceProvider's default behavior and performing SAML  token processing and validation.  CXF provides an implementation of a  SAMLTokenProvider and SAMLTokenValidator which we are using rather than  writing our own.</p><p>
              Learn more about the SAMLTokenProvider
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://coheigea.blogspot.it/2011/10/apache-cxf-sts-documentation-part-iv.html">here</a>
              .
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust;
 
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
 
import javax.xml.ws.WebServiceProvider;
 
import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.interceptor.InInterceptors;
import org.apache.cxf.sts.StaticSTSProperties;
import org.apache.cxf.sts.operation.TokenIssueOperation;
import org.apache.cxf.sts.operation.TokenValidateOperation;
import org.apache.cxf.sts.service.ServiceMBean;
import org.apache.cxf.sts.service.StaticService;
import org.apache.cxf.sts.token.provider.SAMLTokenProvider;
import org.apache.cxf.sts.token.validator.SAMLTokenValidator;
import org.apache.cxf.ws.security.sts.provider.SecurityTokenServiceProvider;
 
@WebServiceProvider(serviceName = "SecurityTokenService",
      portName = "UT_Port",
      targetNamespace = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/",
      wsdlLocation = "WEB-INF/wsdl/ws-trust-1.4-service.wsdl")
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "mystskey"),
      @EndpointProperty(key = "ws-security.signature.properties", value = "stsKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.STSCallbackHandler"),
      //to let the JAAS integration deal with validation through the interceptor below
      @EndpointProperty(key = "ws-security.validate.token", value = "false")
        
})
@InInterceptors(interceptors = {"org.jboss.wsf.stack.cxf.security.authentication.SubjectCreatingPolicyInterceptor"})
public class SampleSTS extends SecurityTokenServiceProvider
{
   public SampleSTS() throws Exception
   {
      super();
 
      StaticSTSProperties props = new StaticSTSProperties();
      props.setSignaturePropertiesFile("stsKeystore.properties");
      props.setSignatureUsername("mystskey");
      props.setCallbackHandlerClass(STSCallbackHandler.class.getName());
      props.setIssuer("DoubleItSTSIssuer");
 
      List&lt;ServiceMBean&gt; services = new LinkedList&lt;ServiceMBean&gt;();
      StaticService service = new StaticService();
      service.setEndpoints(Arrays.asList(
              "http://localhost:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService",
              "http://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService",
              "http://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService"
              ));
      services.add(service);
 
      TokenIssueOperation issueOperation = new TokenIssueOperation();
      issueOperation.setServices(services);
      issueOperation.getTokenProviders().add(new SAMLTokenProvider());
      issueOperation.setStsProperties(props);
 
      TokenValidateOperation validateOperation = new TokenValidateOperation();
      validateOperation.getTokenValidators().add(new SAMLTokenValidator());
      validateOperation.setStsProperties(props);
 
      this.setIssueOperation(issueOperation);
      this.setValidateOperation(validateOperation);
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-STSCallbackHandler"/>5.13.4.2.3. STSCallbackHandler</h5></div></div></div><p>STSCallbackHandler is a callback handler for the WSS4J Crypto API.  It  is used to obtain the password for the private key in the keystore.   This class enables CXF to retrieve the password of the user name to use  for the message signature.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.sts;

import java.util.HashMap;
import java.util.Map;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;

public class STSCallbackHandler extends PasswordCallbackHandler
{
   public STSCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("mystskey", "stskpass");
      return passwords;
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-Cryptopropertiesandkeystorefilesx"/>5.13.4.2.4. Crypto properties and keystore files</h5></div></div></div><p>
              WSS4J's Crypto implementation is loaded and configured via a Java  properties file that contains Crypto configuration data.  The file  contains implementation-specific properties such as a keystore location,  password, default alias and the like.  This application is using the  Merlin implementation. File stsKeystore.properties contains this  information.
              
            </p><p>
              File  servicestore.jks, is a Java KeyStore (JKS) repository.  It contains  self signed certificates for myservicekey and mystskey.
              <span class="italics">Self signed certificates are not appropriate for production use.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin  
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=stsspass
org.apache.ws.security.crypto.merlin.keystore.file=stsstore.jks
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-MANIFEST.MFx"/>5.13.4.2.5. MANIFEST.MF</h5></div></div></div><p>
              When deployed on WildFly, this application requires  access to the JBossWS and Apache CXF APIs provided in module org.jboss.ws.cxf.jbossws-cxf-client.  The org.jboss.ws.cxf.sts module is also needed to build the STS configuration in  the
              <code class="code">SampleSTS</code>
              constructor.  The dependency statement directs the server to provide them at deployment.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Manifest-Version: 1.0  
Ant-Version: Apache Ant 1.8.2  
Created-By: 1.7.0_25-b15 (Oracle Corporation)  
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client,org.jboss.ws.cxf.sts
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-SecurityDomain"/>5.13.4.2.6. Security Domain</h5></div></div></div><p>The STS requires a JBoss security domain be configured.  The jboss-web.xml descriptor declares a named security domain,"JBossWS-trust-sts" to be used by this service for authentication.  This security domain requires two properties files and the addition of a security-domain declaration in the JBoss server configuration file.</p><p>
              For this scenario the domain needs to contain user
              <span class="italics">alice</span>
              , password
              <span class="italics">clarinet</span>
              , and role
              <span class="italics">friend</span>
              . See the listings below for jbossws-users.properties and jbossws-roles.properties.  In addition the following XML must be added to the JBoss security subsystem in the server configuration file.  Replace "
              <span class="strong"><strong>SOME_PATH</strong></span>
              " with appropriate information.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
 &lt;security-domain name="JBossWS-trust-sts"&gt;
  &lt;authentication&gt;
    &lt;login-module code="UsersRoles" flag="required"&gt;
      &lt;module-option name="usersProperties" value="/SOME_PATH/jbossws-users.properties"/&gt;
      &lt;module-option name="unauthenticatedIdentity" value="anonymous"/&gt;
      &lt;module-option name="rolesProperties" value="/SOME_PATH/jbossws-roles.properties"/&gt;
    &lt;/login-module&gt;
  &lt;/authentication&gt;
&lt;/security-domain&gt;
</pre></div><p>jboss-web.xml</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;  
&lt;!DOCTYPE jboss-web PUBLIC "-//JBoss//DTD Web Application 2.4//EN" "&gt;  
&lt;jboss-web&gt;  
  &lt;security-domain&gt;java:/jaas/JBossWS-trust-sts&lt;/security-domain&gt;  
&lt;/jboss-web&gt;
</pre></div><p>jbossws-users.properties</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
# A sample users.properties file for use with the UsersRolesLoginModule  
alice=clarinet
</pre></div><p>jbossws-roles.properties</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
# A sample roles.properties file for use with the UsersRolesLoginModule  
alice=friend
</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>WS-MetadataExchange and interoperability</h2><p>
                To  achieve better interoperability, you might consider allowing the STS  endpoint to reply to WS-MetadataExchange messages directed to the
                <code class="code">/mex</code>
                URL sub-path (e.g.
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://localhost:8080/jaxws-samples-wsse-policy-trust-sts/SecurityTokenService/mex">http://localhost:8080/jaxws-samples-wsse-policy-trust-sts/SecurityTokenService/mex</a>
                ). This can be done by tweaking the
                <span class="italics">url-pattern</span>
                for the underlying endpoint servlet, for instance by adding a
                <span class="italics">web.xml</span>
                descriptor as follows to the deployment:&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                
                &lt;web-app
                
                version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
                
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                
                xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd</a>
                "&gt;
                
                &lt;servlet&gt;
                
                &lt;servlet-name&gt;TestSecurityTokenService&lt;/servlet-name&gt;
                
                &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.trust.SampleSTS&lt;/servlet-class&gt;
                
                &lt;/servlet&gt;
                
                &lt;servlet-mapping&gt;
                
                &lt;servlet-name&gt;TestSecurityTokenService&lt;/servlet-name&gt;
                
                &lt;url-pattern&gt;/SecurityTokenService/*&lt;/url-pattern&gt;
                
                &lt;/servlet-mapping&gt;
                
                &lt;/web-app&gt;
                
                As a matter of fact, at the time of writing some webservices implementations (including
                <span class="italics">Metro</span>
                ) assume the
                <code class="code">/mex</code>
                URL as the default choice for directing WS-MetadataExchange requests to and use that to retrieve STS wsdl contracts.
              </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-47972359_WS-TrustandSTS-Webservicerequester"/>5.13.4.3. Web service requester</h4></div></div></div><p>This section examines the crucial elements in calling a web service  that implements endpoint security as described in the basic WS-Trust  scenario.  The components that will be discussed are.</p><div class="itemizedlist"><ul><li><p>web service requester's implementation</p></li><li><p>ClientCallbackHandler</p></li><li><p>Crypto properties and keystore files</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-WebservicerequesterImplementation"/>5.13.4.3.1. Web service requester Implementation</h5></div></div></div><p>
              The ws-requester, the client, uses standard procedures for creating a  reference to the web service in the first four line.  To address the endpoint  security requirements, the web service's "Request Context" is configured with the information needed in message generation.  In  addition, the STSClient that communicates with the STS is configured  with similar values.  Note the key strings ending with a  ".it" suffix.  This suffix flags these settings as belonging to the  STSClient.  The internal CXF code assigns this information to the  STSClient that is auto-generated for this service call.
              
            </p><p>There  is an alternate method of setting up the STSCLient.  The user may  provide their own instance of the STSClient.  The CXF code will use this  object and not auto-generate one.  This is used in the ActAs and OnBehalfOf examples.  When providing the  STSClient in this way, the user must provide a org.apache.cxf.Bus for it  and the configuration keys must not have the ".it" suffix.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy", "SecurityService");  
URL wsdlURL = new URL(serviceURL + "?wsdl");  
Service service = Service.create(wsdlURL, serviceName);  
ServiceIface proxy = (ServiceIface) service.getPort(ServiceIface.class);  
 
// set the security related configuration information for the service "request"  
Map&lt;String, Object&gt; ctx = ((BindingProvider) proxy).getRequestContext();  
ctx.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());  
ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
   Thread.currentThread().getContextClassLoader().getResource(
   "META-INF/clientKeystore.properties"));  
ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
   Thread.currentThread().getContextClassLoader().getResource(
   "META-INF/clientKeystore.properties"));  
ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myclientkey");  
ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myservicekey");  
 
 
//-- Configuration settings that will be transfered to the STSClient  
// "alice" is the name provided for the WSS Username. Her password will  
// be retreived from the ClientCallbackHander by the STSClient.  
ctx.put(SecurityConstants.USERNAME + ".it", "alice");  
ctx.put(SecurityConstants.CALLBACK_HANDLER + ".it", new ClientCallbackHandler());  
ctx.put(SecurityConstants.ENCRYPT_PROPERTIES + ".it",
   Thread.currentThread().getContextClassLoader().getResource(
   "META-INF/clientKeystore.properties"));  
ctx.put(SecurityConstants.ENCRYPT_USERNAME + ".it", "mystskey");  
// alias name in the keystore to get the user's public key to send to the STS  
ctx.put(SecurityConstants.STS_TOKEN_USERNAME + ".it", "myclientkey");  
// Crypto property configuration to use for the STS  
ctx.put(SecurityConstants.STS_TOKEN_PROPERTIES + ".it",
   Thread.currentThread().getContextClassLoader().getResource(
   "META-INF/clientKeystore.properties"));  
// write out an X509Certificate structure in UseKey/KeyInfo  
ctx.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO + ".it", "true");  
// Setting indicates the  STSclient should not try using the WS-MetadataExchange  
// call using STS EPR WSA address when the endpoint contract does not contain  
// WS-MetadataExchange info.  
ctx.put("ws-security.sts.disable-wsmex-call-using-epr-address", "true");  
   
proxy.sayHello();
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-ClientCallbackHandler"/>5.13.4.3.2. ClientCallbackHandler</h5></div></div></div><p>ClientCallbackHandler is a callback handler for the WSS4J Crypto API.   It is used to obtain the password for the private key in the keystore.   This class enables CXF to retrieve the password of the user name to use  for the message signature.  Note that "alice" and her password have been  provided here.  This information is not in the (JKS)  keystore but  provided in the WildFly security domain.  It was  declared in file jbossws-users.properties.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared;  
 
import java.io.IOException;  
import javax.security.auth.callback.Callback;  
import javax.security.auth.callback.CallbackHandler;  
import javax.security.auth.callback.UnsupportedCallbackException;  
import org.apache.ws.security.WSPasswordCallback;  
 
public class ClientCallbackHandler implements CallbackHandler {  
 
    public void handle(Callback[] callbacks) throws IOException,  
            UnsupportedCallbackException {  
        for (int i = 0; i &lt; callbacks.length; i++) {  
            if (callbacks[i] instanceof WSPasswordCallback) {  
                WSPasswordCallback pc = (WSPasswordCallback) callbacks[i];  
                if ("myclientkey".equals(pc.getIdentifier())) {  
                    pc.setPassword("ckpass");  
                    break;  
                } else if ("alice".equals(pc.getIdentifier())) {  
                    pc.setPassword("clarinet");  
                    break;  
                }  
            }  
        }  
    }  
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-47972359_WS-TrustandSTS-RequesterCryptopropertiesandkeystorefiles"/>5.13.4.3.3. Requester Crypto properties and keystore files</h5></div></div></div><p>
              WSS4J's Crypto implementation is loaded and configured via a Java  properties file that contains Crypto configuration data.  The file  contains implementation-specific properties such as a keystore location,  password, default alias and the like.  This application is using the  Merlin implementation. File clientKeystore.properties contains this  information.
              
            </p><p>
              File  clientstore.jks, is a Java KeyStore (JKS) repository.  It contains self  signed certificates for myservicekey and mystskey.
              <span class="italics">Self signed certificates are not appropriate for production use.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=cspass
org.apache.ws.security.crypto.merlin.keystore.alias=myclientkey
org.apache.ws.security.crypto.merlin.keystore.file=META-INF/clientstore.jks
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-47972359_WS-TrustandSTS-PicketLinkSTS"/>5.13.4.4. PicketLink STS</h4></div></div></div><p>
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.jboss.org/picketlink">PicketLink</a>
            provides facilities for building up an alternative to the Apache CXF Security Token Service implementation.
          </p><p>Similarly to the previous implementation, the STS is served through a WebServiceProvider annotated POJO:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
 package org.jboss.test.ws.jaxws.samples.wsse.policy.trust;

import javax.annotation.Resource;
import javax.xml.ws.Service;
import javax.xml.ws.ServiceMode;
import javax.xml.ws.WebServiceContext;
import javax.xml.ws.WebServiceProvider;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.interceptor.InInterceptors;
import org.picketlink.identity.federation.core.wstrust.PicketLinkSTS;

@WebServiceProvider(serviceName = "PicketLinkSTS", portName = "PicketLinkSTSPort", targetNamespace = "urn:picketlink:identity-federation:sts", wsdlLocation = "WEB-INF/wsdl/PicketLinkSTS.wsdl")
@ServiceMode(value = Service.Mode.MESSAGE)
//be sure to have dependency on org.apache.cxf module when on AS7, otherwise Apache CXF annotations are ignored
@EndpointProperties(value = {
@EndpointProperty(key = "ws-security.signature.username", value = "mystskey"),
@EndpointProperty(key = "ws-security.signature.properties", value = "stsKeystore.properties"),
@EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.STSCallbackHandler"),
@EndpointProperty(key = "ws-security.validate.token", value = "false") //to let the JAAS integration deal with validation through the interceptor below
})
@InInterceptors(interceptors =

)
public class PicketLinkSTService extends PicketLinkSTS {
@Resource
public void setWSC(WebServiceContext wctx)
Unknown macro: { this.context = wctx; }

}
</pre></div><p>
            The
            <code class="code">@WebServiceProvider</code>
            annotation references the following WS-Policy enabled wsdl contract; please note the wsdl operations, messages and such must match the
            <code class="code">PicketLinkSTS</code>
            implementation:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0"?&gt;
&lt;wsdl:definitions name="PicketLinkSTS" targetNamespace="urn:picketlink:identity-federation:sts"
    xmlns:tns="urn:picketlink:identity-federation:sts"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
    xmlns:wsap10="http://www.w3.org/2006/05/addressing/wsdl"
    xmlns:wsp="http://www.w3.org/ns/ws-policy"
    xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
    xmlns:wst="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
    xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/"&gt;
  &lt;wsdl:types&gt;
    &lt;xs:schema elementFormDefault="qualified" targetNamespace='http://docs.oasis-open.org/ws-sx/ws-trust/200512' xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
      &lt;xs:element name='RequestSecurityToken' type='wst:AbstractRequestSecurityTokenType' /&gt;
      &lt;xs:element name='RequestSecurityTokenResponse' type='wst:AbstractRequestSecurityTokenType' /&gt;
      &lt;xs:complexType name='AbstractRequestSecurityTokenType' &gt;
        &lt;xs:sequence&gt;
          &lt;xs:any namespace='##any' processContents='lax' minOccurs='0' maxOccurs='unbounded' /&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name='Context' type='xs:anyURI' use='optional' /&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax' /&gt;
      &lt;/xs:complexType&gt;
      &lt;xs:element name='RequestSecurityTokenCollection' type='wst:RequestSecurityTokenCollectionType' /&gt;
      &lt;xs:complexType name='RequestSecurityTokenCollectionType' &gt;
        &lt;xs:sequence&gt;
          &lt;xs:element name='RequestSecurityToken' type='wst:AbstractRequestSecurityTokenType' minOccurs='2' maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;
      &lt;xs:element name='RequestSecurityTokenResponseCollection' type='wst:RequestSecurityTokenResponseCollectionType' /&gt;
      &lt;xs:complexType name='RequestSecurityTokenResponseCollectionType' &gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref='wst:RequestSecurityTokenResponse' minOccurs='1' maxOccurs='unbounded' /&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax' /&gt;
      &lt;/xs:complexType&gt;
    &lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;
 
  &lt;wsdl:message name="RequestSecurityTokenMsg"&gt;
    &lt;wsdl:part name="request" element="wst:RequestSecurityToken" /&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseCollectionMsg"&gt;
    &lt;wsdl:part name="responseCollection"
            element="wst:RequestSecurityTokenResponseCollection"/&gt;
  &lt;/wsdl:message&gt;
 
  &lt;wsdl:portType name="SecureTokenService"&gt;
    &lt;wsdl:operation name="IssueToken"&gt;
      &lt;wsdl:input wsap10:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsap10:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTRC/IssueFinal" message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;
  &lt;wsdl:binding name="STSBinding" type="tns:SecureTokenService"&gt;
    &lt;wsp:PolicyReference URI="#UT_policy" /&gt;
    &lt;soap12:binding transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="IssueToken"&gt;
      &lt;soap12:operation soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue" style="document"/&gt;
      &lt;wsdl:input&gt;
        &lt;wsp:PolicyReference URI="#Input_policy" /&gt;
        &lt;soap12:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;wsp:PolicyReference URI="#Output_policy" /&gt;
        &lt;soap12:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="PicketLinkSTS"&gt;
    &lt;wsdl:port name="PicketLinkSTSPort" binding="tns:STSBinding"&gt;
      &lt;soap12:address location="http://localhost:8080/picketlink-sts/PicketLinkSTS"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
 
  &lt;wsp:Policy wsu:Id="UT_policy"&gt;
      &lt;wsp:ExactlyOne&gt;
         &lt;wsp:All&gt;
            &lt;wsap10:UsingAddressing/&gt;
            &lt;sp:SymmetricBinding
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
                  &lt;sp:ProtectionToken&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:X509Token
                           sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
                           &lt;wsp:Policy&gt;
                              &lt;sp:RequireDerivedKeys /&gt;
                              &lt;sp:RequireThumbprintReference /&gt;
                              &lt;sp:WssX509V3Token10 /&gt;
                           &lt;/wsp:Policy&gt;
                        &lt;/sp:X509Token&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:ProtectionToken&gt;
                  &lt;sp:AlgorithmSuite&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:Basic256 /&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:AlgorithmSuite&gt;
                  &lt;sp:Layout&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:Lax /&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:Layout&gt;
                  &lt;sp:IncludeTimestamp /&gt;
                  &lt;sp:EncryptSignature /&gt;
                  &lt;sp:OnlySignEntireHeadersAndBody /&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:SymmetricBinding&gt;
            &lt;sp:SignedSupportingTokens
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
                  &lt;sp:UsernameToken
                     sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:WssUsernameToken10 /&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:UsernameToken&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:SignedSupportingTokens&gt;
            &lt;sp:Wss11
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
                  &lt;sp:MustSupportRefKeyIdentifier /&gt;
                  &lt;sp:MustSupportRefIssuerSerial /&gt;
                  &lt;sp:MustSupportRefThumbprint /&gt;
                  &lt;sp:MustSupportRefEncryptedKey /&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:Wss11&gt;
            &lt;sp:Trust13
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
                  &lt;sp:MustSupportIssuedTokens /&gt;
                  &lt;sp:RequireClientEntropy /&gt;
                  &lt;sp:RequireServerEntropy /&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:Trust13&gt;
         &lt;/wsp:All&gt;
      &lt;/wsp:ExactlyOne&gt;
   &lt;/wsp:Policy&gt;
 
   &lt;wsp:Policy wsu:Id="Input_policy"&gt;
      &lt;wsp:ExactlyOne&gt;
         &lt;wsp:All&gt;
            &lt;sp:SignedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
               &lt;sp:Header Name="To"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="From"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="FaultTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="ReplyTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="MessageID"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="RelatesTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="Action"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
            &lt;/sp:SignedParts&gt;
            &lt;sp:EncryptedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
            &lt;/sp:EncryptedParts&gt;
         &lt;/wsp:All&gt;
      &lt;/wsp:ExactlyOne&gt;
   &lt;/wsp:Policy&gt;
 
   &lt;wsp:Policy wsu:Id="Output_policy"&gt;
      &lt;wsp:ExactlyOne&gt;
         &lt;wsp:All&gt;
            &lt;sp:SignedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
               &lt;sp:Header Name="To"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="From"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="FaultTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="ReplyTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="MessageID"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="RelatesTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="Action"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
            &lt;/sp:SignedParts&gt;
            &lt;sp:EncryptedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
            &lt;/sp:EncryptedParts&gt;
         &lt;/wsp:All&gt;
      &lt;/wsp:ExactlyOne&gt;
   &lt;/wsp:Policy&gt;
 
&lt;/wsdl:definitions&gt;
</pre></div><p>Differently from the Apache CXF STS example described above, the  PicketLink based STS gets its configuration from a picketlink-sts.xml  descriptor which must be added in WEB-INF into the deployment; please  refer to the PicketLink documentation for further information:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;PicketLinkSTS xmlns="urn:picketlink:identity-federation:config:1.0"
    STSName="PicketLinkSTS" TokenTimeout="7200" EncryptToken="false"&gt;
    &lt;KeyProvider ClassName="org.picketlink.identity.federation.core.impl.KeyStoreKeyManager"&gt;
        &lt;Auth Key="KeyStoreURL" Value="stsstore.jks"/&gt;
        &lt;Auth Key="KeyStorePass" Value="stsspass"/&gt;
        &lt;Auth Key="SigningKeyAlias" Value="mystskey"/&gt;
        &lt;Auth Key="SigningKeyPass" Value="stskpass"/&gt;
        &lt;ValidatingAlias Key="http://localhost:8080/jaxws-samples-wsse-policy-trust/SecurityService" Value="myservicekey"/&gt;
    &lt;/KeyProvider&gt;
    &lt;TokenProviders&gt;
            &lt;TokenProvider ProviderClass="org.picketlink.identity.federation.core.wstrust.plugins.saml.SAML11TokenProvider"
                TokenType="http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV1.1"
            TokenElement="Assertion"
            TokenElementNS="urn:oasis:names:tc:SAML:1.0:assertion"/&gt;
            &lt;TokenProvider ProviderClass="org.picketlink.identity.federation.core.wstrust.plugins.saml.SAML20TokenProvider"
                TokenType="http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0"
            TokenElement="Assertion"
            TokenElementNS="urn:oasis:names:tc:SAML:2.0:assertion"/&gt;
    &lt;/TokenProviders&gt;
&lt;/PicketLinkSTS&gt;
</pre></div><p>Finally, the PicketLink alternative approach of course requires  different WildFly module dependencies to be declared in the  MANIFEST.MF:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Manifest-Version: 1.0
Ant-Version: Apache Ant 1.8.2
Created-By: 1.6.0_26-b03 (Sun Microsystems Inc.)
Dependencies: org.apache.ws.security,org.apache.cxf,org.picketlink
</pre></div><p>Here is how the PicketLink STS endpoint is packaged:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
alessio@inuyasha /dati/jbossws/stack/cxf/trunk $ jar -tvf ./modules/testsuite/cxf-tests/target/test-libs/jaxws-samples-wsse-policy-trustPicketLink-sts.war
     0 Mon Sep 03 17:38:38 CEST 2012 META-INF/
   174 Mon Sep 03 17:38:36 CEST 2012 META-INF/MANIFEST.MF
     0 Mon Sep 03 17:38:38 CEST 2012 WEB-INF/
     0 Mon Sep 03 17:38:38 CEST 2012 WEB-INF/classes/
     0 Mon Sep 03 16:35:50 CEST 2012 WEB-INF/classes/org/
     0 Mon Sep 03 16:35:50 CEST 2012 WEB-INF/classes/org/jboss/
     0 Mon Sep 03 16:35:50 CEST 2012 WEB-INF/classes/org/jboss/test/
     0 Mon Sep 03 16:35:52 CEST 2012 WEB-INF/classes/org/jboss/test/ws/
     0 Mon Sep 03 16:35:50 CEST 2012 WEB-INF/classes/org/jboss/test/ws/jaxws/
     0 Mon Sep 03 16:35:52 CEST 2012 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/
     0 Mon Sep 03 16:35:50 CEST 2012 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/
     0 Mon Sep 03 16:35:50 CEST 2012 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/
     0 Mon Sep 03 16:35:52 CEST 2012 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/trust/
  1686 Mon Sep 03 16:35:50 CEST 2012 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/trust/PicketLinkSTService.class
  1148 Mon Sep 03 16:35:52 CEST 2012 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/trust/STSCallbackHandler.class
   251 Mon Sep 03 17:38:34 CEST 2012 WEB-INF/jboss-web.xml
     0 Mon Sep 03 16:35:50 CEST 2012 WEB-INF/wsdl/
  9070 Mon Sep 03 17:38:34 CEST 2012 WEB-INF/wsdl/PicketLinkSTS.wsdl
  1267 Mon Sep 03 17:38:34 CEST 2012 WEB-INF/classes/picketlink-sts.xml
  1054 Mon Sep 03 16:35:50 CEST 2012 WEB-INF/classes/stsKeystore.properties
  3978 Mon Sep 03 16:35:50 CEST 2012 WEB-INF/classes/stsstore.jks
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-78711224"/>5.13.5. ActAs WS-Trust Scenario</h3></div></div></div><p>
          The ActAs feature is used in scenarios that require composite  delegation.  It is commonly used in multi-tiered systems where an  application calls a service on behalf of a logged in user or a service  calls another service on behalf of the original caller.
          
        </p><p>
          ActAs  is nothing more than a new sub-element in the RequestSecurityToken  (RST).  It provides additional information about the original caller  when a token is negotiated with the STS.  The ActAs element usually  takes the form of a token with identity claims such as name, role, and  authorization code, for the client to access the service.
          
        </p><p>
          The ActAs scenario is an extension of
          <a href="sid-3866738.html#sid-78711224" title="5.13.5. ActAs WS-Trust Scenario">the basic WS-Trust scenario</a>
          .   In this example the ActAs service calls the ws-service on behalf of a  user.  There are only a couple of additions to the basic scenario's  code.  An ActAs web service provider and callback handler have been  added.  The ActAs web services' WSDL  imposes the same security policies  as the ws-provider. UsernameTokenCallbackHandler is new.  It is a  utility that generates the content for the ActAs element.  And lastly  there are a couple of code additions in the STS to support the ActAs  request.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-Webserviceprovider"/>5.13.5.1. Web service provider</h4></div></div></div><p>This section examines the web service elements from the basic  WS-Trust scenario that have been changed to address the needs of the  ActAs example.  The components are</p><div class="itemizedlist"><ul><li><p>ActAs web service provider's WSDL</p></li><li><p>ActAs web service provider's Interface and Implementation classes.</p></li><li><p>ActAsCallbackHandler class</p></li><li><p>UsernameTokenCallbackHandler</p></li><li><p>Crypto properties and keystore files</p></li><li><p>MANIFEST.MF</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-WebserviceproviderWSDL"/>5.13.5.1.1. Web service provider WSDL</h5></div></div></div><p>The ActAs web service provider's WSDL is a clone of the ws-provider's  WSDL.  The wsp:Policy section is the same. There are  changes to the  service endpoint,  targetNamespace, portType, binding name, and service.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy" name="ActAsService"
             xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
             xmlns:wsp="http://www.w3.org/ns/ws-policy"
             xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"
             xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
             xmlns:wsaws="http://www.w3.org/2005/08/addressing"
             xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"
             xmlns:t="http://docs.oasis-open.org/ws-sx/ws-trust/200512"&gt;
    &lt;types&gt;
        &lt;xsd:schema&gt;
            &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy"
                    schemaLocation="ActAsService_schema1.xsd"/&gt;
        &lt;/xsd:schema&gt;
    &lt;/types&gt;
    &lt;message name="sayHello"&gt;
        &lt;part name="parameters" element="tns:sayHello"/&gt;
    &lt;/message&gt;
    &lt;message name="sayHelloResponse"&gt;
        &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
    &lt;/message&gt;
    &lt;portType name="ActAsServiceIface"&gt;
        &lt;operation name="sayHello"&gt;
            &lt;input message="tns:sayHello"/&gt;
            &lt;output message="tns:sayHelloResponse"/&gt;
        &lt;/operation&gt;
    &lt;/portType&gt;
    &lt;binding name="ActAsServicePortBinding" type="tns:ActAsServiceIface"&gt;
        &lt;wsp:PolicyReference URI="#AsymmetricSAML2Policy" /&gt;
        &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
        &lt;operation name="sayHello"&gt;
            &lt;soap:operation soapAction=""/&gt;
            &lt;input&gt;
                &lt;soap:body use="literal"/&gt;
                &lt;wsp:PolicyReference URI="#Input_Policy" /&gt;
            &lt;/input&gt;
            &lt;output&gt;
                &lt;soap:body use="literal"/&gt;
                &lt;wsp:PolicyReference URI="#Output_Policy" /&gt;
            &lt;/output&gt;
        &lt;/operation&gt;
    &lt;/binding&gt;
    &lt;service name="ActAsService"&gt;
        &lt;port name="ActAsServicePort" binding="tns:ActAsServicePortBinding"&gt;
            &lt;soap:address location="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-actas/ActAsService"/&gt;
        &lt;/port&gt;
    &lt;/service&gt;

&lt;/definitions&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-WebServiceInterface"/>5.13.5.1.2. Web Service Interface</h5></div></div></div><p>The web service provider interface class, ActAsServiceIface, is a simple web service definition.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.actas;

import javax.jws.WebMethod;
import javax.jws.WebService;

@WebService
(
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy"
)
public interface ActAsServiceIface
{
   @WebMethod
   String sayHello();
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-WebServiceImplementation"/>5.13.5.1.3. Web Service Implementation</h5></div></div></div><p>
              The web service provider implementation class, ActAsServiceImpl, is a  simple POJO.  It uses the standard WebService annotation to define the  service endpoint  and two Apache WSS4J annotations, EndpointProperties  and EndpointProperty used for configuring the endpoint for the CXF  runtime.  The WSS4J configuration information provided is for WSS4J's  Crypto Merlin implementation.
              
            </p><p>ActAsServiceImpl  is calling ServiceImpl acting on behalf of the user.  Method  setupService performs the requisite configuration setup.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.actas;

import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.ws.security.SecurityConstants;
import org.apache.cxf.ws.security.trust.STSClient;
import org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service.ServiceIface;
import org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared.WSTrustAppUtils;

import javax.jws.WebService;
import javax.xml.namespace.QName;
import javax.xml.ws.BindingProvider;
import javax.xml.ws.Service;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Map;

@WebService
(
   portName = "ActAsServicePort",
   serviceName = "ActAsService",
   wsdlLocation = "WEB-INF/wsdl/ActAsService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.actas.ActAsServiceIface"
)

@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "myactaskey"),
      @EndpointProperty(key = "ws-security.signature.properties", value =  "actasKeystore.properties"),
      @EndpointProperty(key = "ws-security.encryption.properties", value = "actasKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.actas.ActAsCallbackHandler")
})

public class ActAsServiceImpl implements ActAsServiceIface
{
   public String sayHello() {
      try {
         ServiceIface proxy = setupService();
         return "ActAs " + proxy.sayHello();
      } catch (MalformedURLException e) {
         e.printStackTrace();
      }
      return null;
   }

   private  ServiceIface setupService()throws MalformedURLException {
      ServiceIface proxy = null;
      Bus bus = BusFactory.newInstance().createBus();

      try {
         BusFactory.setThreadDefaultBus(bus);

         final String serviceURL = "http://" + WSTrustAppUtils.getServerHost() + ":8080/jaxws-samples-wsse-policy-trust/SecurityService";
         final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy", "SecurityService");
         final URL wsdlURL = new URL(serviceURL + "?wsdl");
         Service service = Service.create(wsdlURL, serviceName);
         proxy = (ServiceIface) service.getPort(ServiceIface.class);

         Map&lt;String, Object&gt; ctx = ((BindingProvider) proxy).getRequestContext();
         ctx.put(SecurityConstants.CALLBACK_HANDLER, new ActAsCallbackHandler());

         ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource("actasKeystore.properties" ));
         ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myactaskey" );
         ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource("../../META-INF/clientKeystore.properties" ));
         ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myservicekey");

         STSClient stsClient = new STSClient(bus);
         Map&lt;String, Object&gt; props = stsClient.getProperties();
         props.put(SecurityConstants.USERNAME, "alice");
         props.put(SecurityConstants.ENCRYPT_USERNAME, "mystskey");
         props.put(SecurityConstants.STS_TOKEN_USERNAME, "myactaskey" );
         props.put(SecurityConstants.STS_TOKEN_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource("actasKeystore.properties" ));
         props.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO, "true");

         ctx.put(SecurityConstants.STS_CLIENT, stsClient);

      } finally {
         bus.shutdown(true);
      }

      return proxy;
   }

}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-ActAsCallbackHandler"/>5.13.5.1.4. ActAsCallbackHandler</h5></div></div></div><p>ActAsCallbackHandler is a callback handler for the WSS4J Crypto API.  It  is used to obtain the password for the private key in the keystore.   This class enables CXF to retrieve the password of the user name to use  for the message signature.  This class has been revised to return the  passwords for this service, myactaskey and the "actas" user,  alice.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.actas;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;
import java.util.HashMap;
import java.util.Map;

public class ActAsCallbackHandler extends PasswordCallbackHandler {

   public ActAsCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("myactaskey", "aspass");
      passwords.put("alice", "clarinet");
      return passwords;
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-UsernameTokenCallbackHandler"/>5.13.5.1.5. UsernameTokenCallbackHandler</h5></div></div></div><p>
              <span class="color:#000000">The ActAs and OnBeholdOf sub-elements of the RequestSecurityToken are  required to be defined as WSSE Username Tokens.  This utility generates  the properly formated element.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared;

import org.apache.cxf.helpers.DOMUtils;
import org.apache.cxf.message.Message;
import org.apache.cxf.ws.security.SecurityConstants;
import org.apache.cxf.ws.security.trust.delegation.DelegationCallback;
import org.apache.ws.security.WSConstants;
import org.apache.ws.security.message.token.UsernameToken;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.Element;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSSerializer;

import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import java.io.IOException;
import java.util.Map;

/**
* A utility to provide the 3 different input parameter types for jaxws property
* "ws-security.sts.token.act-as" and "ws-security.sts.token.on-behalf-of".
* This implementation obtains a username and password via the jaxws property
* "ws-security.username" and "ws-security.password" respectively, as defined
* in SecurityConstants.  It creates a wss UsernameToken to be used as the
* delegation token.
*/

public class UsernameTokenCallbackHandler implements CallbackHandler {

   public void handle(Callback[] callbacks)
      throws IOException, UnsupportedCallbackException {
      for (int i = 0; i &lt; callbacks.length; i++) {
         if (callbacks[i] instanceof DelegationCallback) {
            DelegationCallback callback = (DelegationCallback) callbacks[i];
            Message message = callback.getCurrentMessage();

            String username =
               (String)message.getContextualProperty(SecurityConstants.USERNAME);
            String password =
               (String)message.getContextualProperty(SecurityConstants.PASSWORD);
            if (username != null) {
               Node contentNode = message.getContent(Node.class);
               Document doc = null;
               if (contentNode != null) {
                  doc = contentNode.getOwnerDocument();
               } else {
                  doc = DOMUtils.createDocument();
               }
               UsernameToken usernameToken = createWSSEUsernameToken(username,password, doc);
               callback.setToken(usernameToken.getElement());
            }
         } else {
            throw new UnsupportedCallbackException(callbacks[i], "Unrecognized Callback");
         }
      }
   }

   /**
    * Provide UsernameToken as a string.
    * @param ctx
    * @return
    */
   public String getUsernameTokenString(Map&lt;String, Object&gt; ctx){
      Document doc = DOMUtils.createDocument();
      String result = null;
      String username = (String)ctx.get(SecurityConstants.USERNAME);
      String password = (String)ctx.get(SecurityConstants.PASSWORD);
      if (username != null) {
         UsernameToken usernameToken = createWSSEUsernameToken(username,password, doc);
         result = toString(usernameToken.getElement().getFirstChild().getParentNode());
      }
      return result;
   }

   /**
    *
    * @param username
    * @param password
    * @return
    */
   public String getUsernameTokenString(String username, String password){
      Document doc = DOMUtils.createDocument();
      String result = null;
      if (username != null) {
         UsernameToken usernameToken = createWSSEUsernameToken(username,password, doc);
         result = toString(usernameToken.getElement().getFirstChild().getParentNode());
      }
      return result;
   }

   /**
    * Provide UsernameToken as a DOM Element.
    * @param ctx
    * @return
    */
   public Element getUsernameTokenElement(Map&lt;String, Object&gt; ctx){
      Document doc = DOMUtils.createDocument();
      Element result = null;
      UsernameToken usernameToken = null;
         String username = (String)ctx.get(SecurityConstants.USERNAME);
      String password = (String)ctx.get(SecurityConstants.PASSWORD);
      if (username != null) {
         usernameToken = createWSSEUsernameToken(username,password, doc);
         result = usernameToken.getElement();
      }
      return result;
   }

   /**
    *
    * @param username
    * @param password
    * @return
    */
   public Element getUsernameTokenElement(String username, String password){
      Document doc = DOMUtils.createDocument();
      Element result = null;
      UsernameToken usernameToken = null;
      if (username != null) {
         usernameToken = createWSSEUsernameToken(username,password, doc);
         result = usernameToken.getElement();
      }
      return result;
   }

   private UsernameToken createWSSEUsernameToken(String username, String password, Document doc) {

      UsernameToken usernameToken = new UsernameToken(true, doc,
         (password == null)? null: WSConstants.PASSWORD_TEXT);
      usernameToken.setName(username);
      usernameToken.addWSUNamespace();
      usernameToken.addWSSENamespace();
      usernameToken.setID("id-" + username);

      if (password != null){
         usernameToken.setPassword(password);
      }

      return usernameToken;
   }


   private String toString(Node node) {
      String str = null;

      if (node != null) {
         DOMImplementationLS lsImpl = (DOMImplementationLS)
            node.getOwnerDocument().getImplementation().getFeature("LS", "3.0");
         LSSerializer serializer = lsImpl.createLSSerializer();
         serializer.getDomConfig().setParameter("xml-declaration", false); //by default its true, so set it to false to get String without xml-declaration
         str = serializer.writeToString(node);
      }
      return str;
   }

}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-Cryptopropertiesandkeystorefiles"/>5.13.5.1.6. Crypto properties and keystore files</h5></div></div></div><p>
              <span class="color:#000000">The ActAs service must provide its own  credentials.  The requisite properties file, actasKeystore.properties,  and keystore, actasstore.jks, were created.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=aapass
org.apache.ws.security.crypto.merlin.keystore.alias=myactaskey
org.apache.ws.security.crypto.merlin.keystore.file=actasstore.jks
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-MANIFEST.MF"/>5.13.5.1.7. MANIFEST.MF</h5></div></div></div><p>
              <span class="color:#000000">When deployed on WildFly this application requires  access to the JBossWS and Apache CXF APIs provided in modules  org.jboss.ws.cxf.jbossws-cxf-client.  The org.jboss.ws.cxf.sts module is also needed in handling the ActAs and OnBehalfOf  extensions.  The dependency statement directs the server to  provide them at deployment.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Manifest-Version: 1.0
Ant-Version: Apache Ant 1.8.2
Created-By: 1.7.0_25-b15 (Oracle Corporation)
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client, org.jboss.ws.cxf.sts
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-SecurityTokenService"/>5.13.5.2. Security Token Service</h4></div></div></div><p>This section examines the STS elements from the basic WS-Trust  scenario that have been changed to address the needs of the ActAs  example.  The components are.</p><div class="itemizedlist"><ul><li><p>STS's implementation class.</p></li><li><p>STSCallbackHandler class</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-STSImplementationclass"/>5.13.5.2.1. STS Implementation class</h5></div></div></div><p>
              The initial description of SampleSTS can be found
              <a href="sid-3866738.html#sid-78711224" title="5.13.5. ActAs WS-Trust Scenario">here</a>
              .
              
            </p><p>
              The  declaration of the set of allowed token recipients by address has  been extended to accept ActAs addresses and OnBehalfOf  addresses.  The addresses are specified as reg-ex  patterns.
              
            </p><p>The  TokenIssueOperation requires class, UsernameTokenValidator be provided  in order to validate the contents of the OnBehalfOf claims and class,  UsernameTokenDelegationHandler to be provided in order to process the  token delegation request of the ActAs on OnBehalfOf user.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
 package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.sts;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

import javax.xml.ws.WebServiceProvider;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.interceptor.InInterceptors;
import org.apache.cxf.sts.StaticSTSProperties;
import org.apache.cxf.sts.operation.TokenIssueOperation;
import org.apache.cxf.sts.operation.TokenValidateOperation;
import org.apache.cxf.sts.service.ServiceMBean;
import org.apache.cxf.sts.service.StaticService;
import org.apache.cxf.sts.token.delegation.UsernameTokenDelegationHandler;
import org.apache.cxf.sts.token.provider.SAMLTokenProvider;
import org.apache.cxf.sts.token.validator.SAMLTokenValidator;
import org.apache.cxf.sts.token.validator.UsernameTokenValidator;
import org.apache.cxf.ws.security.sts.provider.SecurityTokenServiceProvider;

@WebServiceProvider(serviceName = "SecurityTokenService",
      portName = "UT_Port",
      targetNamespace = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/",
      wsdlLocation = "WEB-INF/wsdl/ws-trust-1.4-service.wsdl")
//be sure to have dependency on org.apache.cxf module when on AS7, otherwise Apache CXF annotations are ignored
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "mystskey"),
      @EndpointProperty(key = "ws-security.signature.properties", value = "stsKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.sts.STSCallbackHandler"),
      @EndpointProperty(key = "ws-security.validate.token", value = "false") //to let the JAAS integration deal with validation through the interceptor below
})
@InInterceptors(interceptors = {"org.jboss.wsf.stack.cxf.security.authentication.SubjectCreatingPolicyInterceptor"})
public class SampleSTS extends SecurityTokenServiceProvider
{
   public SampleSTS() throws Exception
   {
      super();

      StaticSTSProperties props = new StaticSTSProperties();
      props.setSignatureCryptoProperties("stsKeystore.properties");
      props.setSignatureUsername("mystskey");
      props.setCallbackHandlerClass(STSCallbackHandler.class.getName());
      props.setIssuer("DoubleItSTSIssuer");

      List&lt;ServiceMBean&gt; services = new LinkedList&lt;ServiceMBean&gt;();
      StaticService service = new StaticService();
      service.setEndpoints(Arrays.asList(
         "http://localhost:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService",
         "http://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService",
         "http://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService",

         "http://localhost:(\\d)*/jaxws-samples-wsse-policy-trust-actas/ActAsService",
         "http://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-actas/ActAsService",
         "http://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-actas/ActAsService",

         "http://localhost:(\\d)*/jaxws-samples-wsse-policy-trust-onbehalfof/OnBehalfOfService",
         "http://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-onbehalfof/OnBehalfOfService",
         "http://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-onbehalfof/OnBehalfOfService"
      ));
      services.add(service);

      TokenIssueOperation issueOperation = new TokenIssueOperation();
      issueOperation.setServices(services);
      issueOperation.getTokenProviders().add(new SAMLTokenProvider());
      // required for OnBehalfOf
      issueOperation.getTokenValidators().add(new UsernameTokenValidator());
      // added for OnBehalfOf and ActAs
      issueOperation.getDelegationHandlers().add(new UsernameTokenDelegationHandler());
      issueOperation.setStsProperties(props);

      TokenValidateOperation validateOperation = new TokenValidateOperation();
      validateOperation.getTokenValidators().add(new SAMLTokenValidator());
      validateOperation.setStsProperties(props);

      this.setIssueOperation(issueOperation);
      this.setValidateOperation(validateOperation);
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-STSCallbackHandler"/>5.13.5.2.2. STSCallbackHandler</h5></div></div></div><p>The user, alice, and corresponding password was required to be added for the ActAs example.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.sts;

import java.util.HashMap;
import java.util.Map;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;

public class STSCallbackHandler extends PasswordCallbackHandler
{
   public STSCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("mystskey", "stskpass");
      passwords.put("alice", "clarinet");
      return passwords;
   }
}
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-Webservicerequester"/>5.13.5.3. Web service requester</h4></div></div></div><p>This section examines the ws-requester elements from the basic  WS-Trust  scenario that have been changed to address the needs of the ActAs  example.  The component is</p><div class="itemizedlist"><ul><li><p>ActAs  web service requester implementation class</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78711224_ActAsWS-TrustScenario-WebservicerequesterImplementation"/>5.13.5.3.1. Web service requester Implementation</h5></div></div></div><p>
              The ActAs ws-requester, the client, uses standard procedures for  creating a reference to the web service in the first four lines.  To  address the endpoint security requirements, the web service's "Request  Context" is configured via the BindingProvider. Information needed in  the message generation is provided through it.  The ActAs user, myactaskey, is declared in this section and  UsernameTokenCallbackHandler is used to provide the contents of the ActAs element to the STSClient.  In this example a  STSClient object is created and provided to the proxy's request context.  The alternative is to provide keys tagged with the ".it" suffix as was  done in
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/JBWS/WS-Trust+and+STS#WS-TrustandSTS-WebservicerequesterImplementation">the Basic Scenario client</a>
              . The use of ActAs is configured through the props map using the SecurityConstants.STS_TOKEN_ACT_AS key.  The alternative is to use the STSClient.setActAs method.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
 final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy", "ActAsService");
final URL wsdlURL = new URL(serviceURL + "?wsdl");
Service service = Service.create(wsdlURL, serviceName);
ActAsServiceIface proxy = (ActAsServiceIface) service.getPort(ActAsServiceIface.class);

Bus bus = BusFactory.newInstance().createBus();
try {
    BusFactory.setThreadDefaultBus(bus);

    Map&lt;String, Object&gt; ctx = proxy.getRequestContext();

    ctx.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
    ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myactaskey");
    ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myclientkey");

    // Generate the ActAs element contents and pass to the STSClient as a string
    UsernameTokenCallbackHandler ch = new UsernameTokenCallbackHandler();
    String str = ch.getUsernameTokenString("alice","clarinet");
    ctx.put(SecurityConstants.STS_TOKEN_ACT_AS, str);

    STSClient stsClient = new STSClient(bus);
    Map&lt;String, Object&gt; props = stsClient.getProperties();
    props.put(SecurityConstants.USERNAME, "bob");
    props.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
    props.put(SecurityConstants.ENCRYPT_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    props.put(SecurityConstants.ENCRYPT_USERNAME, "mystskey");
    props.put(SecurityConstants.STS_TOKEN_USERNAME, "myclientkey");
    props.put(SecurityConstants.STS_TOKEN_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    props.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO, "true");

    ctx.put(SecurityConstants.STS_CLIENT, stsClient);
} finally {
    bus.shutdown(true);
}
proxy.sayHello();
</pre></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-78906783"/>5.13.6. OnBehalfOf WS-Trust Scenario</h3></div></div></div><p>
          The OnBehalfOf feature is used in scenarios that use the proxy  pattern.  In such scenarios, the client cannot access the STS directly,  instead it communicates through a proxy gateway. The proxy gateway  authenticates the caller and puts information about the caller into the  OnBehalfOf element of the RequestSecurityToken (RST) sent to the real  STS for processing. The resulting token contains only claims related to  the client of the proxy, making the proxy completely transparent to the  receiver of the issued token.
          
        </p><p>
          OnBehalfOf  is nothing more than a new sub-element in the RST.  It provides  additional information about the original caller when a token is  negotiated with the STS.  The OnBehalfOf element usually takes the form  of a token with identity claims such as name, role, and authorization  code, for the client to access the service.
          
        </p><p>
          The OnBehalfOf scenario is an extension of
          <a href="sid-3866738.html#sid-78906783" title="5.13.6. OnBehalfOf WS-Trust Scenario">the basic WS-Trust scenario</a>
          .   In this example the OnBehalfOf service calls the ws-service on behalf  of a user.  There are only a couple of additions to the basic scenario's  code.  An OnBehalfOf web service provider and callback handler have  been added.  The OnBehalfOf web services' WSDL  imposes the same  security policies as the ws-provider. UsernameTokenCallbackHandler is a  utility shared with ActAs.  It generates the content for the OnBehalfOf  element.  And lastly there are code additions in the STS that both  OnBehalfOf and ActAs share in common.
          
        </p><p>
          Infor here [
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://coheigea.blogspot.it/2012/01/apache-cxf-251-sts-updates.html">Open Source Security: Apache CXF 2.5.1 STS updates</a>
          ]
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78906783_OnBehalfOfWS-TrustScenario-Webserviceprovider"/>5.13.6.1. Web service provider</h4></div></div></div><p>This section examines the web service elements from the basic  WS-Trust scenario that have been changed to address the needs of the  OnBehalfOf example.  The components are.</p><div class="itemizedlist"><ul><li><p>web service provider's WSDL</p></li><li><p>web service provider's Interface and Implementation classes.</p></li><li><p>OnBehalfOfCallbackHandler class</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906783_OnBehalfOfWS-TrustScenario-WebserviceproviderWSDL"/>5.13.6.1.1. Web service provider WSDL</h5></div></div></div><p>The OnBehalfOf web service provider's WSDL is a clone of the  ws-provider's WSDL.  The wsp:Policy section is the same. There are   changes to the service endpoint,  targetNamespace, portType, binding  name, and service.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy" name="OnBehalfOfService"
             xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
             xmlns:wsp="http://www.w3.org/ns/ws-policy"
             xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"
             xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
             xmlns:wsaws="http://www.w3.org/2005/08/addressing"
             xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"
             xmlns:t="http://docs.oasis-open.org/ws-sx/ws-trust/200512"&gt;
    &lt;types&gt;
        &lt;xsd:schema&gt;
            &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy"
                  schemaLocation="OnBehalfOfService_schema1.xsd"/&gt;
        &lt;/xsd:schema&gt;
    &lt;/types&gt;
    &lt;message name="sayHello"&gt;
        &lt;part name="parameters" element="tns:sayHello"/&gt;
    &lt;/message&gt;
    &lt;message name="sayHelloResponse"&gt;
        &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
    &lt;/message&gt;
    &lt;portType name="OnBehalfOfServiceIface"&gt;
        &lt;operation name="sayHello"&gt;
            &lt;input message="tns:sayHello"/&gt;
            &lt;output message="tns:sayHelloResponse"/&gt;
        &lt;/operation&gt;
    &lt;/portType&gt;
    &lt;binding name="OnBehalfOfServicePortBinding" type="tns:OnBehalfOfServiceIface"&gt;
        &lt;wsp:PolicyReference URI="#AsymmetricSAML2Policy" /&gt;
        &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
        &lt;operation name="sayHello"&gt;
            &lt;soap:operation soapAction=""/&gt;
            &lt;input&gt;
                &lt;soap:body use="literal"/&gt;
                &lt;wsp:PolicyReference URI="#Input_Policy" /&gt;
            &lt;/input&gt;
            &lt;output&gt;
                &lt;soap:body use="literal"/&gt;
                &lt;wsp:PolicyReference URI="#Output_Policy" /&gt;
            &lt;/output&gt;
        &lt;/operation&gt;
    &lt;/binding&gt;
    &lt;service name="OnBehalfOfService"&gt;
        &lt;port name="OnBehalfOfServicePort" binding="tns:OnBehalfOfServicePortBinding"&gt;
            &lt;soap:address location="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-onbehalfof/OnBehalfOfService"/&gt;
        &lt;/port&gt;
    &lt;/service&gt;
&lt;/definitions&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906783_OnBehalfOfWS-TrustScenario-WebServiceInterface"/>5.13.6.1.2. Web Service Interface</h5></div></div></div><p>The web service provider interface class, OnBehalfOfServiceIface, is a simple web service definition.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.onbehalfof;

import javax.jws.WebMethod;
import javax.jws.WebService;

@WebService
(
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy"
)
public interface OnBehalfOfServiceIface
{
   @WebMethod
   String sayHello();
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906783_OnBehalfOfWS-TrustScenario-WebServiceImplementation"/>5.13.6.1.3. Web Service Implementation</h5></div></div></div><p>The web service provider implementation class, OnBehalfOfServiceImpl, is a  simple POJO.  It uses the standard WebService annotation to define the  service endpoint  and two Apache WSS4J annotations, EndpointProperties  and EndpointProperty used for configuring the endpoint for the CXF  runtime.   The WSS4J configuration information provided is for WSS4J's  Crypto Merlin implementation.</p><p>OnBehalfOfServiceImpl  is calling the ServiceImpl acting on behalf of the user.  Method  setupService performs the requisite configuration setup.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.onbehalfof;

import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.ws.security.SecurityConstants;
import org.apache.cxf.ws.security.trust.STSClient;
import org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service.ServiceIface;
import org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared.WSTrustAppUtils;

import javax.jws.WebService;
import javax.xml.namespace.QName;
import javax.xml.ws.BindingProvider;
import javax.xml.ws.Service;
import java.net.*;
import java.util.Map;

@WebService
(
   portName = "OnBehalfOfServicePort",
   serviceName = "OnBehalfOfService",
   wsdlLocation = "WEB-INF/wsdl/OnBehalfOfService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.onbehalfof.OnBehalfOfServiceIface"
)

@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "myactaskey"),
      @EndpointProperty(key = "ws-security.signature.properties", value =  "actasKeystore.properties"),
      @EndpointProperty(key = "ws-security.encryption.properties", value = "actasKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.onbehalfof.OnBehalfOfCallbackHandler")
})

public class OnBehalfOfServiceImpl implements OnBehalfOfServiceIface
{
   public String sayHello() {
      try {

         ServiceIface proxy = setupService();
         return "OnBehalfOf " + proxy.sayHello();

      } catch (MalformedURLException e) {
         e.printStackTrace();
      }
      return null;
   }

   /**
    *
    * @return
    * @throws MalformedURLException
    */
   private  ServiceIface setupService()throws MalformedURLException {
      ServiceIface proxy = null;
      Bus bus = BusFactory.newInstance().createBus();

      try {
         BusFactory.setThreadDefaultBus(bus);

         final String serviceURL = "http://" + WSTrustAppUtils.getServerHost() + ":8080/jaxws-samples-wsse-policy-trust/SecurityService";
         final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy", "SecurityService");
         final URL wsdlURL = new URL(serviceURL + "?wsdl");
         Service service = Service.create(wsdlURL, serviceName);
         proxy = (ServiceIface) service.getPort(ServiceIface.class);

         Map&lt;String, Object&gt; ctx = ((BindingProvider) proxy).getRequestContext();
         ctx.put(SecurityConstants.CALLBACK_HANDLER, new OnBehalfOfCallbackHandler());

         ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource(
            "actasKeystore.properties" ));
         ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myactaskey" );
         ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource(
            "../../META-INF/clientKeystore.properties" ));
         ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myservicekey");

         STSClient stsClient = new STSClient(bus);
         Map&lt;String, Object&gt; props = stsClient.getProperties();
         props.put(SecurityConstants.USERNAME, "bob");
         props.put(SecurityConstants.ENCRYPT_USERNAME, "mystskey");
         props.put(SecurityConstants.STS_TOKEN_USERNAME, "myactaskey" );
         props.put(SecurityConstants.STS_TOKEN_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource(
            "actasKeystore.properties" ));
         props.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO, "true");

         ctx.put(SecurityConstants.STS_CLIENT, stsClient);

      } finally {
         bus.shutdown(true);
      }

      return proxy;
   }

}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906783_OnBehalfOfWS-TrustScenario-OnBehalfOfCallbackHandler"/>5.13.6.1.4. OnBehalfOfCallbackHandler</h5></div></div></div><p>OnBehalfOfCallbackHandler is a callback handler for the WSS4J Crypto API.   It is used to obtain the password for the private key in the keystore.   This class enables CXF to retrieve the password of the user name to use  for the message signature.  This class has been revised to return the passwords for this service, myactaskey and the "OnBehalfOf" user, alice.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
 package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.onbehalfof;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;
import java.util.HashMap;
import java.util.Map;

public class OnBehalfOfCallbackHandler extends PasswordCallbackHandler {

   public OnBehalfOfCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("myactaskey", "aspass");
      passwords.put("alice", "clarinet");
      passwords.put("bob", "trombone");
      return passwords;
   }

}
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78906783_OnBehalfOfWS-TrustScenario-Webservicerequester"/>5.13.6.2. Web service requester</h4></div></div></div><p>This section examines the ws-requester elements from the basic WS-Trust  scenario that have been changed to address the needs of the OnBehalfOf  example.  The component is</p><div class="itemizedlist"><ul><li><p>OnBehalfOf web service requester implementation class</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906783_OnBehalfOfWS-TrustScenario-WebservicerequesterImplementation"/>5.13.6.2.1. Web service requester Implementation</h5></div></div></div><p>
              The OnBehalfOf ws-requester, the client, uses standard procedures for creating a reference to the web service in the first four lines.  To address the endpoint security requirements, the web service's "Request Context" is configured via the BindingProvider. Information needed in the message generation is provided through it.  The OnBehalfOf user, alice, is declared in this section and the callbackHandler, UsernameTokenCallbackHandler is provided to the STSClient for generation of the contents for the OnBehalfOf message element.  In this example a STSClient object is created and provided to the proxy's request context. The alternative is to provide keys tagged with the ".it" suffix as was done in
              <a href="sid-3866738.html#sid-78906783_OnBehalfOfWS-TrustScenario-WebservicerequesterImplementation" title="5.13.6.2.1. Web service requester Implementation">the Basic Scenario client</a>
              .  The use of OnBehalfOf is configured by the method call stsClient.setOnBehalfOf.  The alternative is to use the key SecurityConstants.STS_TOKEN_ON_BEHALF_OF and a value in the props map.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy", "OnBehalfOfService");
final URL wsdlURL = new URL(serviceURL + "?wsdl");
Service service = Service.create(wsdlURL, serviceName);
OnBehalfOfServiceIface proxy = (OnBehalfOfServiceIface) service.getPort(OnBehalfOfServiceIface.class);


Bus bus = BusFactory.newInstance().createBus();
try {

    BusFactory.setThreadDefaultBus(bus);

    Map&lt;String, Object&gt; ctx = proxy.getRequestContext();

    ctx.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
    ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myactaskey");
    ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myclientkey");

    // user and password OnBehalfOf user
    // UsernameTokenCallbackHandler will extract this information when called
    ctx.put(SecurityConstants.USERNAME,"alice");
    ctx.put(SecurityConstants.PASSWORD, "clarinet");

    STSClient stsClient = new STSClient(bus);

    // Providing the STSClient the mechanism to create the claims contents for OnBehalfOf
    stsClient.setOnBehalfOf(new UsernameTokenCallbackHandler());

    Map&lt;String, Object&gt; props = stsClient.getProperties();
    props.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
    props.put(SecurityConstants.ENCRYPT_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    props.put(SecurityConstants.ENCRYPT_USERNAME, "mystskey");
    props.put(SecurityConstants.STS_TOKEN_USERNAME, "myclientkey");
    props.put(SecurityConstants.STS_TOKEN_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    props.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO, "true");

    ctx.put(SecurityConstants.STS_CLIENT, stsClient);

} finally {
    bus.shutdown(true);
}
proxy.sayHello();
</pre></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-78906786"/>5.13.7. SAML Bearer Assertion Scenario</h3></div></div></div><p>
          WS-Trust deals with managing software security tokens.  A SAML  assertion is a type of security token.  In the SAML Bearer scenario, the  service provider automatically trusts that the incoming SOAP request  came from the subject defined in the SAML token after the service  verifies the tokens signature.
          
        </p><p>Implementation of this scenario has the following requirements.</p><div class="itemizedlist"><ul><li><p>SAML  tokens with a Bearer subject confirmation method must be protected so  the token can not be snooped.  In most cases, a bearer token combined  with HTTPS is sufficient to prevent "a man in the middle" getting  possession of the token.  This means a security policy that uses a  sp:TransportBinding and sp:HttpsToken.</p></li><li><p>
              A bearer token has no  encryption or signing keys associated with it, therefore a  sp:IssuedToken of bearer keyType should be used with a  sp:SupportingToken or a sp:SignedSupportingTokens.
              
            </p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-WebserviceProvider"/>5.13.7.1. Web service Provider</h4></div></div></div><p>This section examines the web service elements for the SAML Bearer scenario.  The components are</p><div class="itemizedlist"><ul><li><p>Bearer web service provider's WSDL</p></li><li><p>SSL configuration</p></li><li><p>Bearer web service provider's Interface and Implementation classes.</p></li><li><p>Crypto properties and keystore files</p></li><li><p>MANIFEST.MF</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-WebserviceproviderWSDL"/>5.13.7.1.1. Web service provider WSDL</h5></div></div></div><p>The web service provider is a contract-first endpoint.  All the WS-trust  and security policies for it are declared in WSDL, BearerService.wsdl.   For this scenario a ws-requester is required to present a SAML 2.0  Bearer token issued from a designed STS. The address of the STS is  provided in the WSDL.  HTTPS, a TransportBinding and HttpsToken policy  are used to protect the SOAP body of messages that pass back and forth  between ws-requester and ws-provider.  A detailed explanation of the  security settings are provided in the comments in the listing below.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy"
             name="BearerService"
             xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
             xmlns:wsp="http://www.w3.org/ns/ws-policy"
             xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"
             xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
             xmlns:wsaws="http://www.w3.org/2005/08/addressing"
             xmlns:wsx="http://schemas.xmlsoap.org/ws/2004/09/mex"
             xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"
             xmlns:t="http://docs.oasis-open.org/ws-sx/ws-trust/200512"&gt;

  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy"
                  schemaLocation="BearerService_schema1.xsd"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="sayHello"&gt;
    &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;
  &lt;message name="sayHelloResponse"&gt;
    &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;
  &lt;portType name="BearerIface"&gt;
    &lt;operation name="sayHello"&gt;
      &lt;input message="tns:sayHello"/&gt;
      &lt;output message="tns:sayHelloResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;

&lt;!--
        The wsp:PolicyReference binds the security requirments on all the endpoints.
        The wsp:Policy wsu:Id="#TransportSAML2BearerPolicy" element is defined later in this file.
--&gt;
  &lt;binding name="BearerServicePortBinding" type="tns:BearerIface"&gt;
    &lt;wsp:PolicyReference URI="#TransportSAML2BearerPolicy" /&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="sayHello"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;

&lt;!--
  The soap:address has been defined to use JBoss's https port, 8443.  This is
  set in conjunction with the sp:TransportBinding policy for https.
--&gt;
  &lt;service name="BearerService"&gt;
    &lt;port name="BearerServicePort" binding="tns:BearerServicePortBinding"&gt;
      &lt;soap:address location="https://@jboss.bind.address@:8443/jaxws-samples-wsse-policy-trust-bearer/BearerService"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;


  &lt;wsp:Policy wsu:Id="TransportSAML2BearerPolicy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
  &lt;!--
        The wsam:Addressing element, indicates that the endpoints of this
        web service MUST conform to the WS-Addressing specification.  The
        attribute wsp:Optional="false" enforces this assertion.
  --&gt;
        &lt;wsam:Addressing wsp:Optional="false"&gt;
          &lt;wsp:Policy /&gt;
        &lt;/wsam:Addressing&gt;

&lt;!--
  The sp:TransportBinding element indicates that security is provided by the
  message exchange transport medium, https.  WS-Security policy specification
  defines the sp:HttpsToken for use in exchanging messages transmitted over HTTPS.
--&gt;
        &lt;sp:TransportBinding
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:TransportToken&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:HttpsToken&gt;
                  &lt;wsp:Policy/&gt;
                &lt;/sp:HttpsToken&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:TransportToken&gt;
&lt;!--
     The sp:AlgorithmSuite element, requires the TripleDes algorithm suite
     be used in performing cryptographic operations.
--&gt;
            &lt;sp:AlgorithmSuite&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:TripleDes /&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:AlgorithmSuite&gt;
&lt;!--
     The sp:Layout element,  indicates the layout rules to apply when adding
     items to the security header.  The sp:Lax sub-element indicates items
     are added to the security header in any order that conforms to
     WSS: SOAP Message Security.
--&gt;
            &lt;sp:Layout&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Lax /&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:Layout&gt;
            &lt;sp:IncludeTimestamp /&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:TransportBinding&gt;

&lt;!--
  The sp:SignedSupportingTokens element causes the supporting tokens
  to be signed using the primary token that is used to sign the message.
--&gt;
        &lt;sp:SignedSupportingTokens
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
&lt;!--
  The sp:IssuedToken element asserts that a SAML 2.0 security token of type
  Bearer is expected from the STS.  The
  sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
  attribute instructs the runtime to include the initiator's public key
  with every message sent to the recipient.

  The sp:RequestSecurityTokenTemplate element directs that all of the
  children of this element will be copied directly into the body of the
  RequestSecurityToken (RST) message that is sent to the STS when the
  initiator asks the STS to issue a token.
--&gt;
            &lt;sp:IssuedToken
              sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
              &lt;sp:RequestSecurityTokenTemplate&gt;
                &lt;t:TokenType&gt;http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0&lt;/t:TokenType&gt;
                &lt;t:KeyType&gt;http://docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer&lt;/t:KeyType&gt;
              &lt;/sp:RequestSecurityTokenTemplate&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:RequireInternalReference /&gt;
              &lt;/wsp:Policy&gt;
&lt;!--
  The sp:Issuer element defines the STS's address and endpoint information
  This information is used by the STSClient.
--&gt;
              &lt;sp:Issuer&gt;
                &lt;wsaws:Address&gt;http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts-bearer/SecurityTokenService&lt;/wsaws:Address&gt;
                &lt;wsaws:Metadata
                  xmlns:wsdli="http://www.w3.org/2006/01/wsdl-instance"
                  wsdli:wsdlLocation="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts-bearer/SecurityTokenService?wsdl"&gt;
                  &lt;wsaw:ServiceName
                    xmlns:wsaw="http://www.w3.org/2006/05/addressing/wsdl"
                    xmlns:stsns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
                    EndpointName="UT_Port"&gt;stsns:SecurityTokenService&lt;/wsaw:ServiceName&gt;
                &lt;/wsaws:Metadata&gt;
              &lt;/sp:Issuer&gt;

            &lt;/sp:IssuedToken&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SignedSupportingTokens&gt;
&lt;!--
    The sp:Wss11 element declares WSS: SOAP Message Security 1.1 options
    to be supported by the STS.  These particular elements generally refer
    to how keys are referenced within the SOAP envelope.  These are normally
    handled by CXF.
--&gt;
        &lt;sp:Wss11&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportRefIssuerSerial /&gt;
            &lt;sp:MustSupportRefThumbprint /&gt;
            &lt;sp:MustSupportRefEncryptedKey /&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Wss11&gt;
&lt;!--
    The sp:Trust13 element declares controls for WS-Trust 1.3 options.
    They are policy assertions related to exchanges specifically with
    client and server challenges and entropy behaviors.  Again these are
    normally handled by CXF.
--&gt;
        &lt;sp:Trust13&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportIssuedTokens /&gt;
            &lt;sp:RequireClientEntropy /&gt;
            &lt;sp:RequireServerEntropy /&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Trust13&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

&lt;/definitions&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-SSLconfiguration"/>5.13.7.1.2. SSL configuration</h5></div></div></div><p>This web service is using https, therefore the JBoss server must be configured to provide SSL support in the Web subsystem.  There are 2 components to SSL configuration.</p><div class="itemizedlist"><ul><li><p>create a certificate keystore</p></li><li><p>declare an SSL connector in the Web subsystem of the JBoss server configuration file.</p></li></ul></div><p>
              Follow the directions in the, "
              <span class="italics">Using the pure Java implementation supplied by JSSE</span>
              " section in the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/WFLY8/SSL+setup+guide">SSL Setup Guide</a>
              .
            </p><p>Here is an example of an SSL connector declaration.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;subsystem xmlns="urn:jboss:domain:web:1.4" default-virtual-server="default-host" native="false"&gt;
  .....
  &lt;connector name="jbws-https-connector" protocol="HTTP/1.1" scheme="https" socket-binding="https" secure="true" enabled="true"&gt;
    &lt;ssl key-alias="tomcat" password="changeit" certificate-key-file="/myJbossHome/security/test.keystore" verify-client="false"/&gt;
  &lt;/connector&gt;
  ...
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-WebserviceInterface"/>5.13.7.1.3. Web service Interface</h5></div></div></div><p>The web service provider interface class, BearerIface, is a simple straight forward web service definition.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.bearer;

import javax.jws.WebMethod;
import javax.jws.WebService;

@WebService
(
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy"
)
public interface BearerIface
{
   @WebMethod
   String sayHello();
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-WebserviceImplementation"/>5.13.7.1.4. Web service Implementation</h5></div></div></div><p>
              The web service provider implementation class, BearerImpl, is a  simple POJO.  It uses the standard WebService annotation to define the  service endpoint. In addition there are two Apache CXF annotations,  EndpointProperties and EndpointProperty used for configuring the  endpoint for the CXF runtime. These annotations come from the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://ws.apache.org/wss4j/">Apache WSS4J project</a>
              ,  which provides a Java implementation of the primary WS-Security  standards for Web Services. These annotations are programmatically  adding properties to the endpoint. With plain Apache CXF, these properties are often set via the  &lt;jaxws:properties&gt; element on the   &lt;jaxws:endpoint&gt; element  in the Spring config; these   annotations allow the properties to be  configured in the code.
            </p><p>WSS4J  uses the Crypto interface to get keys and certificates for signature  creation/verification, as is asserted by the WSDL for this service.  The  WSS4J configuration information being provided by BearerImpl is for  Crypto's Merlin implementation.  More information will be provided about  this in the keystore section.</p><p>Because the web  service provider automatically trusts that the incoming SOAP request  came from the subject defined in the SAML token there is no need for a  Crypto callbackHandler class or a signature username, unlike in prior  examples, however in order to verify the message signature, the Java  properties file that contains the (Merlin) crypto configuration  information is still required.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.bearer;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;

import javax.jws.WebService;

@WebService
(
   portName = "BearerServicePort",
   serviceName = "BearerService",
   wsdlLocation = "WEB-INF/wsdl/BearerService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.bearer.BearerIface"
)
@EndpointProperties(value = {
   @EndpointProperty(key = "ws-security.signature.properties", value = "serviceKeystore.properties")
})
public class BearerImpl implements BearerIface
{
   public String sayHello()
   {
      return "Bearer WS-Trust Hello World!";
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-Cryptopropertiesandkeystorefiles"/>5.13.7.1.5. Crypto properties and keystore files</h5></div></div></div><p>WSS4J's Crypto implementation is loaded and configured via a Java   properties file that contains Crypto configuration data.  The file   contains implementation-specific properties such as a keystore location,   password, default alias and the like.  This application is using the   Merlin implementation. File serviceKeystore.properties contains this   information.</p><p>
              File  servicestore.jks, is a Java KeyStore (JKS) repository.  It  contains  self signed certificates for myservicekey and mystskey.
              <span class="italics">Self signed certificates are not appropriate for production use.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=sspass
org.apache.ws.security.crypto.merlin.keystore.alias=myservicekey
org.apache.ws.security.crypto.merlin.keystore.file=servicestore.jks
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-MANIFEST.MF"/>5.13.7.1.6. MANIFEST.MF</h5></div></div></div><p>When deployed on WildFly this application requires   access to the JBossWs and CXF APIs provided in module   org.jboss.ws.cxf.jbossws-cxf-client.  The dependency statement directs  the server to provide them at deployment.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Manifest-Version: 1.0  
Ant-Version: Apache Ant 1.8.2  
Created-By: 1.7.0_25-b15 (Oracle Corporation)  
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-BearerSecurityTokenService"/>5.13.7.2. Bearer Security Token Service</h4></div></div></div><p>This section examines the crucial elements in providing the Security  Token Service functionality for providing a SAML Bearer token.  The  components that will be discussed are.</p><div class="itemizedlist"><ul><li><p>Security Domain</p></li><li><p>STS's WSDL</p></li><li><p>STS's implementation class</p></li><li><p>STSBearerCallbackHandler</p></li><li><p>Crypto properties and keystore files</p></li><li><p>
                MANIFEST.MF
                
              </p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-SecurityDomain"/>5.13.7.2.1. Security Domain</h5></div></div></div><p>The STS requires a JBoss security domain be configured.  The  jboss-web.xml descriptor declares a named security  domain,"JBossWS-trust-sts" to be used by this service for  authentication.  This security domain requires two properties files and  the addition of a security-domain declaration in the JBoss server  configuration file.</p><p>
              For this scenario the domain needs to contain user
              <span class="italics">alice</span>
              , password
              <span class="italics">clarinet</span>
              , and role
              <span class="italics">friend</span>
              .  See the listings below for jbossws-users.properties and  jbossws-roles.properties.  In addition the following XML must be added  to the JBoss security subsystem in the server configuration file.   Replace "
              <span class="strong"><strong>SOME_PATH</strong></span>
              " with appropriate information.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;security-domain name="JBossWS-trust-sts"&gt;
  &lt;authentication&gt;
    &lt;login-module code="UsersRoles" flag="required"&gt;
      &lt;module-option name="usersProperties" value="/SOME_PATH/jbossws-users.properties"/&gt;
      &lt;module-option name="unauthenticatedIdentity" value="anonymous"/&gt;
      &lt;module-option name="rolesProperties" value="/SOME_PATH/jbossws-roles.properties"/&gt;
    &lt;/login-module&gt;
  &lt;/authentication&gt;
&lt;/security-domain&gt;
</pre></div><p>jboss-web.xml</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;  
&lt;!DOCTYPE jboss-web PUBLIC "-//JBoss//DTD Web Application 2.4//EN" "&gt;  
&lt;jboss-web&gt;  
  &lt;security-domain&gt;java:/jaas/JBossWS-trust-sts&lt;/security-domain&gt;  
&lt;/jboss-web&gt;
</pre></div><p>jbossws-users.properties</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
# A sample users.properties file for use with the UsersRolesLoginModule  
alice=clarinet
</pre></div><p>jbossws-roles.properties</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
# A sample roles.properties file for use with the UsersRolesLoginModule  
alice=friend
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-STS%27sWSDL"/>5.13.7.2.2. STS's WSDL</h5></div></div></div><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;wsdl:definitions
  targetNamespace="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:tns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:wstrust="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:wsap10="http://www.w3.org/2006/05/addressing/wsdl"
  xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
  xmlns:wsp="http://www.w3.org/ns/ws-policy"
  xmlns:wst="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"&gt;

  &lt;wsdl:types&gt;
    &lt;xs:schema elementFormDefault="qualified"
               targetNamespace='http://docs.oasis-open.org/ws-sx/ws-trust/200512'&gt;

      &lt;xs:element name='RequestSecurityToken'
                  type='wst:AbstractRequestSecurityTokenType'/&gt;
      &lt;xs:element name='RequestSecurityTokenResponse'
                  type='wst:AbstractRequestSecurityTokenType'/&gt;

      &lt;xs:complexType name='AbstractRequestSecurityTokenType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:any namespace='##any' processContents='lax' minOccurs='0'
                  maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name='Context' type='xs:anyURI' use='optional'/&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax'/&gt;
      &lt;/xs:complexType&gt;
      &lt;xs:element name='RequestSecurityTokenCollection'
                  type='wst:RequestSecurityTokenCollectionType'/&gt;
      &lt;xs:complexType name='RequestSecurityTokenCollectionType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element name='RequestSecurityToken'
                      type='wst:AbstractRequestSecurityTokenType' minOccurs='2'
                      maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name='RequestSecurityTokenResponseCollection'
                  type='wst:RequestSecurityTokenResponseCollectionType'/&gt;
      &lt;xs:complexType name='RequestSecurityTokenResponseCollectionType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref='wst:RequestSecurityTokenResponse' minOccurs='1'
                      maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax'/&gt;
      &lt;/xs:complexType&gt;

    &lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;

  &lt;!-- WS-Trust defines the following GEDs --&gt;
  &lt;wsdl:message name="RequestSecurityTokenMsg"&gt;
    &lt;wsdl:part name="request" element="wst:RequestSecurityToken"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseMsg"&gt;
    &lt;wsdl:part name="response"
               element="wst:RequestSecurityTokenResponse"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenCollectionMsg"&gt;
    &lt;wsdl:part name="requestCollection"
               element="wst:RequestSecurityTokenCollection"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseCollectionMsg"&gt;
    &lt;wsdl:part name="responseCollection"
               element="wst:RequestSecurityTokenResponseCollection"/&gt;
  &lt;/wsdl:message&gt;

  &lt;!-- This portType an example of a Requestor (or other) endpoint that
  Accepts SOAP-based challenges from a Security Token Service --&gt;
  &lt;wsdl:portType name="WSSecurityRequestor"&gt;
    &lt;wsdl:operation name="Challenge"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!-- This portType is an example of an STS supporting full protocol --&gt;
  &lt;!--
      The wsdl:portType and data types are XML elements defined by the
      WS_Trust specification.  The wsdl:portType defines the endpoints
      supported in the STS implementation.  This WSDL defines all operations
      that an STS implementation can support.
  --&gt;
  &lt;wsdl:portType name="STS"&gt;
    &lt;wsdl:operation name="Cancel"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/CancelFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Issue"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTRC/IssueFinal"
        message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Renew"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/RenewFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Validate"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/ValidateFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="KeyExchangeToken"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KET"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/KETFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="RequestCollection"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenCollectionMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!-- This portType is an example of an endpoint that accepts
  Unsolicited RequestSecurityTokenResponse messages --&gt;
  &lt;wsdl:portType name="SecurityTokenResponseService"&gt;
    &lt;wsdl:operation name="RequestSecurityTokenResponse"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!--
      The wsp:PolicyReference binds the security requirments on all the STS endpoints.
      The wsp:Policy wsu:Id="UT_policy" element is later in this file.
  --&gt;
  &lt;wsdl:binding name="UT_Binding" type="wstrust:STS"&gt;
    &lt;wsp:PolicyReference URI="#UT_policy"/&gt;
    &lt;soap:binding style="document"
                  transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="Issue"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue"/&gt;
      &lt;wsdl:input&gt;
        &lt;wsp:PolicyReference
          URI="#Input_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;wsp:PolicyReference
          URI="#Output_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Validate"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate"/&gt;
      &lt;wsdl:input&gt;
        &lt;wsp:PolicyReference
          URI="#Input_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;wsp:PolicyReference
          URI="#Output_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Cancel"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Renew"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="KeyExchangeToken"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KeyExchangeToken"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="RequestCollection"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/RequestCollection"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;

  &lt;wsdl:service name="SecurityTokenService"&gt;
    &lt;wsdl:port name="UT_Port" binding="tns:UT_Binding"&gt;
      &lt;soap:address location="http://localhost:8080/SecurityTokenService/UT"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;


  &lt;wsp:Policy wsu:Id="UT_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;!--
            The sp:UsingAddressing element, indicates that the endpoints of this
            web service conforms to the WS-Addressing specification.  More detail
            can be found here: [http://www.w3.org/TR/2006/CR-ws-addr-wsdl-20060529]
        --&gt;
        &lt;wsap10:UsingAddressing/&gt;
        &lt;!--
            The sp:SymmetricBinding element indicates that security is provided
            at the SOAP layer and any initiator must authenticate itself by providing
            WSS UsernameToken credentials.
        --&gt;
        &lt;sp:SymmetricBinding
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;!--
                In a symmetric binding, the keys used for encrypting and signing in both
                directions are derived from a single key, the one specified by the
                sp:ProtectionToken element.  The sp:X509Token sub-element declares this
                key to be a X.509 certificate and the
                IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"
                attribute adds the requirement that the token MUST NOT be included in
                any messages sent between the initiator and the recipient; rather, an
                external reference to the token should be used.  Lastly the WssX509V3Token10
                sub-element declares that the Username token presented by the initiator
                should be compliant with Web Services Security UsernameToken Profile
                1.0 specification. [ http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0.pdf ]
            --&gt;
            &lt;sp:ProtectionToken&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:X509Token
                  sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
                  &lt;wsp:Policy&gt;
                    &lt;sp:RequireDerivedKeys/&gt;
                    &lt;sp:RequireThumbprintReference/&gt;
                    &lt;sp:WssX509V3Token10/&gt;
                  &lt;/wsp:Policy&gt;
                &lt;/sp:X509Token&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:ProtectionToken&gt;
            &lt;!--
                The sp:AlgorithmSuite element, requires the Basic256 algorithm suite
                be used in performing cryptographic operations.
            --&gt;
            &lt;sp:AlgorithmSuite&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Basic256/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:AlgorithmSuite&gt;
            &lt;!--
                The sp:Layout element,  indicates the layout rules to apply when adding
                items to the security header.  The sp:Lax sub-element indicates items
                are added to the security header in any order that conforms to
                WSS: SOAP Message Security.
            --&gt;
            &lt;sp:Layout&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Lax/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:Layout&gt;
            &lt;sp:IncludeTimestamp/&gt;
            &lt;sp:EncryptSignature/&gt;
            &lt;sp:OnlySignEntireHeadersAndBody/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SymmetricBinding&gt;

        &lt;!--
            The sp:SignedSupportingTokens element declares that the security header
            of messages must contain a sp:UsernameToken and the token must be signed.
            The attribute IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"
            on sp:UsernameToken indicates that the token MUST be included in all
            messages sent from initiator to the recipient and that the token MUST
            NOT be included in messages sent from the recipient to the initiator.
            And finally the element sp:WssUsernameToken10 is a policy assertion
            indicating the Username token should be as defined in  Web Services
            Security UsernameToken Profile 1.0
        --&gt;
        &lt;sp:SignedSupportingTokens
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:UsernameToken
              sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:WssUsernameToken10/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:UsernameToken&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SignedSupportingTokens&gt;
        &lt;!--
            The sp:Wss11 element declares WSS: SOAP Message Security 1.1 options
            to be supported by the STS.  These particular elements generally refer
            to how keys are referenced within the SOAP envelope.  These are normally
            handled by CXF.
        --&gt;
        &lt;sp:Wss11
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportRefKeyIdentifier/&gt;
            &lt;sp:MustSupportRefIssuerSerial/&gt;
            &lt;sp:MustSupportRefThumbprint/&gt;
            &lt;sp:MustSupportRefEncryptedKey/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Wss11&gt;
        &lt;!--
            The sp:Trust13 element declares controls for WS-Trust 1.3 options.
            They are policy assertions related to exchanges specifically with
            client and server challenges and entropy behaviors.  Again these are
            normally handled by CXF.
        --&gt;
        &lt;sp:Trust13
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportIssuedTokens/&gt;
            &lt;sp:RequireClientEntropy/&gt;
            &lt;sp:RequireServerEntropy/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Trust13&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

  &lt;wsp:Policy wsu:Id="Input_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;sp:SignedParts
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;sp:Body/&gt;
          &lt;sp:Header Name="To"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="From"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="FaultTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="ReplyTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="MessageID"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="RelatesTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="Action"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
        &lt;/sp:SignedParts&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

  &lt;wsp:Policy wsu:Id="Output_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;sp:SignedParts
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;sp:Body/&gt;
          &lt;sp:Header Name="To"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="From"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="FaultTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="ReplyTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="MessageID"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="RelatesTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="Action"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
        &lt;/sp:SignedParts&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

&lt;/wsdl:definitions&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-STS%27simplementationclass"/>5.13.7.2.3. STS's implementation class</h5></div></div></div><p>
              The Apache CXF's STS, SecurityTokenServiceProvider, is a web service   provider that is compliant with the protocols and functionality defined   by the WS-Trust specification.  It has a modular architecture. Many of   its components are configurable or replaceable and there are many   optional features that are enabled by implementing and configuring   plug-ins.  Users can customize their own STS by extending from   SecurityTokenServiceProvider and overriding the default settings.    Extensive information about the CXF's STS configurable and pluggable   components can be found
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://coheigea.blogspot.com/2011/11/apache-cxf-sts-documentation-part-viii_10.html">here</a>
              .
            </p><p>This STS implementation class, SampleSTSBearer, is a POJO that extends from   SecurityTokenServiceProvider.  Note that the class is defined with a   WebServiceProvider annotation and not a WebService  annotation.  This  annotation defines the service as a Provider-based  endpoint, meaning it  supports a more messaging-oriented approach to Web  services.  In  particular, it signals that the exchanged messages will be  XML  documents of some type.  SecurityTokenServiceProvider is an   implementation of the javax.xml.ws.Provider interface.  In comparison   the WebService annotation defines a (service endpoint interface)   SEI-based endpoint which supports message exchange via SOAP envelopes.</p><p>As was  done in the BearerImpl class, the WSS4J annotations  EndpointProperties  and EndpointProperty are providing endpoint  configuration  for the CXF runtime.  The first EndpointProperty statement in the listing is declaring the  user's name to use for the message  signature.  It is used as the alias  name in the keystore to get the  user's cert and private key for  signature.  The next two EndpointProperty statements declares the Java  properties file that contains the (Merlin)  crypto configuration  information.  In this case both for signing and  encrypting the  messages.  WSS4J reads this file and extra required  information for  message handling.  The last EndpointProperty statement declares the STSBearerCallbackHandler implementation class.  It is used  to obtain the  user's password for the certificates in the keystore  file.</p><p>In this implementation we are customizing the operations of token issuance, token validation and their static properties.</p><p>StaticSTSProperties is used to set select properties for configuring  resources  in the STS.  You may think this is a duplication of the  settings made  with the WSS4J annotations.  The values are the same but  the underlaying  structures being set are different, thus this  information must be  declared in both places.</p><p>The  setIssuer setting is important because it uniquely identifies   the issuing STS.  The issuer string is embedded in issued tokens and,   when validating tokens, the STS checks the issuer string value.   Consequently, it is important to use the issuer string in a consistent   way, so that the STS can recognize the tokens that it has issued.</p><p>The setEndpoints call allows the declaration of a set  of allowed  token recipients by address.  The addresses are specified  as reg-ex  patterns.</p><p>TokenIssueOperation has a modular  structure.   This allows custom behaviors to be injected into the  processing of  messages.  In this case we are overriding the   SecurityTokenServiceProvider's default behavior and performing SAML   token processing.  CXF provides an implementation of a   SAMLTokenProvider which we are using rather than   writing our own.</p><p>
              Learn more about the SAMLTokenProvider
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://coheigea.blogspot.it/2011/10/apache-cxf-sts-documentation-part-iv.html">here</a>
              .
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsbearer;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.sts.StaticSTSProperties;
import org.apache.cxf.sts.operation.TokenIssueOperation;
import org.apache.cxf.sts.service.ServiceMBean;
import org.apache.cxf.sts.service.StaticService;
import org.apache.cxf.sts.token.provider.SAMLTokenProvider;
import org.apache.cxf.ws.security.sts.provider.SecurityTokenServiceProvider;

import javax.xml.ws.WebServiceProvider;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

@WebServiceProvider(serviceName = "SecurityTokenService",
      portName = "UT_Port",
      targetNamespace = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/",
      wsdlLocation = "WEB-INF/wsdl/bearer-ws-trust-1.4-service.wsdl")
//be sure to have dependency on org.apache.cxf module when on AS7, otherwise Apache CXF annotations are ignored
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "mystskey"),
      @EndpointProperty(key = "ws-security.signature.properties", value = "stsKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsbearer.STSBearerCallbackHandler")
})
public class SampleSTSBearer extends SecurityTokenServiceProvider
{

   public SampleSTSBearer() throws Exception
   {
      super();

      StaticSTSProperties props = new StaticSTSProperties();
      props.setSignatureCryptoProperties("stsKeystore.properties");
      props.setSignatureUsername("mystskey");
      props.setCallbackHandlerClass(STSBearerCallbackHandler.class.getName());
      props.setEncryptionCryptoProperties("stsKeystore.properties");
      props.setEncryptionUsername("myservicekey");
      props.setIssuer("DoubleItSTSIssuer");

      List&lt;ServiceMBean&gt; services = new LinkedList&lt;ServiceMBean&gt;();
      StaticService service = new StaticService();
      service.setEndpoints(Arrays.asList(
         "https://localhost:(\\d)*/jaxws-samples-wsse-policy-trust-bearer/BearerService",
         "https://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-bearer/BearerService",
         "https://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-bearer/BearerService"
      ));
      services.add(service);

      TokenIssueOperation issueOperation = new TokenIssueOperation();
      issueOperation.getTokenProviders().add(new SAMLTokenProvider());
      issueOperation.setServices(services);
      issueOperation.setStsProperties(props);
      this.setIssueOperation(issueOperation);
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-STSBearerCallbackHandler"/>5.13.7.2.4. STSBearerCallbackHandler</h5></div></div></div><p>STSBearerCallbackHandler is a callback handler for the WSS4J Crypto API.  It   is used to obtain the password for the private key in the keystore.    This class enables CXF to retrieve the password of the user name to use   for the message signature.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsbearer;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;

import java.util.HashMap;
import java.util.Map;

public class STSBearerCallbackHandler extends PasswordCallbackHandler
{
   public STSBearerCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("mystskey", "stskpass");
      passwords.put("alice", "clarinet");
      return passwords;
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-Cryptopropertiesandkeystorefilesx"/>5.13.7.2.5. Crypto properties and keystore files</h5></div></div></div><p>WSS4J's Crypto implementation is loaded and configured via a Java   properties file that contains Crypto configuration data.  The file   contains implementation-specific properties such as a keystore location,   password, default alias and the like.  This application is using the   Merlin implementation. File stsKeystore.properties contains this   information.</p><p>
              File  servicestore.jks, is a Java KeyStore (JKS) repository.  It  contains  self signed certificates for myservicekey and mystskey.
              <span class="italics">Self signed certificates are not appropriate for production use.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin  
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=stsspass
org.apache.ws.security.crypto.merlin.keystore.file=stsstore.jks
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-MANIFEST.MFx"/>5.13.7.2.6. MANIFEST.MF</h5></div></div></div><p>
              When deployed on WildFly, this application requires   access to the JBossWS and Apache CXF APIs provided in modules   org.jboss.ws.cxf.jbossws-cxf-client.  The org.jboss.ws.cxf.sts module is also needed to build the STS  configuration in  the
              <code class="code">SampleSTS</code>
              constructor.  The dependency statement directs the server to provide them at deployment.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Manifest-Version: 1.0  
Ant-Version: Apache Ant 1.8.2  
Created-By: 1.7.0_25-b15 (Oracle Corporation)  
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client,org.jboss.ws.cxf.sts
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-Webservicerequester"/>5.13.7.3. Web service requester</h4></div></div></div><p>This section examines the crucial elements in calling a web service   that implements endpoint security as described in the SAML Bearer   scenario.  The components that will be discussed are.</p><div class="itemizedlist"><ul><li><p>Web service requester's implementation</p></li><li><p>ClientCallbackHandler</p></li><li><p>Crypto properties and keystore files</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-WebservicerequesterImplementation"/>5.13.7.3.1. Web service requester Implementation</h5></div></div></div><p>The ws-requester, the client, uses standard procedures for creating a   reference to the web service.  To address the  endpoint  security requirements, the web service's "Request Context" is  configured with the information needed in message generation.  In   addition, the STSClient that communicates with the STS is configured   with similar values.  Note the key strings ending with a  ".it" suffix.   This suffix flags these settings as belonging to the  STSClient.  The  internal CXF code assigns this information to the  STSClient that is  auto-generated for this service call.</p><p>There  is an alternate method of setting up the STSCLient.  The user  may  provide their own instance of the STSClient.  The CXF code will use  this  object and not auto-generate one.  When providing the  STSClient in this way, the  user must provide a org.apache.cxf.Bus for it  and the configuration  keys must not have the ".it" suffix.  This is used in the ActAs and OnBehalfOf examples.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
  String serviceURL = "https://" + getServerHost() + ":8443/jaxws-samples-wsse-policy-trust-bearer/BearerService";

  final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy", "BearerService");
  Service service = Service.create(new URL(serviceURL + "?wsdl"), serviceName);
  BearerIface proxy = (BearerIface) service.getPort(BearerIface.class);

  Map&lt;String, Object&gt; ctx = ((BindingProvider)proxy).getRequestContext();

  // set the security related configuration information for the service "request"
  ctx.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
  ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
    Thread.currentThread().getContextClassLoader().getResource(
    "META-INF/clientKeystore.properties"));
  ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
    Thread.currentThread().getContextClassLoader().getResource(
    "META-INF/clientKeystore.properties"));
  ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myclientkey");
  ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myservicekey");

  //-- Configuration settings that will be transfered to the STSClient
  // "alice" is the name provided for the WSS Username. Her password will
  // be retreived from the ClientCallbackHander by the STSClient.
  ctx.put(SecurityConstants.USERNAME + ".it", "alice");
  ctx.put(SecurityConstants.CALLBACK_HANDLER + ".it", new ClientCallbackHandler());
  ctx.put(SecurityConstants.ENCRYPT_PROPERTIES + ".it",
    Thread.currentThread().getContextClassLoader().getResource(
    "META-INF/clientKeystore.properties"));
  ctx.put(SecurityConstants.ENCRYPT_USERNAME + ".it", "mystskey");
  ctx.put(SecurityConstants.STS_TOKEN_USERNAME + ".it", "myclientkey");
  ctx.put(SecurityConstants.STS_TOKEN_PROPERTIES + ".it",
    Thread.currentThread().getContextClassLoader().getResource(
    "META-INF/clientKeystore.properties"));
  ctx.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO + ".it", "true");

  proxy.sayHello();

</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-ClientCallbackHandler"/>5.13.7.3.2. ClientCallbackHandler</h5></div></div></div><p>
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/JBWS/WS-Trust+and+STS#WS-TrustandSTS-ClientCallbackHandler">https://docs.jboss.org/author/display/JBWS/WS-Trust+and+STS#WS-TrustandSTS-ClientCallbackHandler</a>
            </p><p>ClientCallbackHandler is a callback handler for the WSS4J Crypto API.    It is used to obtain the password for the private key in the keystore.    This class enables CXF to retrieve the password of the user name to use   for the message signature.  Note that "alice" and her password have  been  provided here.  This information is not in the (JKS)  keystore but   provided in the WildFly security domain.  It was   declared in file jbossws-users.properties.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared;

import java.io.IOException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.ws.security.WSPasswordCallback;

public class ClientCallbackHandler implements CallbackHandler {

    public void handle(Callback[] callbacks) throws IOException,
            UnsupportedCallbackException {
        for (int i = 0; i &lt; callbacks.length; i++) {
            if (callbacks[i] instanceof WSPasswordCallback) {
                WSPasswordCallback pc = (WSPasswordCallback) callbacks[i];
                if ("myclientkey".equals(pc.getIdentifier())) {
                    pc.setPassword("ckpass");
                    break;
                } else if ("alice".equals(pc.getIdentifier())) {
                    pc.setPassword("clarinet");
                    break;
                } else if ("bob".equals(pc.getIdentifier())) {
                    pc.setPassword("trombone");
                    break;
                } else if ("myservicekey".equals(pc.getIdentifier())) {  // rls test  added for bearer test
                   pc.setPassword("skpass");
                   break;
                }
            }
        }
    }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906786_SAMLBearerAssertionScenario-Cryptopropertiesandkeystorefilesxx"/>5.13.7.3.3. Crypto properties and keystore files</h5></div></div></div><p>
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/JBWS/WS-Trust+and+STS#WS-TrustandSTS-RequesterCryptopropertiesandkeystorefiles">https://docs.jboss.org/author/display/JBWS/WS-Trust+and+STS#WS-TrustandSTS-RequesterCryptopropertiesandkeystorefiles</a>
            </p><p>WSS4J's Crypto implementation is loaded and configured via a Java   properties file that contains Crypto configuration data.  The file   contains implementation-specific properties such as a keystore location,   password, default alias and the like.  This application is using the   Merlin implementation. File clientKeystore.properties contains this   information.</p><p>
              File  clientstore.jks, is a Java KeyStore (JKS) repository.  It  contains self  signed certificates for myservicekey and mystskey.
              <span class="italics">Self signed certificates are not appropriate for production use.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=cspass
org.apache.ws.security.crypto.merlin.keystore.alias=myclientkey
org.apache.ws.security.crypto.merlin.keystore.file=META-INF/clientstore.jks
</pre></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-78906915"/>5.13.8. SAML Holder-Of-Key Assertion Scenario</h3></div></div></div><p>
          WS-Trust deals with managing software security tokens.  A SAML  assertion is a type of security token.  In the Holder-Of-Key method, the  STS creates a SAML token containing the client's public key and signs  the SAML token with its private key.  The client includes the SAML token  and signs the outgoing soap envelope to the web service with its  private key.  The web service validates the SOAP message and the SAML  token.
          
        </p><p>Implementation of this scenario has the following requirements.</p><div class="itemizedlist"><ul><li><p>SAML  tokens with a Holder-Of-Key subject confirmation method must be  protected so the token can not be snooped.  In most cases,  a Holder-Of-Key token combined with HTTPS is sufficient to prevent "a  man in the middle" getting possession of the token.  This means a  security policy that uses a sp:TransportBinding and sp:HttpsToken.</p></li><li><p>A Holder-Of-Key  token has no encryption or signing keys associated with it, therefore a  sp:IssuedToken of SymmetricKey or PublicKey  keyType should be used  with a sp:SignedEndorsingSupportingTokens.</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-WebserviceProvider"/>5.13.8.1. Web service Provider</h4></div></div></div><p>This section examines the web service elements for the SAML Holder-Of-Key scenario.  The components are</p><div class="itemizedlist"><ul><li><p>Web service provider's WSDL</p></li><li><p>SSL configuration</p></li><li><p>Web service provider's Interface and Implementation classes.</p></li><li><p>Crypto properties and keystore files</p></li><li><p>MANIFEST.MF</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-WebserviceproviderWSDL"/>5.13.8.1.1. Web service provider WSDL</h5></div></div></div><p>The web service provider is a contract-first endpoint.  All the WS-trust   and security policies for it are declared in the WSDL, HolderOfKeyService.wsdl.  For this scenario a ws-requester is required to   present a SAML 2.0 token of SymmetricKey keyType, issued from a designed STS. The address of the   STS is provided in the WSDL.  A transport binding policy is used.  The token is declared to be signed and endorsed, sp:SignedEndorsingSupportingTokens.  A detailed  explanation of the security  settings are provided in the comments in  the listing below.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy"
             name="HolderOfKeyService"
        xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
        xmlns="http://schemas.xmlsoap.org/wsdl/"
        xmlns:wsp="http://www.w3.org/ns/ws-policy"
        xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"
    xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
    xmlns:wsaws="http://www.w3.org/2005/08/addressing"
    xmlns:wsx="http://schemas.xmlsoap.org/ws/2004/09/mex"
    xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"
    xmlns:t="http://docs.oasis-open.org/ws-sx/ws-trust/200512"&gt;

  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy"
                  schemaLocation="HolderOfKeyService_schema1.xsd"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="sayHello"&gt;
    &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;
  &lt;message name="sayHelloResponse"&gt;
    &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;
  &lt;portType name="HolderOfKeyIface"&gt;
    &lt;operation name="sayHello"&gt;
      &lt;input message="tns:sayHello"/&gt;
      &lt;output message="tns:sayHelloResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
&lt;!--
        The wsp:PolicyReference binds the security requirments on all the endpoints.
        The wsp:Policy wsu:Id="#TransportSAML2HolderOfKeyPolicy" element is defined later in this file.
--&gt;
  &lt;binding name="HolderOfKeyServicePortBinding" type="tns:HolderOfKeyIface"&gt;
    &lt;wsp:PolicyReference URI="#TransportSAML2HolderOfKeyPolicy" /&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="sayHello"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;
&lt;!--
  The soap:address has been defined to use JBoss's https port, 8443.  This is
  set in conjunction with the sp:TransportBinding policy for https.
--&gt;
  &lt;service name="HolderOfKeyService"&gt;
    &lt;port name="HolderOfKeyServicePort" binding="tns:HolderOfKeyServicePortBinding"&gt;
      &lt;soap:address location="https://@jboss.bind.address@:8443/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;


  &lt;wsp:Policy wsu:Id="TransportSAML2HolderOfKeyPolicy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
  &lt;!--
        The wsam:Addressing element, indicates that the endpoints of this
        web service MUST conform to the WS-Addressing specification.  The
        attribute wsp:Optional="false" enforces this assertion.
  --&gt;
        &lt;wsam:Addressing wsp:Optional="false"&gt;
          &lt;wsp:Policy /&gt;
        &lt;/wsam:Addressing&gt;
&lt;!--
  The sp:TransportBinding element indicates that security is provided by the
  message exchange transport medium, https.  WS-Security policy specification
  defines the sp:HttpsToken for use in exchanging messages transmitted over HTTPS.
--&gt;
          &lt;sp:TransportBinding
            xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
            &lt;wsp:Policy&gt;
              &lt;sp:TransportToken&gt;
                &lt;wsp:Policy&gt;
                  &lt;sp:HttpsToken&gt;
                    &lt;wsp:Policy/&gt;
                  &lt;/sp:HttpsToken&gt;
                &lt;/wsp:Policy&gt;
              &lt;/sp:TransportToken&gt;
&lt;!--
     The sp:AlgorithmSuite element, requires the TripleDes algorithm suite
     be used in performing cryptographic operations.
--&gt;
              &lt;sp:AlgorithmSuite&gt;
                &lt;wsp:Policy&gt;
                  &lt;sp:TripleDes /&gt;
                &lt;/wsp:Policy&gt;
              &lt;/sp:AlgorithmSuite&gt;
&lt;!--
     The sp:Layout element,  indicates the layout rules to apply when adding
     items to the security header.  The sp:Lax sub-element indicates items
     are added to the security header in any order that conforms to
     WSS: SOAP Message Security.
--&gt;
              &lt;sp:Layout&gt;
                &lt;wsp:Policy&gt;
                  &lt;sp:Lax /&gt;
                &lt;/wsp:Policy&gt;
              &lt;/sp:Layout&gt;
              &lt;sp:IncludeTimestamp /&gt;
            &lt;/wsp:Policy&gt;
          &lt;/sp:TransportBinding&gt;

&lt;!--
  The sp:SignedEndorsingSupportingTokens, when transport level security level is
  used there will be no message signature and the signature generated by the
  supporting token will sign the Timestamp.
--&gt;
        &lt;sp:SignedEndorsingSupportingTokens
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
&lt;!--
  The sp:IssuedToken element asserts that a SAML 2.0 security token of type
  Bearer is expected from the STS.  The
  sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
  attribute instructs the runtime to include the initiator's public key
  with every message sent to the recipient.

  The sp:RequestSecurityTokenTemplate element directs that all of the
  children of this element will be copied directly into the body of the
  RequestSecurityToken (RST) message that is sent to the STS when the
  initiator asks the STS to issue a token.
--&gt;
            &lt;sp:IssuedToken
              sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
              &lt;sp:RequestSecurityTokenTemplate&gt;
                &lt;t:TokenType&gt;http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0&lt;/t:TokenType&gt;
 &lt;!--
   KeyType of "SymmetricKey", the client must prove to the WS service that it
   possesses a particular symmetric session key.
 --&gt;
                &lt;t:KeyType&gt;http://docs.oasis-open.org/ws-sx/ws-trust/200512/SymmetricKey&lt;/t:KeyType&gt;
              &lt;/sp:RequestSecurityTokenTemplate&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:RequireInternalReference /&gt;
              &lt;/wsp:Policy&gt;
&lt;!--
  The sp:Issuer element defines the STS's address and endpoint information
  This information is used by the STSClient.
--&gt;
              &lt;sp:Issuer&gt;
                &lt;wsaws:Address&gt;http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts-holderofkey/SecurityTokenService&lt;/wsaws:Address&gt;
                &lt;wsaws:Metadata
                  xmlns:wsdli="http://www.w3.org/2006/01/wsdl-instance"
                  wsdli:wsdlLocation="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts-holderofkey/SecurityTokenService?wsdl"&gt;
                  &lt;wsaw:ServiceName
                    xmlns:wsaw="http://www.w3.org/2006/05/addressing/wsdl"
                    xmlns:stsns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
                    EndpointName="UT_Port"&gt;stsns:SecurityTokenService&lt;/wsaw:ServiceName&gt;
                &lt;/wsaws:Metadata&gt;
              &lt;/sp:Issuer&gt;

            &lt;/sp:IssuedToken&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SignedEndorsingSupportingTokens&gt;
&lt;!--
    The sp:Wss11 element declares WSS: SOAP Message Security 1.1 options
    to be supported by the STS.  These particular elements generally refer
    to how keys are referenced within the SOAP envelope.  These are normally
    handled by CXF.
--&gt;
        &lt;sp:Wss11&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportRefIssuerSerial /&gt;
            &lt;sp:MustSupportRefThumbprint /&gt;
            &lt;sp:MustSupportRefEncryptedKey /&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Wss11&gt;
&lt;!--
    The sp:Trust13 element declares controls for WS-Trust 1.3 options.
    They are policy assertions related to exchanges specifically with
    client and server challenges and entropy behaviors.  Again these are
    normally handled by CXF.
--&gt;
        &lt;sp:Trust13&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportIssuedTokens /&gt;
            &lt;sp:RequireClientEntropy /&gt;
            &lt;sp:RequireServerEntropy /&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Trust13&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

&lt;/definitions&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-SSLconfiguration"/>5.13.8.1.2. SSL configuration</h5></div></div></div><p>
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/JBWS/WS-Trust+and+STS#WS-TrustandSTS-SSLconfiguration">https://docs.jboss.org/author/display/JBWS/WS-Trust+and+STS#WS-TrustandSTS-SSLconfiguration</a>
            </p><p>This web service is using https, therefore the JBoss server must be  configured to provide SSL support in the Web subsystem.  There are 2  components to SSL configuration.</p><div class="itemizedlist"><ul><li><p>create a certificate keystore</p></li><li><p>declare an SSL connector in the Web subsystem of the JBoss server configuration file.</p></li></ul></div><p>
              Follow the directions in the, "
              <span class="italics">Using the pure Java implementation supplied by JSSE</span>
              " section in the [SSL Setup Guide|../../../../../../../../../../display/WFLY8/SSL+setup+guide|||\||].
            </p><p>Here is an example of an SSL connector declaration.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;subsystem xmlns="urn:jboss:domain:web:1.4" default-virtual-server="default-host" native="false"&gt;
.....
  &lt;connector name="jbws-https-connector" protocol="HTTP/1.1" scheme="https" socket-binding="https" secure="true" enabled="true"&gt;
    &lt;ssl key-alias="tomcat" password="changeit" certificate-key-file="/myJbossHome/security/test.keystore" verify-client="false"/&gt;
  &lt;/connector&gt;
...
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-WebserviceInterface"/>5.13.8.1.3. Web service Interface</h5></div></div></div><p>The web service provider interface class, HolderOfKeyIface, is a simple straight forward web service definition.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.holderofkey;

import javax.jws.WebMethod;
import javax.jws.WebService;

@WebService
(
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy"
)
public interface HolderOfKeyIface {
   @WebMethod
   String sayHello();
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-WebserviceImplementation"/>5.13.8.1.4. Web service Implementation</h5></div></div></div><p>
              The web service provider implementation class, HolderOfKeyImpl, is a   simple POJO. It uses the standard WebService annotation to define the   service endpoint. In addition there are two Apache CXF annotations,   EndpointProperties and EndpointProperty used for configuring the   endpoint for the CXF runtime. These annotations come from the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://ws.apache.org/wss4j/">Apache WSS4J project</a>
              ,   which provides a Java implementation of the primary WS-Security   standards for Web Services. These annotations are programmatically   adding properties to the endpoint. With plain Apache CXF, these properties are often set via the &lt;jaxws:properties&gt; element on the   &lt;jaxws:endpoint&gt; element in the Spring config; these   annotations allow the properties to be configured in the code.
            </p><p>WSS4J  uses the Crypto interface to get keys and certificates for  signature  creation/verification, as is asserted by the WSDL for this  service. The  WSS4J configuration information being provided by HolderOfKeyImpl is for  Crypto's Merlin implementation. More information  will be provided about  this in the keystore section.</p><p>The first EndpointProperty statement in the listing disables ensurance of compliance with the Basic Security Profile 1.1. The next EndpointProperty statements declares the Java  properties file that contains the (Merlin)  crypto configuration  information. The last EndpointProperty statement declares the STSHolderOfKeyCallbackHandler implementation class. It is used  to obtain the  user's password for the certificates in the keystore  file.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.holderofkey;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;

import javax.jws.WebService;

@WebService
   (
      portName = "HolderOfKeyServicePort",
      serviceName = "HolderOfKeyService",
      wsdlLocation = "WEB-INF/wsdl/HolderOfKeyService.wsdl",
      targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy",
      endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.holderofkey.HolderOfKeyIface"
   )
@EndpointProperties(value = {
   @EndpointProperty(key = "ws-security.is-bsp-compliant", value = "false"),
   @EndpointProperty(key = "ws-security.signature.properties", value = "serviceKeystore.properties"),
   @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.holderofkey.HolderOfKeyCallbackHandler")
})
public class HolderOfKeyImpl implements HolderOfKeyIface
{
   public String sayHello()
   {
      return "Holder-Of-Key WS-Trust Hello World!";
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-Cryptopropertiesandkeystorefiles"/>5.13.8.1.5. Crypto properties and keystore files</h5></div></div></div><p>WSS4J's Crypto implementation is loaded and configured via a Java   properties file that contains Crypto configuration data.  The file   contains implementation-specific properties such as a keystore location,   password, default alias and the like.  This application is using the   Merlin implementation. File serviceKeystore.properties contains this   information.</p><p>
              File  servicestore.jks, is a Java KeyStore (JKS) repository.  It  contains  self signed certificates for myservicekey and mystskey.
              <span class="italics">Self signed certificates are not appropriate for production use.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=sspass
org.apache.ws.security.crypto.merlin.keystore.alias=myservicekey
org.apache.ws.security.crypto.merlin.keystore.file=servicestore.jks
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-MANIFEST.MF"/>5.13.8.1.6. MANIFEST.MF</h5></div></div></div><p>
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/JBWS/WS-Trust+and+STS#WS-TrustandSTS-MANIFEST.MF">https://docs.jboss.org/author/display/JBWS/WS-Trust+and+STS#WS-TrustandSTS-MANIFEST.MF</a>
            </p><p>When deployed on WildFly this application requires   access to the JBossWs and CXF APIs provided in module   org.jboss.ws.cxf.jbossws-cxf-client.  The dependency statement directs  the server to provide them at deployment.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Manifest-Version:1.0
Ant-Version: Apache Ant1.8.2
Created-By:1.7.0_25-b15 (Oracle Corporation)
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-SecurityTokenService"/>5.13.8.2. Security Token Service</h4></div></div></div><p>This section examines the crucial elements in providing the Security   Token Service functionality for providing a SAML Holder-Of-Key token.  The   components that will be discussed are.</p><div class="itemizedlist"><ul><li><p>Security Domain</p></li><li><p>STS's WSDL</p></li><li><p>STS's implementation class</p></li><li><p>STSBearerCallbackHandler</p></li><li><p>Crypto properties and keystore files</p></li><li><p>MANIFEST.MF</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-SecurityDomain"/>5.13.8.2.1. Security Domain</h5></div></div></div><p>The STS requires a JBoss security domain be configured.  The  jboss-web.xml descriptor declares a named security  domain,"JBossWS-trust-sts" to be used by this service for  authentication.  This security domain requires two properties files and  the addition of a security-domain declaration in the JBoss server  configuration file.</p><p>
              For this scenario the domain needs to contain user
              <span class="italics">alice</span>
              , password
              <span class="italics">clarinet</span>
              , and role
              <span class="italics">friend</span>
              .  See the listings below for jbossws-users.properties and  jbossws-roles.properties.  In addition the following XML must be added  to the JBoss security subsystem in the server configuration file.   Replace "
              <span class="strong"><strong>SOME_PATH</strong></span>
              " with appropriate information.
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;security-domain name="JBossWS-trust-sts"&gt;
  &lt;authentication&gt;
   &lt;login-module code="UsersRoles" flag="required"&gt;
     &lt;module-option name="usersProperties" value="/SOME_PATH/jbossws-users.properties"/&gt;
     &lt;module-option name="unauthenticatedIdentity" value="anonymous"/&gt;
     &lt;module-option name="rolesProperties" value="/SOME_PATH/jbossws-roles.properties"/&gt;
   &lt;/login-module&gt;
  &lt;/authentication&gt;
&lt;/security-domain&gt;
</pre></div><p>jboss-web.xml</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE jboss-web PUBLIC"-//JBoss//DTD Web Application 2.4//EN" "&gt;
&lt;jboss-web&gt;
  &lt;security-domain&gt;java:/jaas/JBossWS-trust-sts&lt;/security-domain&gt;
&lt;/jboss-web&gt;
</pre></div><div class="informaltable"><table border="1"><colgroup><col/></colgroup><tbody><tr><td>
                      <p>
                        
                      </p>
                    </td></tr></tbody></table></div><p>jbossws-users.properties</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
# A sample users.properties filefor use with the UsersRolesLoginModule
alice=clarinet
</pre></div><div class="informaltable"><table border="1"><colgroup><col/></colgroup><tbody><tr><td>
                      <p> </p>
                    </td></tr></tbody></table></div><p>jbossws-roles.properties</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
# A sample roles.properties filefor use with the UsersRolesLoginModule
alice=friend
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-STS%27sWSDL"/>5.13.8.2.2. STS's WSDL</h5></div></div></div><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;wsdl:definitions
  targetNamespace="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:tns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:wstrust="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:wsap10="http://www.w3.org/2006/05/addressing/wsdl"
  xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
  xmlns:wsp="http://www.w3.org/ns/ws-policy"
  xmlns:wst="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"&gt;

  &lt;wsdl:types&gt;
    &lt;xs:schema elementFormDefault="qualified"
               targetNamespace='http://docs.oasis-open.org/ws-sx/ws-trust/200512'&gt;

      &lt;xs:element name='RequestSecurityToken'
                  type='wst:AbstractRequestSecurityTokenType'/&gt;
      &lt;xs:element name='RequestSecurityTokenResponse'
                  type='wst:AbstractRequestSecurityTokenType'/&gt;

      &lt;xs:complexType name='AbstractRequestSecurityTokenType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:any namespace='##any' processContents='lax' minOccurs='0'
                  maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name='Context' type='xs:anyURI' use='optional'/&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax'/&gt;
      &lt;/xs:complexType&gt;
      &lt;xs:element name='RequestSecurityTokenCollection'
                  type='wst:RequestSecurityTokenCollectionType'/&gt;
      &lt;xs:complexType name='RequestSecurityTokenCollectionType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element name='RequestSecurityToken'
                      type='wst:AbstractRequestSecurityTokenType' minOccurs='2'
                      maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name='RequestSecurityTokenResponseCollection'
                  type='wst:RequestSecurityTokenResponseCollectionType'/&gt;
      &lt;xs:complexType name='RequestSecurityTokenResponseCollectionType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref='wst:RequestSecurityTokenResponse' minOccurs='1'
                      maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax'/&gt;
      &lt;/xs:complexType&gt;

    &lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;

  &lt;!-- WS-Trust defines the following GEDs --&gt;
  &lt;wsdl:message name="RequestSecurityTokenMsg"&gt;
    &lt;wsdl:part name="request" element="wst:RequestSecurityToken"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseMsg"&gt;
    &lt;wsdl:part name="response"
               element="wst:RequestSecurityTokenResponse"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenCollectionMsg"&gt;
    &lt;wsdl:part name="requestCollection"
               element="wst:RequestSecurityTokenCollection"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseCollectionMsg"&gt;
    &lt;wsdl:part name="responseCollection"
               element="wst:RequestSecurityTokenResponseCollection"/&gt;
  &lt;/wsdl:message&gt;

  &lt;!-- This portType an example of a Requestor (or other) endpoint that
         Accepts SOAP-based challenges from a Security Token Service --&gt;
  &lt;wsdl:portType name="WSSecurityRequestor"&gt;
    &lt;wsdl:operation name="Challenge"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!-- This portType is an example of an STS supporting full protocol --&gt;
  &lt;wsdl:portType name="STS"&gt;
    &lt;wsdl:operation name="Cancel"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/CancelFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Issue"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTRC/IssueFinal"
        message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Renew"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/RenewFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Validate"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/ValidateFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="KeyExchangeToken"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KET"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/KETFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="RequestCollection"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenCollectionMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!-- This portType is an example of an endpoint that accepts
         Unsolicited RequestSecurityTokenResponse messages --&gt;
  &lt;wsdl:portType name="SecurityTokenResponseService"&gt;
    &lt;wsdl:operation name="RequestSecurityTokenResponse"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;wsdl:binding name="UT_Binding" type="wstrust:STS"&gt;
    &lt;wsp:PolicyReference URI="#UT_policy"/&gt;
    &lt;soap:binding style="document"
                  transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="Issue"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue"/&gt;
      &lt;wsdl:input&gt;
        &lt;wsp:PolicyReference
          URI="#Input_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;wsp:PolicyReference
          URI="#Output_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Validate"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate"/&gt;
      &lt;wsdl:input&gt;
        &lt;wsp:PolicyReference
          URI="#Input_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;wsp:PolicyReference
          URI="#Output_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Cancel"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Renew"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="KeyExchangeToken"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KeyExchangeToken"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="RequestCollection"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/RequestCollection"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;

  &lt;wsdl:service name="SecurityTokenService"&gt;
    &lt;wsdl:port name="UT_Port" binding="tns:UT_Binding"&gt;
      &lt;soap:address location="http://localhost:8080/SecurityTokenService/UT"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;

  &lt;wsp:Policy wsu:Id="UT_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;wsap10:UsingAddressing/&gt;
        &lt;sp:SymmetricBinding
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:ProtectionToken&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:X509Token
                  sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
                  &lt;wsp:Policy&gt;
                    &lt;sp:RequireDerivedKeys/&gt;
                    &lt;sp:RequireThumbprintReference/&gt;
                    &lt;sp:WssX509V3Token10/&gt;
                  &lt;/wsp:Policy&gt;
                &lt;/sp:X509Token&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:ProtectionToken&gt;
            &lt;sp:AlgorithmSuite&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Basic256/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:AlgorithmSuite&gt;
            &lt;sp:Layout&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Lax/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:Layout&gt;
            &lt;sp:IncludeTimestamp/&gt;
            &lt;sp:EncryptSignature/&gt;
            &lt;sp:OnlySignEntireHeadersAndBody/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SymmetricBinding&gt;
        &lt;sp:SignedSupportingTokens
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:UsernameToken
              sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:WssUsernameToken10/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:UsernameToken&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SignedSupportingTokens&gt;
        &lt;sp:Wss11
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportRefKeyIdentifier/&gt;
            &lt;sp:MustSupportRefIssuerSerial/&gt;
            &lt;sp:MustSupportRefThumbprint/&gt;
            &lt;sp:MustSupportRefEncryptedKey/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Wss11&gt;
        &lt;sp:Trust13
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportIssuedTokens/&gt;
            &lt;sp:RequireClientEntropy/&gt;
            &lt;sp:RequireServerEntropy/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Trust13&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

  &lt;wsp:Policy wsu:Id="Input_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;sp:SignedParts
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;sp:Body/&gt;
          &lt;sp:Header Name="To"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="From"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="FaultTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="ReplyTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="MessageID"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="RelatesTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="Action"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
        &lt;/sp:SignedParts&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

  &lt;wsp:Policy wsu:Id="Output_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;sp:SignedParts
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;sp:Body/&gt;
          &lt;sp:Header Name="To"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="From"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="FaultTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="ReplyTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="MessageID"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="RelatesTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="Action"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
        &lt;/sp:SignedParts&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

&lt;/wsdl:definitions&gt;
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-STS%27simplementationclass"/>5.13.8.2.3. STS's implementation class</h5></div></div></div><p>
              The Apache CXF's STS, SecurityTokenServiceProvider, is a web service    provider that is compliant with the protocols and functionality  defined   by the WS-Trust specification.  It has a modular architecture.  Many of   its components are configurable or replaceable and there are  many   optional features that are enabled by implementing and  configuring   plug-ins.  Users can customize their own STS by extending  from   SecurityTokenServiceProvider and overriding the default  settings.    Extensive information about the CXF's STS configurable and  pluggable   components can be found
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://coheigea.blogspot.com/2011/11/apache-cxf-sts-documentation-part-viii_10.html">here</a>
              .
            </p><p>This STS implementation class, SampleSTSHolderOfKey, is a POJO that  extends from   SecurityTokenServiceProvider.  Note that the class is  defined with a   WebServiceProvider annotation and not a WebService   annotation.  This  annotation defines the service as a Provider-based   endpoint, meaning it  supports a more messaging-oriented approach to Web   services.  In  particular, it signals that the exchanged messages will  be  XML  documents of some type.  SecurityTokenServiceProvider is an    implementation of the javax.xml.ws.Provider interface.  In comparison    the WebService annotation defines a (service endpoint interface)    SEI-based endpoint which supports message exchange via SOAP envelopes.</p><p>As was  done in the HolderOfKeyImpl class, the WSS4J annotations   EndpointProperties  and EndpointProperty are providing endpoint   configuration  for the CXF runtime.  The first EndpointProperty  statements declares the Java  properties file that  contains the (Merlin)  crypto configuration  information.  WSS4J reads this file  and extra required  information for  message handling.  The last  EndpointProperty statement declares the STSHolderOfKeyCallbackHandler  implementation class.  It is used  to obtain the  user's password for  the certificates in the keystore  file.</p><p>In this implementation we are customizing the operations of token issuance and their static properties.</p><p>StaticSTSProperties is used to set select properties for configuring   resources  in the STS.  You may think this is a duplication of the   settings made  with the WSS4J annotations.  The values are the same but   the underlaying  structures being set are different, thus this   information must be  declared in both places.</p><p>The  setIssuer setting is important because it uniquely identifies    the issuing STS.  The issuer string is embedded in issued tokens and,    when validating tokens, the STS checks the issuer string value.    Consequently, it is important to use the issuer string in a consistent    way, so that the STS can recognize the tokens that it has issued.</p><p>The setEndpoints call allows the declaration of a set  of allowed   token recipients by address.  The addresses are specified  as reg-ex   patterns.</p><p>TokenIssueOperation has a modular  structure.   This allows custom  behaviors to be injected into the  processing of  messages.  In this  case we are overriding the   SecurityTokenServiceProvider's default  behavior and performing SAML   token processing.  CXF provides an  implementation of a   SAMLTokenProvider which we are using rather than    writing our own.</p><p>
              Learn more about the SAMLTokenProvider
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://coheigea.blogspot.it/2011/10/apache-cxf-sts-documentation-part-iv.html">here</a>
              .
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsholderofkey;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.sts.StaticSTSProperties;
import org.apache.cxf.sts.operation.TokenIssueOperation;
import org.apache.cxf.sts.service.ServiceMBean;
import org.apache.cxf.sts.service.StaticService;
import org.apache.cxf.sts.token.provider.SAMLTokenProvider;
import org.apache.cxf.ws.security.sts.provider.SecurityTokenServiceProvider;

import javax.xml.ws.WebServiceProvider;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

/**
 * User: rsearls
 * Date: 3/14/14
 */
@WebServiceProvider(serviceName = "SecurityTokenService",
   portName = "UT_Port",
   targetNamespace = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/",
   wsdlLocation = "WEB-INF/wsdl/holderofkey-ws-trust-1.4-service.wsdl")
//be sure to have dependency on org.apache.cxf module when on AS7, otherwise Apache CXF annotations are ignored
@EndpointProperties(value = {
   @EndpointProperty(key = "ws-security.signature.properties", value = "stsKeystore.properties"),
   @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsholderofkey.STSHolderOfKeyCallbackHandler")
})
public class SampleSTSHolderOfKey extends SecurityTokenServiceProvider
{

   public SampleSTSHolderOfKey() throws Exception
   {
      super();

      StaticSTSProperties props = new StaticSTSProperties();
      props.setSignatureCryptoProperties("stsKeystore.properties");
      props.setSignatureUsername("mystskey");
      props.setCallbackHandlerClass(STSHolderOfKeyCallbackHandler.class.getName());
      props.setEncryptionCryptoProperties("stsKeystore.properties");
      props.setEncryptionUsername("myservicekey");
      props.setIssuer("DoubleItSTSIssuer");

      List&lt;ServiceMBean&gt; services = new LinkedList&lt;ServiceMBean&gt;();
      StaticService service = new StaticService();
      service.setEndpoints(Arrays.asList(
         "https://localhost:(\\d)*/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService",
         "https://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService",
         "https://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService"
      ));

      services.add(service);

      TokenIssueOperation issueOperation = new TokenIssueOperation();
      issueOperation.getTokenProviders().add(new SAMLTokenProvider());
      issueOperation.setServices(services);
      issueOperation.setStsProperties(props);
      this.setIssueOperation(issueOperation);

   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-HolderOfKeyCallbackHandler"/>5.13.8.2.4. HolderOfKeyCallbackHandler</h5></div></div></div><p>STSHolderOfKeyCallbackHandler is a callback handler for the WSS4J Crypto  API.  It   is used to obtain the password for the private key in the  keystore.    This class enables CXF to retrieve the password of the user  name to use   for the message signature.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsholderofkey;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;

import java.util.HashMap;
import java.util.Map;

/**
 * User: rsearls
 * Date: 3/19/14
 */
public class STSHolderOfKeyCallbackHandler extends PasswordCallbackHandler
{
   public STSHolderOfKeyCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("mystskey", "stskpass");
      passwords.put("alice", "clarinet");
      return passwords;
   }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-Cryptopropertiesandkeystorefilesx"/>5.13.8.2.5. Crypto properties and keystore files</h5></div></div></div><p>WSS4J's Crypto implementation is loaded and configured via a Java   properties file that contains Crypto configuration data.  The file   contains implementation-specific properties such as a keystore location,   password, default alias and the like.  This application is using the   Merlin implementation. File stsKeystore.properties contains this   information.</p><p>
              File  servicestore.jks, is a Java KeyStore (JKS) repository.  It  contains  self signed certificates for myservicekey and mystskey.
              <span class="italics">Self signed certificates are not appropriate for production use.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=stsspass
org.apache.ws.security.crypto.merlin.keystore.file=stsstore.jks
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-MANIFEST.MFx"/>5.13.8.2.6. MANIFEST.MF</h5></div></div></div><p>When deployed on WildFly, this application requires   access to the JBossWS and Apache CXF APIs provided in modules   org.jboss.ws.cxf.jbossws-cxf-client.  The org.jboss.ws.cxf.sts module is also needed to build the STS  configuration in  the SampleSTSHolderOfKey constructor.  The dependency statement directs the server to provide them at deployment.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Manifest-Version:1.0
Ant-Version: Apache Ant1.8.2
Created-By:1.7.0_25-b15 (Oracle Corporation)
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client,org.jboss.ws.cxf.sts
</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-Webservicerequester"/>5.13.8.3. Web service requester</h4></div></div></div><p>This section examines the crucial elements in calling a web service    that implements endpoint security as described in the SAML Holder-Of-Key    scenario.  The components that will be discussed are.</p><div class="itemizedlist"><ul><li><p>web service requester's implementation</p></li><li><p>ClientCallbackHandler</p></li><li><p>Crypto properties and keystore files</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-WebservicerequesterImplementation"/>5.13.8.3.1. Web service requester Implementation</h5></div></div></div><p>The ws-requester, the client, uses standard procedures for creating a    reference to the web service.  To address the  endpoint  security  requirements, the web service's "Request Context" is  configured with  the information needed in message generation.  In   addition, the  STSClient that communicates with the STS is configured   with similar  values.  Note the key strings ending with a  ".it" suffix.   This suffix  flags these settings as belonging to the  STSClient.  The  internal CXF  code assigns this information to the  STSClient that is  auto-generated  for this service call.</p><p>There  is an alternate method of setting up the STSCLient.  The user   may  provide their own instance of the STSClient.  The CXF code will  use  this  object and not auto-generate one.  When providing the   STSClient in this way, the  user must provide a org.apache.cxf.Bus for  it  and the configuration  keys must not have the ".it" suffix.  This is  used in the ActAs and OnBehalfOf examples.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
String serviceURL = "https://" + getServerHost() + ":8443/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService";

final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy", "HolderOfKeyService");
final URL wsdlURL = new URL(serviceURL + "?wsdl");
Service service = Service.create(wsdlURL, serviceName);
HolderOfKeyIface proxy = (HolderOfKeyIface) service.getPort(HolderOfKeyIface.class);

Map&lt;String, Object&gt; ctx = ((BindingProvider)proxy).getRequestContext();

// set the security related configuration information for the service "request"
ctx.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
  Thread.currentThread().getContextClassLoader().getResource(
  "META-INF/clientKeystore.properties"));
ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
  Thread.currentThread().getContextClassLoader().getResource(
  "META-INF/clientKeystore.properties"));
ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myclientkey");
ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myservicekey");

//-- Configuration settings that will be transfered to the STSClient
// "alice" is the name provided for the WSS Username. Her password will
// be retreived from the ClientCallbackHander by the STSClient.
ctx.put(SecurityConstants.USERNAME + ".it", "alice");
ctx.put(SecurityConstants.CALLBACK_HANDLER + ".it", new ClientCallbackHandler());
ctx.put(SecurityConstants.ENCRYPT_PROPERTIES + ".it",
  Thread.currentThread().getContextClassLoader().getResource(
  "META-INF/clientKeystore.properties"));
ctx.put(SecurityConstants.ENCRYPT_USERNAME + ".it", "mystskey");
ctx.put(SecurityConstants.STS_TOKEN_USERNAME + ".it", "myclientkey");
ctx.put(SecurityConstants.STS_TOKEN_PROPERTIES + ".it",
  Thread.currentThread().getContextClassLoader().getResource(
  "META-INF/clientKeystore.properties"));
ctx.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO + ".it", "true");

proxy.sayHello();
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-ClientCallbackHandler"/>5.13.8.3.2. ClientCallbackHandler</h5></div></div></div><p>ClientCallbackHandler is a callback handler for the WSS4J Crypto API.    It is used to obtain the password for the private key in the keystore.    This class enables CXF to retrieve the password of the user name to use   for the message signature.  Note that "alice" and her password have  been  provided here.  This information is not in the (JKS)  keystore but   provided in the WildFly security domain.  It was   declared in file jbossws-users.properties.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared;

import java.io.IOException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.ws.security.WSPasswordCallback;

public class ClientCallbackHandler implements CallbackHandler {

    public void handle(Callback[] callbacks) throws IOException,
            UnsupportedCallbackException {
        for (int i = 0; i &lt; callbacks.length; i++) {
            if (callbacks[i] instanceof WSPasswordCallback) {
                WSPasswordCallback pc = (WSPasswordCallback) callbacks[i];
                if ("myclientkey".equals(pc.getIdentifier())) {
                    pc.setPassword("ckpass");
                    break;
                } else if ("alice".equals(pc.getIdentifier())) {
                    pc.setPassword("clarinet");
                    break;
                } else if ("bob".equals(pc.getIdentifier())) {
                    pc.setPassword("trombone");
                    break;
                } else if ("myservicekey".equals(pc.getIdentifier())) {  // rls test  added for bearer test
                   pc.setPassword("skpass");
                   break;
                }
            }
        }
    }
}
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="sid-78906915_SAMLHolder-Of-KeyAssertionScenario-Cryptopropertiesandkeystorefilesxx"/>5.13.8.3.3. Crypto properties and keystore files</h5></div></div></div><p>WSS4J's Crypto implementation is loaded and configured via a Java   properties file that contains Crypto configuration data.  The file   contains implementation-specific properties such as a keystore location,   password, default alias and the like.  This application is using the   Merlin implementation. File clientKeystore.properties contains this   information.</p><p>
              File  clientstore.jks, is a Java KeyStore (JKS) repository.  It  contains self  signed certificates for myservicekey and mystskey.
              <span class="italics">Self signed certificates are not appropriate for production use.</span>
            </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=cspass
org.apache.ws.security.crypto.merlin.keystore.alias=myclientkey
org.apache.ws.security.crypto.merlin.keystore.file=META-INF/clientstore.jks
</pre></div></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866797"/>5.14. WS-Reliable Messaging</h2></div></div></div><p>
        JBoss Web Services inherits full WS-Reliable Messaging capabilities from the  underlying Apache CXF implementation. At the time of writing, Apache CXF provides support for the
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://schemas.xmlsoap.org/ws/2005/02/rm/">WS-Reliable Messaging 1.0</a>
        (February 2005) version of the specification.
      </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866797_WS-ReliableMessaging-EnablingWSReliableMessaging"/>5.14.1. Enabling WS-Reliable Messaging</h3></div></div></div><p>WS-Reliable Messaging is implemented internally in Apache CXF through a set of interceptors that deal with the low level requirements of the reliable messaging protocol. In order for enabling WS-Reliable Messaging, users need to either:</p><div class="itemizedlist"><ul><li><p>consume a WSDL contract that specifies proper WS-Reliable Messaging policies / assertions</p></li><li><p>manually add / configure the reliable messaging interceptors</p></li><li><p>specify the reliable messaging policies in an optional CXF Spring XML descriptor</p></li><li><p>specify the Apache CXF reliable messaging feature in an optional CXF Spring XML descriptor</p></li></ul></div><p>
          The former approach relies on the Apache CXF WS-Policy engine and is the only portable one. The other approaches are Apache CXF proprietary ones, however they allow for fine-grained configuration of protocol aspects that are not covered by the WS-Reliable Messaging Policy. More details are available in the
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/wsrmconfiguration.html">Apache CXF documentation</a>
          .
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866797_WS-ReliableMessaging-Example"/>5.14.2. Example</h3></div></div></div><p>In this example we configure WS-Reliable Messaging endpoint and client through the WS-Policy support.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866797_WS-ReliableMessaging-Endpoint"/>5.14.2.1. Endpoint</h4></div></div></div><p>We go with a contract-first approach, so we start by creating a proper WSDL contract, containing the WS-Reliable Messaging and WS-Addressing policies (the latter is a requirement of the former):</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;wsdl:definitions name="SimpleService" targetNamespace="http://www.jboss.org/jbossws/ws-extensions/wsrm"
  xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/wsrm" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:wsp="http://www.w3.org/2006/07/ws-policy"&gt;

  &lt;wsdl:types&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/wsrm"
  attributeFormDefault="unqualified" elementFormDefault="unqualified"
  targetNamespace="http://www.jboss.org/jbossws/ws-extensions/wsrm"&gt;
&lt;xsd:element name="ping" type="tns:ping"/&gt;
&lt;xsd:complexType name="ping"&gt;
&lt;xsd:sequence/&gt;
&lt;/xsd:complexType&gt;
&lt;xsd:element name="echo" type="tns:echo"/&gt;
&lt;xsd:complexType name="echo"&gt;
&lt;xsd:sequence&gt;
&lt;xsd:element minOccurs="0" name="arg0" type="xsd:string"/&gt;
&lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;
&lt;xsd:element name="echoResponse" type="tns:echoResponse"/&gt;
&lt;xsd:complexType name="echoResponse"&gt;
&lt;xsd:sequence&gt;
&lt;xsd:element minOccurs="0" name="return" type="xsd:string"/&gt;
&lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
  &lt;/wsdl:types&gt;
  &lt;wsdl:message name="echoResponse"&gt;
    &lt;wsdl:part name="parameters" element="tns:echoResponse"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="echo"&gt;
    &lt;wsdl:part name="parameters" element="tns:echo"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="ping"&gt;
    &lt;wsdl:part name="parameters" element="tns:ping"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:portType name="SimpleService"&gt;
    &lt;wsdl:operation name="ping"&gt;
      &lt;wsdl:input name="ping" message="tns:ping"&gt;
    &lt;/wsdl:input&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;wsdl:input name="echo" message="tns:echo"&gt;
    &lt;/wsdl:input&gt;
      &lt;wsdl:output name="echoResponse" message="tns:echoResponse"&gt;
    &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;
  &lt;wsdl:binding name="SimpleServiceSoapBinding" type="tns:SimpleService"&gt;
    &lt;wsp:Policy&gt;
      &lt;!-- WS-Addressing and basic WS-Reliable Messaging policy assertions --&gt;
      &lt;wswa:UsingAddressing xmlns:wswa="http://www.w3.org/2006/05/addressing/wsdl"/&gt;
      &lt;wsrmp:RMAssertion xmlns:wsrmp="http://schemas.xmlsoap.org/ws/2005/02/rm/policy"/&gt;
      &lt;!-- --------------------------------------------------------------- --&gt;
    &lt;/wsp:Policy&gt;
    &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="ping"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="ping"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="echo"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="echoResponse"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="SimpleService"&gt;
    &lt;wsdl:port name="SimpleServicePort" binding="tns:SimpleServiceSoapBinding"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-samples-wsrm-api"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</pre></div><p>
            Then we use the
            <span class="italics">wsconsume</span>
            tool to generate both standard JAX-WS client and endpoint.
          </p><p>We provide a basic JAX-WS implementation for the endpoint, nothing special in it:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.jboss.test.ws.jaxws.samples.wsrm.service;

import javax.jws.Oneway;
import javax.jws.WebMethod;
import javax.jws.WebService;

@WebService
(
   name = "SimpleService",
   serviceName = "SimpleService",
   wsdlLocation = "WEB-INF/wsdl/SimpleService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wsrm"
)
public class SimpleServiceImpl
{
   @Oneway
   @WebMethod
   public void ping()
   {
      System.out.println("ping()");
   }

   @WebMethod
   public String echo(String s)
   {
      System.out.println("echo(" + s + ")");
      return s;
   }
}</pre></div><p>Finally we package the generated POJO endpoint together with a basic web.xml the usual way and deploy to the application server. The webservices stack automatically detects the policies and enables WS-Reliable Messaging.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866797_WS-ReliableMessaging-Client"/>5.14.2.2. Client</h4></div></div></div><p>The endpoint advertises his  RM capabilities (and requirements) through the published WSDL and the client is required to  also enable WS-RM for successfully exchanging messages with the server.</p><p>So a regular JAX WS client is enough if the user does not need to tune any specific detail of the RM subsystem.</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wsrm", "SimpleService");
URL wsdlURL = new URL("http://localhost:8080/jaxws-samples-wsrm-api?wsdl");
Service service = Service.create(wsdlURL, serviceName);
proxy = (SimpleService)service.getPort(SimpleService.class);
proxy.echo("Hello World!");</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866797_WS-ReliableMessaging-Additionalconfiguration"/>5.14.2.3. Additional configuration</h4></div></div></div><p>Fine-grained tuning of WS-Reliable Messaging engine requires setting up proper RM features and attach them for instance to the client proxy. Here is an example:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsrm.client;

//...
import javax.xml.ws.Service;
import org.apache.cxf.ws.rm.feature.RMFeature;
import org.apache.cxf.ws.rm.manager.AcksPolicyType;
import org.apache.cxf.ws.rm.manager.DestinationPolicyType;
import org.apache.cxf.ws.rmp.v200502.RMAssertion;
import org.apache.cxf.ws.rmp.v200502.RMAssertion.AcknowledgementInterval;
import org.jboss.test.ws.jaxws.samples.wsrm.generated.SimpleService;

//...
Service service = Service.create(wsdlURL, serviceName);

RMFeature feature = new RMFeature();
RMAssertion rma = new RMAssertion();
RMAssertion.BaseRetransmissionInterval bri = new RMAssertion.BaseRetransmissionInterval();
bri.setMilliseconds(4000L);
rma.setBaseRetransmissionInterval(bri);
AcknowledgementInterval ai = new AcknowledgementInterval();
ai.setMilliseconds(2000L);
rma.setAcknowledgementInterval(ai);
feature.setRMAssertion(rma);
DestinationPolicyType dp = new DestinationPolicyType();
AcksPolicyType ap = new AcksPolicyType();
ap.setIntraMessageThreshold(0);
dp.setAcksPolicy(ap);
feature.setDestinationPolicy(dp);

SimpleService proxy = (SimpleService)service.getPort(SimpleService.class, feature);
proxy.echo("Hello World");
</pre></div><p>
            The same can of course be achieved by factoring the feature into a custom pojo extending
            <code class="code">org.apache.cxf.ws.rm.feature.RMFeature</code>
            and setting the obtained property in a client configuration:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.jboss.test.ws.jaxws.samples.wsrm.client;

import org.apache.cxf.ws.rm.feature.RMFeature;
import org.apache.cxf.ws.rm.manager.AcksPolicyType;
import org.apache.cxf.ws.rm.manager.DestinationPolicyType;
import org.apache.cxf.ws.rmp.v200502.RMAssertion;
import org.apache.cxf.ws.rmp.v200502.RMAssertion.AcknowledgementInterval;

public class CustomRMFeature extends RMFeature
{
   public CustomRMFeature() {
      super();
      RMAssertion rma = new RMAssertion();
      RMAssertion.BaseRetransmissionInterval bri = new RMAssertion.BaseRetransmissionInterval();
      bri.setMilliseconds(4000L);
      rma.setBaseRetransmissionInterval(bri);
      AcknowledgementInterval ai = new AcknowledgementInterval();
      ai.setMilliseconds(2000L);
      rma.setAcknowledgementInterval(ai);
      super.setRMAssertion(rma);
      DestinationPolicyType dp = new DestinationPolicyType();
      AcksPolicyType ap = new AcksPolicyType();
      ap.setIntraMessageThreshold(0);
      dp.setAcksPolicy(ap);
      super.setDestinationPolicy(dp);
   }
}
</pre></div><p>
            ... this is how the
            <code class="code">jaxws-client-config.xml</code>
            descriptor would look:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;

  &lt;client-config&gt;
    &lt;config-name&gt;Custom Client Config&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.samples.wsrm.client.CustomRMFeature&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/client-config&gt;

&lt;/jaxws-config&gt;
</pre></div><p>... and this is how the client would set the configuration:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
import org.jboss.ws.api.configuration.ClientConfigUtil;
import org.jboss.ws.api.configuration.ClientConfigurer;

//...
Service service = Service.create(wsdlURL, serviceName);
SimpleService proxy = (SimpleService)service.getPort(SimpleService.class);

ClientConfigurer configurer = ClientConfigUtil.resolveClientConfigurer();
configurer.setConfigProperties(proxy, "META-INF/jaxws-client-config.xml", "Custom Client Config");
proxy.echo("Hello World!");
</pre></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-3866801"/>5.15. SOAP over JMS</h2></div></div></div><p>
        JBoss Web Services allows communication over the
        <span class="italics">JMS</span>
        transport. The functionality comes from Apache CXF support for the
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/soapjms/">SOAP over Java Message Service 1.0</a>
        specification, which is aimed at a set of standards for interoperable transport of
        <span class="italics">SOAP</span>
        messages over
        <span class="italics">JMS</span>
        .
      </p><p>
        On top of Apache CXF functionalities, the JBossWS integration allows users to deploy WS archives containing both
        <span class="italics">JMS</span>
        and
        <span class="italics">HTTP</span>
        endpoints the same way as they do for basic
        <span class="italics">HTTP</span>
        WS endpoints (in
        <span class="italics">war</span>
        archives). The webservices layer of WildFly takes care of looking for
        <span class="italics">JMS</span>
        enpdoints in the deployed archive and starts them delegating to the Apache CXF core similarly as with
        <span class="italics">HTTP</span>
        endpoints.
      </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866801_SOAPoverJMS-ConfiguringSOAPoverJMS"/>5.15.1. Configuring SOAP over JMS</h3></div></div></div><p>
          As per specification, the
          <span class="italics">SOAP over JMS</span>
          transport configuration is controlled by proper elements and attributes in the
          <code class="code">binding</code>
          and
          <code class="code">service</code>
          elements of the WSDL contract. So a
          <span class="italics">JMS</span>
          endpoint is usually developed using a contract-first approach.
        </p><p>
          The
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/soap-over-jms-10-support.html">Apache CXF documentation</a>
          covers all the details of the supported configurations. The minimum configuration implies:
        </p><div class="itemizedlist"><ul><li><p>
              setting a proper JMS URI in the
              <code class="code">soap:address</code>
              <code class="code">location</code>
              [1]
            </p></li><li><p>providing a JNDI connection factory name to be used for connecting to the queues [2]</p></li><li><p>setting the transport binding [3]</p></li></ul></div><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;wsdl:definitions name="HelloWorldService" targetNamespace="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:tns="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soapjms="http://www.w3.org/2010/soapjms/"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
...

&lt;wsdl:binding name="HelloWorldServiceSoapBinding" type="tns:HelloWorld"&gt;
  &lt;soap:binding style="document" transport="http://www.w3.org/2010/soapjms/"/&gt; &lt;!-- 3 --&gt;
  &lt;wsdl:operation name="echo"&gt;
    &lt;soap:operation soapAction="" style="document"/&gt;
    &lt;wsdl:input name="echo"&gt;
      &lt;soap:body use="literal"/&gt;
    &lt;/wsdl:input&gt;
    &lt;wsdl:output name="echoResponse"&gt;
      &lt;soap:body use="literal"/&gt;
    &lt;/wsdl:output&gt;
  &lt;/wsdl:operation&gt;
&lt;/wsdl:binding&gt;
&lt;wsdl:service name="HelloWorldService"&gt;
  &lt;soapjms:jndiConnectionFactoryName&gt;java:/ConnectionFactory&lt;/soapjms:jndiConnectionFactoryName&gt; &lt;!-- 2 --&gt;
  &lt;wsdl:port binding="tns:HelloWorldServiceSoapBinding" name="HelloWorldImplPort"&gt;
    &lt;soap:address location="jms:queue:testQueue"/&gt; &lt;!-- 1 --&gt;
  &lt;/wsdl:port&gt;
&lt;/wsdl:service&gt;
</pre></div><p>
          Apache CXF takes care of setting up the JMS transport for endpoint implementations whose
          <code class="code">@WebService</code>
          annotation points to a port declared for JMS transport as explained above.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
            JBossWS currently supports POJO endpoints only for JMS transport use. The endpoint classes can be deployed as part of
            <span class="italics">jar</span>
            or
            <span class="italics">war</span>
            archives.
          </p><p>
            The
            <span class="italics">web.xml</span>
            descriptor in
            <span class="italics">war</span>
            archives doesn't need any entry for JMS endpoints.
          </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-3866801_SOAPoverJMS-Examples"/>5.15.2. Examples</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866801_SOAPoverJMS-JMSendpointonlydeployment"/>5.15.2.1. JMS endpoint only deployment</h4></div></div></div><p>
            In this example we create a simple endpoint relying on
            <span class="italics">SOAP over JMS</span>
            and deploy it as part of a jar archive.
          </p><p>The endpoint is created using wsconsume tool from a WSDL contract such as:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;wsdl:definitions name="HelloWorldService" targetNamespace="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:ns1="http://schemas.xmlsoap.org/soap/http"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:tns="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soapjms="http://www.w3.org/2010/soapjms/"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;wsdl:types&gt;
&lt;xs:schema elementFormDefault="unqualified" targetNamespace="http://org.jboss.ws/jaxws/cxf/jms" version="1.0" xmlns:tns="http://org.jboss.ws/jaxws/cxf/jms" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;xs:element name="echo" type="tns:echo"/&gt;
&lt;xs:element name="echoResponse" type="tns:echoResponse"/&gt;
&lt;xs:complexType name="echo"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;xs:complexType name="echoResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;
  &lt;wsdl:message name="echoResponse"&gt;
    &lt;wsdl:part element="tns:echoResponse" name="parameters"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="echo"&gt;
    &lt;wsdl:part element="tns:echo" name="parameters"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:portType name="HelloWorld"&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;wsdl:input message="tns:echo" name="echo"&gt;
    &lt;/wsdl:input&gt;
      &lt;wsdl:output message="tns:echoResponse" name="echoResponse"&gt;
    &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;
  &lt;wsdl:binding name="HelloWorldServiceSoapBinding" type="tns:HelloWorld"&gt;
    &lt;soap:binding style="document" transport="http://www.w3.org/2010/soapjms/"/&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="echo"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="echoResponse"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="HelloWorldService"&gt;
    &lt;soapjms:jndiConnectionFactoryName&gt;java:jms/RemoteConnectionFactory&lt;/soapjms:jndiConnectionFactoryName&gt;
    &lt;soapjms:jndiInitialContextFactory&gt;org.jboss.naming.remote.client.InitialContextFactory&lt;/soapjms:jndiInitialContextFactory&gt;
    &lt;soapjms:jndiURL&gt;http-remoting://myhost:8080&lt;/soapjms:jndiURL&gt;
    &lt;wsdl:port binding="tns:HelloWorldServiceSoapBinding" name="HelloWorldImplPort"&gt;
      &lt;soap:address location="jms:queue:testQueue"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
  &lt;wsdl:service name="HelloWorldServiceLocal"&gt;
    &lt;soapjms:jndiConnectionFactoryName&gt;java:/ConnectionFactory&lt;/soapjms:jndiConnectionFactoryName&gt;
    &lt;wsdl:port binding="tns:HelloWorldServiceSoapBinding" name="HelloWorldImplPort"&gt;
      &lt;soap:address location="jms:queue:testQueue"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
              The
              <span class="italics">HelloWorldImplPort</span>
              here is meant for using the
              <span class="italics">testQueue</span>
              that has to be created before deploying the endpoint.
            </p></div><p>
            At the time of writing,
            <span class="italics">java:/ConnectionFactory</span>
            is the default connection factory JNDI location.
          </p><p>
            For allowing remote JNDI lookup of the connection factory, a specific service (
            <code class="code">HelloWorldService</code>
            ) for remote clients is added to the WSDL. The
            <span class="italics">java:jms/RemoteConnectionFactory</span>
            is the JNDI location of the same connection factory mentioned above, except it's exposed for remote lookup. The
            <code class="code">soapjms:jndiInitialContextFactory</code>
            and
            <code class="code">soap:jmsjndiURL</code>
            complete the remote connection configuration: they depends on the actual WildFly container the service is running on and specify the the initial context factory class to use and the JNDI registry address.
          </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Have a look at the application server domain for finding out the configured connection factory JNDI locations.</p></div><p>The endpoint implementation is a basic JAX-WS POJO using @WebService annotation to refer to the consumed contract:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.jboss.test.ws.jaxws.cxf.jms;

import javax.jws.WebService;

@WebService
(
   portName = "HelloWorldImplPort",
   serviceName = "HelloWorldServiceLocal",
   wsdlLocation = "META-INF/wsdl/HelloWorldService.wsdl",
   endpointInterface = "org.jboss.test.ws.jaxws.cxf.jms.HelloWorld",
   targetNamespace = "http://org.jboss.ws/jaxws/cxf/jms"
)
public class HelloWorldImpl implements HelloWorld
{
   public String echo(String input)
   {
      return input;
   }
}</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
              The endpoint implementation references the
              <code class="code">HelloWorldServiceLocal</code>
              wsdl service, so that the local JNDI connection factory location is used for starting the endpoint on server side.
            </p></div><p>
            That's pretty much all. We just need to package the generated service endpoint interface, the endpoint implementation and the WSDL file in a
            <span class="italics">jar</span>
            archive and deploy it:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">alessio@inuyasha /dati/jbossws/stack/cxf/trunk $ jar -tvf ./modules/testsuite/cxf-tests/target/test-libs/jaxws-cxf-jms-only-deployment.jar
     0 Thu Jun 23 15:18:44 CEST 2011 META-INF/
   129 Thu Jun 23 15:18:42 CEST 2011 META-INF/MANIFEST.MF
     0 Thu Jun 23 15:18:42 CEST 2011 org/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/jaxws/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/jaxws/cxf/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/jaxws/cxf/jms/
   313 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/jaxws/cxf/jms/HelloWorld.class
  1173 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/jaxws/cxf/jms/HelloWorldImpl.class
     0 Thu Jun 23 15:18:40 CEST 2011 META-INF/wsdl/
  3074 Thu Jun 23 15:18:40 CEST 2011 META-INF/wsdl/HelloWorldService.wsdl</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
              A dependency on
              <code class="code">org.apache.activemq.artemis</code>
              module needs to be added in MANIFEST.MF when deploying to WildFly.
            </p><div class="informalexample"><pre xmlns="" class="">Manifest-Version: 1.0

Ant-Version: Apache Ant 1.7.1

Created-By: 17.0-b16 (Sun Microsystems Inc.)

Dependencies: org.apache.activemq.artemis</pre></div></div><p>A JAX-WS client can interact with the JMS endpoint the usual way:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">URL wsdlUrl = ...
//start another bus to avoid affecting the one that could already be assigned to the current thread - optional but highly suggested
Bus bus = BusFactory.newInstance().createBus();
BusFactory.setThreadDefaultBus(bus);
try
{
   QName serviceName = new QName("http://org.jboss.ws/jaxws/cxf/jms", "HelloWorldService");
   Service service = Service.create(wsdlUrl, serviceName);
   HelloWorld proxy = (HelloWorld) service.getPort(new QName("http://org.jboss.ws/jaxws/cxf/jms", "HelloWorldImplPort"), HelloWorld.class);
   setupProxy(proxy);
   proxy.echo("Hi");
}
finally
{
   bus.shutdown(true);
}
</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>The WSDL location URL needs to be retrieved in a custom way, depending on the client application. Given the endpoint is JMS only, there's no automatically published WSDL contract.</p></div><p>in order for performing the remote invocation (which internally goes through remote JNDI lookup of the connection factory), the calling user credentials need to be set into the Apache CXF JMSConduit:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
private void setupProxy(HelloWorld proxy) {
   JMSConfiguration config = conduit.getJmsConfig();
   config.setUserName(JBossWSTestHelper.getTestUsername());
   config.setPassword(JBossWSTestHelper.getTestPassword());
   Properties props = conduit.getJmsConfig().getJndiEnvironment();
   props.put(Context.SECURITY_PRINCIPAL, JBossWSTestHelper.getTestUsername());
   props.put(Context.SECURITY_CREDENTIALS, JBossWSTestHelper.getTestPassword());
}
</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
              Have a look at the WildFly domain and messaging configuration for finding out the actual security requirements. At the time of writing, a user with
              <code class="code">guest</code>
              role is required and that's internally checked using the
              <code class="code">other</code>
              security domain.
            </p></div><p>Of course once the endpoint is exposed over JMS transport, any plain JMS client can also be used to send messages to the webservice endpoint. You can have a look at the SOAP over JMS spec details and code the client similarly to</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Properties env = new Properties();
env.put(Context.INITIAL_CONTEXT_FACTORY, "org.jboss.naming.remote.client.InitialContextFactory");
env.put(Context.PROVIDER_URL, "http-remoting://myhost:8080");
env.put(Context.SECURITY_PRINCIPAL, "user");
env.put(Context.SECURITY_CREDENTIALS, "password");
InitialContext context = new InitialContext(env);
QueueConnectionFactory connectionFactory = (QueueConnectionFactory)context.lookup("jms/RemoteConnectionFactory");
Queue reqQueue = (Queue)context.lookup("jms/queue/test");
Queue resQueue = (Queue)context.lookup("jms/queue/test");
QueueConnection con = connectionFactory.createQueueConnection("user", "password");
QueueSession session = con.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
QueueReceiver receiver = session.createReceiver(resQueue);
ResponseListener responseListener = new ResponseListener(); //a custom response listener...
receiver.setMessageListener(responseListener);
con.start();
TextMessage message = session.createTextMessage(reqMessage);
message.setJMSReplyTo(resQueue);

//setup SOAP-over-JMS properties...
message.setStringProperty("SOAPJMS_contentType", "text/xml");
message.setStringProperty("SOAPJMS_requestURI", "jms:queue:testQueue");

QueueSender sender = session.createSender(reqQueue);
sender.send(message);
sender.close();

...
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866801_SOAPoverJMS-JMSandHTTPendpointsdeployment"/>5.15.2.2. JMS and HTTP endpoints deployment</h4></div></div></div><p>
            In this example we create a deployment containing an endpoint that serves over both HTTP and JMS transports.
            
          </p><p>
            We from a WSDL contract such as below (please note we've two
            <code class="code">binding</code>
            /
            <code class="code">portType</code>
            for the same
            <code class="code">service</code>
            ):
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;wsdl:definitions name="HelloWorldService" targetNamespace="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:ns1="http://schemas.xmlsoap.org/soap/http"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:tns="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soapjms="http://www.w3.org/2010/soapjms/"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;wsdl:types&gt;
&lt;xs:schema elementFormDefault="unqualified" targetNamespace="http://org.jboss.ws/jaxws/cxf/jms" version="1.0"
  xmlns:tns="http://org.jboss.ws/jaxws/cxf/jms" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;xs:element name="echo" type="tns:echo"/&gt;
&lt;xs:element name="echoResponse" type="tns:echoResponse"/&gt;
&lt;xs:complexType name="echo"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;xs:complexType name="echoResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;
  &lt;wsdl:message name="echoResponse"&gt;
    &lt;wsdl:part element="tns:echoResponse" name="parameters"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="echo"&gt;
    &lt;wsdl:part element="tns:echo" name="parameters"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:portType name="HelloWorld"&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;wsdl:input message="tns:echo" name="echo"&gt;
    &lt;/wsdl:input&gt;
      &lt;wsdl:output message="tns:echoResponse" name="echoResponse"&gt;
    &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;
  &lt;wsdl:binding name="HelloWorldServiceSoapBinding" type="tns:HelloWorld"&gt;
    &lt;soap:binding style="document" transport="http://www.w3.org/2010/soapjms/"/&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="echo"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="echoResponse"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:binding name="HttpHelloWorldServiceSoapBinding" type="tns:HelloWorld"&gt;
    &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="echo"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="echoResponse"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="HelloWorldService"&gt;
    &lt;soapjms:jndiConnectionFactoryName&gt;java:jms/RemoteConnectionFactory&lt;/soapjms:jndiConnectionFactoryName&gt;
    &lt;soapjms:jndiInitialContextFactory&gt;org.jboss.naming.remote.client.InitialContextFactory&lt;/soapjms:jndiInitialContextFactory&gt;
    &lt;soapjms:jndiURL&gt;remote://localhost:4447&lt;/soapjms:jndiURL&gt;
    &lt;wsdl:port binding="tns:HelloWorldServiceSoapBinding" name="HelloWorldImplPort"&gt;
      &lt;soap:address location="jms:queue:testQueue"/&gt;
    &lt;/wsdl:port&gt;
    &lt;wsdl:port binding="tns:HttpHelloWorldServiceSoapBinding" name="HttpHelloWorldImplPort"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-cxf-jms-http-deployment"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
  &lt;wsdl:service name="HelloWorldServiceLocal"&gt;
    &lt;soapjms:jndiConnectionFactoryName&gt;java:/ConnectionFactory&lt;/soapjms:jndiConnectionFactoryName&gt;
    &lt;wsdl:port binding="tns:HelloWorldServiceSoapBinding" name="HelloWorldImplPort"&gt;
      &lt;soap:address location="jms:queue:testQueue"/&gt;
    &lt;/wsdl:port&gt;
&lt;/wsdl:definitions&gt;</pre></div><p>
            The same considerations of the previous example regarding the JMS queue and JNDI connection factory still apply.
            
            Here we can implement the endpoint in multiple ways, either with a common implementation class that's extended by the JMS and HTTP ones, or keep the two implementation classes independent and just have them implement the same service endpoint interface:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.jboss.test.ws.jaxws.cxf.jms_http;

import javax.jws.WebService;

@WebService
(
   portName = "HelloWorldImplPort",
   serviceName = "HelloWorldServiceLocal",
   wsdlLocation = "WEB-INF/wsdl/HelloWorldService.wsdl",
   endpointInterface = "org.jboss.test.ws.jaxws.cxf.jms_http.HelloWorld",
   targetNamespace = "http://org.jboss.ws/jaxws/cxf/jms"
)
public class HelloWorldImpl implements HelloWorld
{
   public String echo(String input)
   {
      System.out.println("input: " + input);
      return input;
   }
}</pre></div><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.jboss.test.ws.jaxws.cxf.jms_http;

import javax.jws.WebService;

@WebService
(
   portName = "HttpHelloWorldImplPort",
   serviceName = "HelloWorldService",
   wsdlLocation = "WEB-INF/wsdl/HelloWorldService.wsdl",
   endpointInterface = "org.jboss.test.ws.jaxws.cxf.jms_http.HelloWorld",
   targetNamespace = "http://org.jboss.ws/jaxws/cxf/jms"
)
public class HttpHelloWorldImpl implements HelloWorld
{
   public String echo(String input)
   {
      System.out.println("input (http): " + input);
      return "(http) " + input;
   }
}</pre></div><p>
            Both classes are packaged together the service endpoint interface and the WSDL file in a
            <span class="italics">war</span>
            archive:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">alessio@inuyasha /dati/jbossws/stack/cxf/trunk $ jar -tvf ./modules/testsuite/cxf-tests/target/test-libs/jaxws-cxf-jms-http-deployment.war
     0 Thu Jun 23 15:18:44 CEST 2011 META-INF/
   129 Thu Jun 23 15:18:42 CEST 2011 META-INF/MANIFEST.MF
     0 Thu Jun 23 15:18:44 CEST 2011 WEB-INF/
   569 Thu Jun 23 15:18:40 CEST 2011 WEB-INF/web.xml
     0 Thu Jun 23 15:18:44 CEST 2011 WEB-INF/classes/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/cxf/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/cxf/jms_http/
   318 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/cxf/jms_http/HelloWorld.class
  1192 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/cxf/jms_http/HelloWorldImpl.class
  1246 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/cxf/jms_http/HttpHelloWorldImpl.class
     0 Thu Jun 23 15:18:40 CEST 2011 WEB-INF/wsdl/
  3068 Thu Jun 23 15:18:40 CEST 2011 WEB-INF/wsdl/HelloWorldService.wsdl</pre></div><p>A trivial web.xml descriptor is also included to trigger the HTTP endpoint publish:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
  version="2.4"&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;EndpointServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.test.ws.jaxws.cxf.jms_http.HttpHelloWorldImpl&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;EndpointServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
              Here too the MANIFEST.MF needs to declare a dependency on
              <span class="italics">org.apache.activemq.artemis</span>
              module when deploying to WildFly.
            </p></div><p>Finally, the JAX-WS client can ineract with both JMS and HTTP endpoints as usual:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">//start another bus to avoid affecting the one that could already be assigned to current thread - optional but highly suggested
Bus bus = BusFactory.newInstance().createBus();
BusFactory.setThreadDefaultBus(bus);
try
{
   QName serviceName = new QName("http://org.jboss.ws/jaxws/cxf/jms", "HelloWorldService");
   Service service = Service.create(wsdlUrl, serviceName);

   //JMS test
   HelloWorld proxy = (HelloWorld) service.getPort(new QName("http://org.jboss.ws/jaxws/cxf/jms", "HelloWorldImplPort"), HelloWorld.class);
   setupProxy(proxy);
   proxy.echo("Hi");
   //HTTP test
   HelloWorld httpProxy = (HelloWorld) service.getPort(new QName("http://org.jboss.ws/jaxws/cxf/jms", "HttpHelloWorldImplPort"), HelloWorld.class);
   httpProxy.echo("Hi");
}
finally
{
   bus.shutdown(true);
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-3866801_SOAPoverJMS-UseofEndpoint.publish%28%29API"/>5.15.2.3. Use of Endpoint.publish() API</h4></div></div></div><p>
            An alternative to deploying an archive containing JMS endpoints is in starting them directly using the JAX-WS
            <code class="code">Endpoint.publish(..)</code>
            API.
          </p><p>That's as easy as doing:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Object implementor = new HelloWorldImpl();
Endpoint ep = Endpoint.publish("jms:queue:testQueue", implementor);
try
{
   //use or let others use the endpoint
}
finally
{
   ep.stop();
}</pre></div><p>
            where
            <code class="code">HelloWorldImpl</code>
            is a POJO endpoint implementation referencing a JMS
            <span class="italics">port</span>
            in a given WSDL contract, as explained in the previous examples.
          </p><p>
            The main difference among the deployment approach is in the direct control and responsibility over the endpoint lifecycle (
            <span class="italics">start/publish</span>
            and
            <span class="italics">stop</span>
            ).
          </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-4784141"/>5.16. HTTP Proxy</h2></div></div></div><p>The HTTP Proxy related functionalities of JBoss Web Services are provided by the Apache CXF http transport layer.</p><p>
        The suggested configuration mechanism when running JBoss Web Services is explained below; for further information please refer to the
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/client-http-transport-including-ssl-support.html">Apache CXF documentation</a>
        .
      </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-4784141_HTTPProxy-Configuration"/>5.16.1. Configuration</h3></div></div></div><p>The HTTP proxy configuration for a given JAX-WS client can be set in the following ways:</p><div class="itemizedlist"><ul><li><p>
              through the
              <code class="code">http.proxyHost</code>
              and
              <code class="code">http.proxyPort</code>
              system properties, or
            </p></li><li><p>
              leveraging the
              <code class="code">org.apache.cxf.transport.http.HTTPConduit</code>
              options
            </p></li></ul></div><p>
          The former is a JVM level configuration; for instance, assuming the http proxy is currently running at
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://localhost:9934">http://localhost:9934</a>
          , here is the setup:
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">System.getProperties().setProperty("http.proxyHost", "localhost");
System.getProperties().setProperty("http.proxyPort", 9934);</pre></div><p>
          The latter is a client stub/port level configuration: the setup is performed on the
          <code class="code">HTTPConduit</code>
          object that's part of the Apache CXF
          <code class="code">Client</code>
          abstraction.
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">import org.apache.cxf.configuration.security.ProxyAuthorizationPolicy;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.frontend.ClientProxy;
import org.apache.cxf.transport.http.HTTPConduit;
import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;
import org.apache.cxf.transports.http.configuration.ProxyServerType;
...

Service service = Service.create(wsdlURL, new QName("http://org.jboss.ws/jaxws/cxf/httpproxy", "HelloWorldService"));
HelloWorld port = (HelloWorld) service.getPort(new QName("http://org.jboss.ws/jaxws/cxf/httpproxy", "HelloWorldImplPort"), HelloWorld.class);

Client client = ClientProxy.getClient(port);
HTTPConduit conduit = (HTTPConduit)client.getConduit();
ProxyAuthorizationPolicy policy = new ProxyAuthorizationPolicy();
policy.setAuthorizationType("Basic");
policy.setUserName(PROXY_USER);
policy.setPassword(PROXY_PWD);
conduit.setProxyAuthorization(policy);

port.echo("Foo");</pre></div><p>
          The
          <code class="code">ProxyAuthorizationPolicy</code>
          also allows for setting the authotization type as well as the username / password to be used.
        </p><p>
          Speaking of authorization and authentication, please note that the JDK already features the
          <code class="code">java.net.Authenticator</code>
          facility, which is used whenever opening a connection to a given URL requiring a http proxy. Users might want to set a custom Authenticator for instance when needing to read WSDL contracts before actually calling into the JBoss Web Services / Apache CXF code; here is an example:
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">import java.net.Authenticator;
import java.net.PasswordAuthentication;
...
public class ProxyAuthenticator extends Authenticator
{
   private String user, password;

   public ProxyAuthenticator(String user, String password)
   {
      this.user = user;
      this.password = password;
   }

   protected PasswordAuthentication getPasswordAuthentication()
   {
      return new PasswordAuthentication(user, password.toCharArray());
   }
}

...

Authenticator.setDefault(new ProxyAuthenticator(PROXY_USER, PROXY_PWD));</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-66486377"/>5.17. WS-Discovery</h2></div></div></div><p>
        Apache CXF includes support for
        <span class="italics">Web Services Dynamic Discovery</span>
        (
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html">WS-Discovery</a>
        ), which is a protocol to enable dynamic discovery of services available on the local network. The protocol implies using a
        <code class="code">UDP</code>
        based multicast transport to announce new services and probe for existing services. A managed mode where a discovery proxy is used to reduce the amount of required multicast traffic is also covered by the protocol.
      </p><p>
        JBossWS integrates the
        <span class="italics">WS-Discovery</span>
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/ws-discovery.html">functionalities</a>
        provided by Apache CXF into the application server.
      </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-66486377_WS-Discovery-EnablingWSDiscovery"/>5.17.1. Enabling WS-Discovery</h3></div></div></div><p>
          Apache CXF enables
          <span class="italics">WS-Discovery</span>
          depending on the availability of its runtime component; given that's always shipped in the application server, JBossWS integration requires using the
          <code class="code">cxf.ws-discovery.enabled</code>
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://docs.jboss.org/author/display/JBWS/Advanced+User+Guide#AdvancedUserGuide-Configurationthroughdeploymentdescriptor">property</a>
          usage for enabling
          <span class="italics">WS-Discovery</span>
          for a given deployment. By default
          <span class="italics">WS-Discovery</span>
          is disabled on the application server. Below is an example of
          <span class="italics">jboss-webservices.xml</span>
          descriptor to be used for enabling
          <span class="italics">WS-Discovery</span>
          :
        </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;webservices xmlns="http://www.jboss.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="1.2" xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;

  &lt;property&gt;
    &lt;name&gt;cxf.ws-discovery.enabled&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;

&lt;/webservices&gt;</pre></div><p>
          By default, a
          <span class="italics">WS-Discovery</span>
          service endpoint (SOAP-over-UDP bound) will be started the first time a WS-Discovery enabled deployment is processed on the application server. Every ws endpoint belonging to
          <span class="italics">WS-Discovery</span>
          enabled deployments will be automatically registered into such a
          <span class="italics">WS-Discovery</span>
          service endpoint (
          <code class="code">Hello</code>
          messages). The service will reply to
          <code class="code">Probe</code>
          and
          <code class="code">Resolve</code>
          messages received on
          <code class="code">UDP</code>
          port
          <code class="code">3702</code>
          (including multicast messages sent to
          <code class="code">IPv4</code>
          address
          <code class="code">239.255.255.250</code>
          , as per
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html#_Toc234231816">specification</a>
          ). Endpoints will eventually be automatically unregistered using
          <code class="code">Bye</code>
          messages upon undeployment.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-66486377_WS-Discovery-Probingservices"/>5.17.2. Probing services</h3></div></div></div><p>
          Apache CXF comes with a
          <span class="italics">WS-Discovery</span>
          API that can be used to probe / resolve services. When running in-container, a JBoss module
          <a href="sid-4784150.html" title="Chapter 6. JBoss Modules">dependency</a>
          to the the
          <code class="code">org.apache.cxf.impl</code>
          module is to be set to have access to
          <span class="italics">WS-Discovery</span>
          client functionalities.
        </p><p>
          The
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://svn.apache.org/viewvc/cxf/tags/cxf-2.7.5/services/ws-discovery/ws-discovery-api/src/main/java/org/apache/cxf/ws/discovery/WSDiscoveryClient.java?revision=1481139&amp;view=markup">org.apache.cxf.ws.discovery.WSDiscoveryClient</a>
          class provides the
          <span class="italics">probe</span>
          and
          <span class="italics">resolve</span>
          methods which also accepts filters on scopes. Users can rely on them for locating available endpoints on the network. Please have a look at the JBossWS testsuite which includes a
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://anonsvn.jboss.org/repos/jbossws/stack/cxf/tags/jbossws-cxf-4.2.0.Beta1/modules/testsuite/cxf-tests/src/test/java/org/jboss/test/ws/jaxws/samples/wsdd/WSDiscoveryTestCase.java">sample</a>
          on CXF WS-Discovery usage.
        </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-68354567"/>5.18. WS-Policy</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-68354567_WS-Policy-ApacheCXFWSPolicysupport"/>5.18.1. Apache CXF WS-Policy support</h3></div></div></div><p>
          JBossWS policy support rely on the Apache CXF WS-Policy framework, which is compliant with the
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2007/REC-ws-policy-20070904/">Web Services Policy 1.5 - Framework</a>
          and
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2007/REC-ws-policy-attach-20070904/">Web Services Policy 1.5 - Attachment</a>
          specifications.
          
          Users can work with policies in different ways:
        </p><div class="itemizedlist"><ul><li><p>by adding policy assertions to wsdl contracts and letting the runtime consume them and behave accordingly;</p></li><li><p>by specifying endpoint policy attachments using either CXF annotations or features.</p></li></ul></div><p>
          Of course users can also make direct use of the Apache CXF policy framework,
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cxf.apache.org/docs/developing-assertions.html">defining custom assertions</a>
          , etc.
        </p><p>Finally, JBossWS provides some additional annotations for simplified policy attachment.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-68354567_WS-Policy-Contractfirstapproach"/>5.18.1.1. Contract-first approach</h4></div></div></div><p>WS-Policies can be attached and referenced in wsdl elements (the specifications describe all possible alternatives). Apache CXF automatically recognizes, reads and uses policies defined in the wsdl.</p><p>
            Users should hence develop endpoints using the
            <span class="italics">contract-first</span>
            approach, that is explicitly providing the contract for their services. Here is a excerpt taken from a wsdl including a WS-Addressing policy:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;wsdl:definitions name="Foo" targetNamespace="http://ws.jboss.org/foo"
...
&lt;wsdl:service name="FooService"&gt;
    &lt;wsdl:port binding="tns:FooBinding" name="FooPort"&gt;
        &lt;soap:address location="http://localhost:80800/foo"/&gt;
        &lt;wsp:Policy xmlns:wsp="http://www.w3.org/ns/ws-policy"&gt;
             &lt;wsam:Addressing xmlns:wsam="http://www.w3.org/2007/02/addressing/metadata"&gt;
                 &lt;wsp:Policy/&gt;
              &lt;/wsam:Addressing&gt;
         &lt;/wsp:Policy&gt;
    &lt;/wsdl:port&gt;
&lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</pre></div><p>Of course, CXF also acts upon policies specified in wsdl documents consumed on client side.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-68354567_WS-Policy-Codefirstapproach"/>5.18.1.2. Code-first approach</h4></div></div></div><p>
            For those preferring code-first (java-first) endpoint development, Apache CXF comes with
            <code class="code">org.apache.cxf.annotations.Policy</code>
            and
            <code class="code">org.apache.cxf.annotations.Policies</code>
            annotations to be used for attaching policy fragments to the wsdl generated at deploy time.
          </p><p>Here is an example of a code-first endpoint including @Policy annotation:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">import javax.jws.WebService;
import org.apache.cxf.annotations.Policy;

@WebService(portName = "MyServicePort",
            serviceName = "MyService",
            name = "MyServiceIface",
            targetNamespace = "http://www.jboss.org/jbossws/foo")
@Policy(placement = Policy.Placement.BINDING, uri = "JavaFirstPolicy.xml")
public class MyServiceImpl {
   public String sayHello() {
      return "Hello World!";
   }
}</pre></div><p>
            The referenced descriptor is to be added to the deployment and will include the policy to be attached; the attachment position in the contracts is defined through the
            <code class="code">placement</code>
            attribute. Here is a descriptor example:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;wsp:Policy wsu:Id="MyPolicy" xmlns:wsp="http://www.w3.org/ns/ws-policy"
    xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"&gt;
    &lt;wsp:ExactlyOne&gt;
        &lt;wsp:All&gt;
            &lt;sp:SupportingTokens xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
                &lt;wsp:Policy&gt;
                    &lt;sp:UsernameToken sp:IncludeToken="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy/IncludeToken/AlwaysToRecipient"&gt;
                        &lt;wsp:Policy&gt;
                            &lt;sp:WssUsernameToken10/&gt;
                        &lt;/wsp:Policy&gt;
                    &lt;/sp:UsernameToken&gt;
                &lt;/wsp:Policy&gt;
            &lt;/sp:SupportingTokens&gt;
        &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
&lt;/wsp:Policy&gt;</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-68354567_WS-Policy-JBossWSadditions"/>5.18.2. JBossWS additions</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sid-68354567_WS-Policy-Policysets"/>5.18.2.1. Policy sets</h4></div></div></div><p>
            Both approaches above require users to actually write their policies' assertions; while this offer great flexibility and control of the actual contract, providing the assertions might end up being quite a challenging task for complex policies. For this reason, the JBossWS integration provides
            <span class="italics">policy sets</span>
            , which are basically pre-defined groups of policy assertions corresponding to well known / common needs. Each set has a label allowing users to specify it in the
            <code class="code">@org.jboss.ws.api.annotation.PolicySets</code>
            annotation to have the policy assertions for that set attached to the annotated endpoint. Multiple labels can also be specified. Here is an example of the @PolicySets annotation on a service endpoint interface:
          </p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">import javax.jws.WebService;
import org.jboss.ws.api.annotation.PolicySets;

@WebService(name = "EndpointTwo", targetNamespace = "http://org.jboss.ws.jaxws.cxf/jbws3648")
@PolicySets({"WS-RM_Policy_spec_example", "WS-SP-EX223_WSS11_Anonymous_X509_Sign_Encrypt", "WS-Addressing"})
public interface EndpointTwo
{
   String echo(String input);
}</pre></div><p>The three sets specified in @PolicySets will cause the wsdl generated for the endpoint having this interface to be enriched with some policy assertions for WS-RM, WS-Security and WS-Addressing.</p><p>
            The labels' list of known sets is stored in the
            <code class="code">META-INF/policies/org.jboss.wsf.stack.cxf.extensions.policy.PolicyAttachmentStore</code>
            file within the
            <code class="code">jbossws-cxf-client.jar</code>
            (
            <code class="code">org.jboss.ws.cxf:jbossws-cxf-client</code>
            maven artifact). Actual policy fragments for each set are also stored in the same artifact at
            <code class="code">META-INF/policies/&lt;set-label&gt;-&lt;attachment-position&gt;.xml</code>
            .
          </p><p>Here is a list of the available policy sets:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                    <p>Label</p>
                  </th><th>
                    <p>Description</p>
                  </th></tr></thead><tbody><tr><td>
                    <p>WS-Addressing</p>
                  </td><td>
                    <p>Basic WS-Addressing policy</p>
                  </td></tr><tr><td>
                    <p>
                      WS-RM_Policy_spec_example
                      
                    </p>
                  </td><td>
                    <p>The basic WS-RM policy example in the WS-RM specification</p>
                  </td></tr><tr><td>
                    <p>WS-SP-EX2121_SSL_UT_Supporting_Token</p>
                  </td><td>
                    <p>
                      The group of policy assertions used in the section 2.1.2.1 example of the WS-Security Policy Examples 1.0 specification
                      
                    </p>
                  </td></tr><tr><td>
                    <p>
                      WS-SP-EX213_WSS10_UT_Mutual_Auth_X509_Sign_Encrypt
                      
                    </p>
                  </td><td>
                    <p>
                      The group of policy assertions used in the section 2.1.3 example of the WS-Security Policy Examples 1.0 specification
                      
                    </p>
                  </td></tr><tr><td>
                    <p>
                      WS-SP-EX214_WSS11_User_Name_Cert_Sign_Encrypt
                      
                    </p>
                  </td><td>
                    <p>
                      The group of policy assertions used in the section 2.1.4 example of the WS-Security Policy Examples 1.0 specification
                      
                    </p>
                  </td></tr><tr><td>
                    <p>
                      WS-SP-EX221_WSS10_Mutual_Auth_X509_Sign_Encrypt
                      
                    </p>
                  </td><td>
                    <p>The group of policy assertions used in the section 2.2.1 example of the WS-Security Policy Examples 1.0 specification</p>
                  </td></tr><tr><td>
                    <p>
                      WS-SP-EX222_WSS10_Mutual_Auth_X509_Sign_Encrypt
                      
                    </p>
                  </td><td>
                    <p>
                      The group of policy assertions used in the section 2.2.2 example of the WS-Security Policy Examples 1.0 specification
                      
                    </p>
                  </td></tr><tr><td>
                    <p>
                      WS-SP-EX223_WSS11_Anonymous_X509_Sign_Encrypt
                      
                    </p>
                  </td><td>
                    <p>
                      The group of policy assertions used in the section 2.2.3 example of the WS-Security Policy Examples 1.0 specification
                      
                    </p>
                  </td></tr><tr><td>
                    <p>
                      WS-SP-EX224_WSS11_Mutual_Auth_X509_Sign_Encrypt
                      
                    </p>
                  </td><td>
                    <p>
                      The group of policy assertions used in the section 2.2.4 example of the WS-Security Policy Examples 1.0 specification
                      
                    </p>
                  </td></tr><tr><td>
                    <p>
                      AsymmetricBinding_X509v1_TripleDesRsa15_EncryptBeforeSigning_ProtectTokens
                      
                    </p>
                  </td><td>
                    <p>A WS-Security policy for asymmetric binding (encrypt before signing) using X.509v1 tokens, 3DES + RSA 1.5 algorithms and with token protections enabled</p>
                  </td></tr><tr><td>
                    <p>
                      AsymmetricBinding_X509v1_GCM256OAEP_ProtectTokens
                      
                    </p>
                  </td><td>
                    <p>The same as before, but using custom Apache CXF algorithm suite including GCM 256 + RSA OAEP algorithms</p>
                  </td></tr></tbody></table></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Always verify the contents of the generated wsdl contract, as policy sets are potentially subject to updates between JBossWS releases. This is especially important when dealing with security related policies; the provided sets are to be considered as convenient configuration options only; users remain responsible for the policies in their contracts.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>
              The
              <code class="code">org.jboss.wsf.stack.cxf.extensions.policy.Constants</code>
              interface has convenient String constants for the available policy set labels.
            </p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>If you feel a new set should be added, just propose it by writing the user forum!</p></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sid-83919125"/>5.19. Published WSDL customization</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-83919125_PublishedWSDLcustomization-Endpointaddressrewrite"/>5.19.1. Endpoint address rewrite</h3></div></div></div><p>
          JBossWS supports the rewrite of the
          <code class="code">&lt;soap:address&gt;</code>
          element of endpoints published in WSDL contracts.  This feature is useful for controlling the server address that is advertised to clients for each endpoint. The rewrite mechanism is configured at server level through a set of elements in the webservices subsystem of the WildFly management model. Please refer to the container documentation for details on the options supported in the selected container version. Below is a list of the elements available in the latest WildFly sources:
        </p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>
                  <p>Name</p>
                </th><th>
                  <p>Type</p>
                </th><th>
                  <p>Description</p>
                </th></tr></thead><tbody><tr><td>
                  <p>
                    modify-wsdl-address
                    
                  </p>
                </td><td>
                  <p>boolean</p>
                </td><td>
                  <p>
                    This boolean enables and disables the address rewrite functionality.
                    
                    When modify-wsdl-address is set to true and the content of &lt;soap:address&gt; is a valid URL, JBossWS will rewrite the URL using the values of wsdl-host and wsdl-port or wsdl-secure-port.
                    
                    When modify-wsdl-address is set to false and the content of &lt;soap:address&gt; is a valid URL, JBossWS will not rewrite the URL.  The &lt;soap:address&gt; URL will be used.
                    
                    When the content of &lt;soap:address&gt; is not a valid URL, JBossWS will rewrite it no matter what the setting of modify-wsdl-address.
                    
                    If modify-wsdl-address is set to true and wsdl-host is not defined or explicitly set to
                    <span class="italics">'</span>
                    <code class="code">jbossws.undefined.host</code>
                    _' _ the content of &lt;soap:address&gt; URL is use.  JBossWS uses the requester's host when rewriting the &lt;soap:address&gt;
                    
                    When modify-wsdl-address is not defined JBossWS uses a default value of true.
                    
                  </p>
                </td></tr><tr><td>
                  <p>
                    wsdl-host
                    
                  </p>
                </td><td>
                  <p>string</p>
                </td><td>
                  <p>
                    The hostname / IP address to be used for rewriting
                    <code class="code">&lt;soap:address&gt;</code>
                    .
                    
                    If
                    <code class="code">wsdl-host</code>
                    is set to
                    <code class="code">jbossws.undefined.host</code>
                    , JBossWS uses the requester's host when rewriting the
                    <code class="code">&lt;soap:address&gt;</code>
                    
                    When wsdl-host is not defined JBossWS uses a default value of '
                    <code class="code">jbossws.undefined.host</code>
                    '.
                  </p>
                </td></tr><tr><td>
                  <p>
                    wsdl-port
                    
                  </p>
                </td><td>
                  <p>int</p>
                </td><td>
                  <p>
                    Set this property to explicitly define the HTTP port that will be used for rewriting the SOAP address.
                    
                    Otherwise the HTTP port will be identified by querying the list of installed HTTP connectors.
                  </p>
                </td></tr><tr><td>
                  <p>
                    wsdl-secure-port
                    
                  </p>
                </td><td>
                  <p>int</p>
                </td><td>
                  <p>
                    Set this property to explicitly define the HTTPS port that will be used for rewriting the SOAP address.
                    
                    Otherwise the HTTPS port will be identified by querying the list of installed HTTPS connectors.
                  </p>
                </td></tr><tr><td>
                  <p>wsdl-uri-scheme</p>
                </td><td>
                  <p>
                    string
                    
                  </p>
                </td><td>
                  <p>
                    This property explicitly sets the URI scheme to use for rewriting
                    <code class="code">&lt;soap:address&gt;</code>
                    . Valid values are
                    <code class="code">http</code>
                    and
                    <code class="code">https</code>
                    . This configuration overrides scheme computed by processing the endpoint (even if a transport guarantee
                    
                    is specified). The provided values for
                    <code class="code">wsdl-port</code>
                    and
                    <code class="code">wsdl-secure-port</code>
                    (or their default values) are used depending on specified scheme.
                    
                  </p>
                </td></tr><tr><td>
                  <p>wsdl-path-rewrite-rule</p>
                </td><td>
                  <p>
                    string
                    
                  </p>
                </td><td>
                  <p>
                    This string defines a SED substitution command (e.g., 's/regexp/replacement/g') that JBossWS executes against the path component of each &lt;soap:address&gt; URL published from the server.
                    
                    When wsdl-path-rewrite-rule is not defined, JBossWS retains the original path component of each &lt;soap:address&gt; URL.
                    
                    When 'modify-wsdl-address' is set to "false" this element is ignored.
                  </p>
                </td></tr></tbody></table></div><p>
          Additionally, users can override the server level configuration by requesting a specific rewrite behavior for a given endpoint deployment. That is achieved by setting one of the following properties within a
          <span class="italics">jboss-webservices.xml</span>
          descriptor:
        </p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                  <p>Property</p>
                </th><th>
                  <p>Corresponding server option</p>
                </th></tr></thead><tbody><tr><td>
                  <p>wsdl.soapAddress.rewrite.modify-wsdl-address</p>
                </td><td>
                  <p>modify-wsdl-address</p>
                </td></tr><tr><td>
                  <p>wsdl.soapAddress.rewrite.wsdl-host</p>
                </td><td>
                  <p>wsdl-host</p>
                </td></tr><tr><td>
                  <p>wsdl.soapAddress.rewrite.wsdl-port</p>
                </td><td>
                  <p>wsdl-port</p>
                </td></tr><tr><td>
                  <p>wsdl.soapAddress.rewrite.wsdl-secure-port</p>
                </td><td>
                  <p>wsdl-secure-port</p>
                </td></tr><tr><td>
                  <p>wsdl.soapAddress.rewrite.wsdl-path-rewrite-rule</p>
                </td><td>
                  <p>wsdl-path-rewrite-rule</p>
                </td></tr><tr><td>
                  <p>wsdl.soapAddress.rewrite.wsdl-uri-scheme</p>
                </td><td>
                  <p>wsdl-uri-scheme</p>
                </td></tr></tbody></table></div><p>Here is an example of partial overriding of the default configuration for a specific deployment:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.1" encoding="UTF-8"?&gt;
&lt;webservices version="1.2"
  xmlns="http://www.jboss.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;
  &lt;property&gt;
    &lt;name&gt;wsdl.soapAddress.rewrite.wsdl-uri-scheme&lt;/name&gt;
    &lt;value&gt;https&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;wsdl.soapAddress.rewrite.wsdl-host&lt;/name&gt;
    &lt;value&gt;foo&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sid-83919125_PublishedWSDLcustomization-Systempropertyreferences"/>5.19.2. System property references</h3></div></div></div><p>System property references wrapped within "@" characters are expanded when found in WSDL attribute and element values. This allows for instance including multiple WS-Policy declarations in the contract and selecting the policy to use depending on a server wide system property; here is an example:</p><div class="informalexample"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;wsdl:definitions ...&gt;
  ...
  &lt;wsdl:binding name="ServiceOneSoapBinding" type="tns:EndpointOne"&gt;
    ...
    &lt;wsp:PolicyReference URI="#@org.jboss.wsf.test.JBWS3628TestCase.policy@"/&gt;
    &lt;wsdl:operation name="echo"&gt;
      ...
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="ServiceOne"&gt;
    &lt;wsdl:port binding="tns:ServiceOneSoapBinding" name="EndpointOnePort"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-cxf-jbws3628/ServiceOne"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;

  &lt;wsp:Policy xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsp="http://www.w3.org/ns/ws-policy" wsu:Id="WS-RM_Policy"&gt;
	&lt;wsrmp:RMAssertion xmlns:wsrmp="http://schemas.xmlsoap.org/ws/2005/02/rm/policy"&gt;
          ...
  	&lt;/wsrmp:RMAssertion&gt;
  &lt;/wsp:Policy&gt;

  &lt;wsp:Policy xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsp="http://www.w3.org/ns/ws-policy"
      xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata" wsu:Id="WS-Addressing_policy"&gt;
    &lt;wsam:Addressing&gt;
      &lt;wsp:Policy/&gt;
    &lt;/wsam:Addressing&gt;
  &lt;/wsp:Policy&gt;
&lt;/wsdl:definitions&gt;</pre></div><p>
          If the
          <span class="strong"><strong>
            <span class="italics">org.jboss.wsf.test.JBWS3628TestCase.policy</span>
          </strong></span>
          system property is defined and set to "
          <span class="strong"><strong>
            <span class="italics">WS-Addressing_policy</span>
          </strong></span>
          ", WS-Addressing will be enabled for the endpoint defined by the contract above.
        </p></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="sid-3866751.html"><strong>Prev</strong>Chapter 4. JAX-WS Tools</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="sid-4784150.html"><strong>Next</strong>Chapter 6. JBoss Modules</a></li></ul></body></html>