<!DOCTYPE html>
<html>
    <head>
   <META HTTP-EQUIV='Content-Security-Policy'
         CONTENT="default-src 'none'; object-src 'none'; style-src 'self' https://static.jboss.org ; script-src 'self' https://static.jboss.org ; font-src 'none'; img-src 'self' https://static.jboss.org; base-uri 'none'; form-action 'none'; frame-ancestors 'none' "/>
   <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
   <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <meta name="keywords" content="JBoss Web Services"/>
   <meta name="description" content=""/>
   <meta name="author" content=""/>
   <meta name="robots" content="all"/>
   <meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8"/>

   <title>JBoss Web Services - JBoss Community</title>

   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/theme/css/magnolia/clearspace_common.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/theme/css/magnolia/stkdefault-styles.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/theme/css/common/org_common.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/css/magnolia/styles.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/theme/css/magnolia/jquery-ui.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/theme/css/magnolia/project.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/theme/css/magnolia/wide.css" media="only screen and (min-width: 1200px)" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/css/jbossdeveloper-thin.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/css/rhbar.css" media="screen, projection" />
</head>

    <body id="project" class="col-float3 rightcol-layout">
    <div id="rhbar">
   <a class="jbdevlogo" href="https://developers.redhat.com"></a>
   <a class="rhlogo" href="https://www.redhat.com/"></a>
</div>

<div id="wrapper">
   <div id="maincontent-wrapper">

      <div id="top_subnav_branding">
         <div id="banner">

            <div style="z-index: 999; position: absolute; top: 0px; height:15px;">
            </div>

            <div id="projectname">
               JBoss Web Services
            </div>

            <div id="tagline">Web Services Framework for WildFly</div>

         </div>

         <div id="proj_announce">
            <div id="proj_logo"><h2>JBoss WS</h2></div>
            <div id="proj_tagline"><h3>Web Services Framework for WildFly</h3></div>
         </div>

         <div id="proj_nav" class="">
            <ul class="sf-menu">

               <li class="current">
                  <span class="notch">&nbsp;</span>
                  <a href="/index.html" class="menu-title">Overview</a>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/downloads" class="menu-title">Downloads</a>
                  <ul class="level1">
                     <li class="leaf"><a href="/downloads-latest"> Latest</a></li>
                     <li class="leaf"><a href="/downloads-4x"> 4.x</a></li>
                     <li class="leaf"><a href="/downloads-3x"> 3.x</a></li>
                  </ul>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/docs" class="menu-title">Documentation</a>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/blogs" class="menu-title">Blog</a>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/community" class="menu-title">Community</a>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="https://issues.redhat.com/jira/browse/JBWS" class="menu-title">Issue Tracker</a>
                  <ul class="level1 jiralink">
                     <li class="leaf"><a href="https://issues.redhat.com/jira/browse/JBWS">JIRA</a></li>
                  </ul>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/sourcecode" class="menu-title">Source Code</a>
                  <ul class="level1">
                     <li class="leaf"><a href="https://github.com/jbossws">GitHub</a></li>
                  </ul>
               </li>

               <li id="buildmenu" class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/build" class="menu-title">Build</a>
               </li>
            </ul>
         </div>

      </div>
          <div id="wrapper-2">
         <div id="wrap-content">
            <div id="wrapper-3">
               <div id="main-wrapper">
                  <div id="main">
                     <div id="breadcrumb">
                       <span>
                              <a href="/">JBoss Web Services</a>
                                &gt;
                              <a href="/">Chapter 3 Jax_ws_user_guide</a>
                                &gt;
                              <a href="#"></a>
                       </span>
                     </div><!-- end breadcrumb -->
                     <div class="sect1">
<h2 id="jakarta-xml-web-services-user-guide">Jakarta XML Web Services User Guide</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://jakarta.ee/specifications/xml-web-services/">Jakarta XML Web Services(JAX-WS)</a>
defines the mapping between WSDL and Java
as well as the classes to be used for accessing webservices and
publishing them. JBossWS implements the latest Jakarta XML Web Services specification,
hence users can reference it for any vendor agnostic webservice usage. Below is a brief overview of the most basic functionalities.</p>
</div>
<div class="sect2">
<h3 id="web-service-endpoints">Web Service Endpoints</h3>
<div class="paragraph">
<p>Jakarta XML Web Services simplifies the development model for a web service endpoint. An endpoint implementation bean is annotated with
JAX-WS annotations and deployed to the server. The server automatically
generates and publishes the abstract contract (i.e. wsdl+schema) for
client consumption. All marshalling/unmarshalling is delegated to
<a href="https://jakarta.ee/specifications/xml-binding" class="bare">https://jakarta.ee/specifications/xml-binding</a>[Jakarta XML Binding
(JAXB).</p>
</div>
<div class="sect3">
<h4 id="plain-old-java-object-pojo">Plain old Java Object (POJO)</h4>
<div class="paragraph">
<p>The following is a simple POJO endpoint implementation. All endpoint
associated metadata is provided via
<a href="https://jakarta.ee/specifications/web-services-metadata/">Jakarta Web Service Metadata</a>
 annotations</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class JSEBean01
{
   @WebMethod
   public String echo(String input)
   {
      ...
   }
}</pre>
</div>
</div>
<div class="sect4">
<h5 id="the-endpoint-as-a-web-application">The endpoint as a web application</h5>
<div class="paragraph">
<p>A JAX-WS java service endpoint (JSE) is deployed as a web application.
Here is a sample <em>web.xml</em> descriptor:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;web-app ...&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.jsr181pojo.JSEBean01&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="packaging-the-endpoint">Packaging the endpoint</h5>
<div class="paragraph">
<p>A JSR-181 java service endpoint (JSE) is packaged as a web application
in a <em>war</em> file.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;war warfile="${build.dir}/libs/jbossws-samples-jsr181pojo.war" webxml="${build.resources.dir}/samples/jsr181pojo/WEB-INF/web.xml"&gt;
  &lt;classes dir="${build.dir}/classes"&gt;
    &lt;include name="org/jboss/test/ws/samples/jsr181pojo/JSEBean01.class"/&gt;
  &lt;/classes&gt;
&lt;/war&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Note, only the endpoint implementation bean and web.xml are required.</p>
</div>
</div>
<div class="sect4">
<h5 id="accessing-the-generated-wsdl">Accessing the generated WSDL</h5>
<div class="paragraph">
<p>A successfully deployed service endpoint shows up in the WildFly
management console. The deployed endpoint wsdl address can be found there.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Note, it is also possible to generate the abstract contract offline
using JBossWS tools. For details of that please see Bottom-Up (Java to
WSDL).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ejb3-stateless-session-bean-slsb">EJB3 Stateless Session Bean (SLSB)</h4>
<div class="paragraph">
<p>The JAX-WS programming model supports the same set of annotations on
EJB3 stateless session beans as on POJO endpoints.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@Stateless
@Remote(EJB3RemoteInterface.class)
@RemoteBinding(jndiBinding = "/ejb3/EJB3EndpointInterface")

@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class EJB3Bean01 implements EJB3RemoteInterface
{
   @WebMethod
   public String echo(String input)
   {
      ...
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Above you see an EJB-3.0 stateless session bean that exposes one method
both on the remote interface and as an endpoint operation.</p>
</div>
<div class="sect4">
<h5 id="packaging-the-endpoint-2">Packaging the endpoint</h5>
<div class="paragraph">
<p>A Jakarta Web Service Metadata EJB service endpoint is packaged as an ordinary ejb
deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;jar jarfile="${build.dir}/libs/jbossws-samples-jsr181ejb.jar"&gt;
  &lt;fileset dir="${build.dir}/classes"&gt;
    &lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3Bean01.class"/&gt;
    &lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3RemoteInterface.class"/&gt;
  &lt;/fileset&gt;
&lt;/jar&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="accessing-the-generated-wsdl-2">Accessing the generated WSDL</h5>
<div class="paragraph">
<p>A successfully deployed service endpoint shows up in the WildFly
management console. The deployed endpoint wsdl address can be found there.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Note, it is also possible to generate the abstract contract offline
using JBossWS tools. For details of that please see Bottom-Up (Java to
WSDL).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-provider">Endpoint Provider</h4>
<div class="paragraph">
<p>JAX-WS services typically implement a native Java service endpoint
interface (SEI), perhaps mapped from a WSDL port type, either directly
or via the use of annotations.</p>
</div>
<div class="paragraph">
<p>Java SEIs provide a high level Java-centric abstraction that hides the
details of converting between Java objects and their XML representations
for use in XML-based messages. However, in some cases it is desirable
for services to be able to operate at the XML message level. The
Provider interface offers an alternative to SEIs and may be implemented
by services wishing to work at the XML message level.</p>
</div>
<div class="paragraph">
<p>A Provider based service instances invoke method is called for each
message received for the service.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebServiceProvider(wsdlLocation = "WEB-INF/wsdl/Provider.wsdl")
@ServiceMode(value = Service.Mode.PAYLOAD)
public class ProviderBeanPayload implements Provider&lt;Source&gt;
{
   public Source invoke(Source req)
   {
      // Access the entire request PAYLOAD and return the response PAYLOAD
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Note, <code>Service.Mode.PAYLOAD</code> is the default and does not have to be
declared explicitly. The <code>Service.Mode.MESSAGE</code> can be used to access
the entire SOAP message (i.e. with <code>MESSAGE</code> the Provider can also see
SOAP Headers)</p>
</div>
<div class="paragraph">
<p>The abstract contract for a provider endpoint cannot be
derived/generated automatically. Therefore, it is necessary to specify
the <em>wsdlLocation</em> with the <code>@</code> <code>WebServiceProvider</code> annotation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="web-service-clients">Web Service Clients</h3>
<div class="sect3">
<h4 id="service">Service</h4>
<div class="paragraph">
<p><code>Service</code> is an abstraction that represents a WSDL service. A WSDL
service is a collection of related ports, each of which consists of a
port type bound to a particular protocol and available at a particular
endpoint address.</p>
</div>
<div class="paragraph">
<p>Most clients are started with a set of stubs generated from the
WSDL. One of these will be the service, and you will create objects of
that class in order to work with the service (see "static case" below).</p>
</div>
<div class="sect4">
<h5 id="service-usage">Service Usage</h5>
<div class="sect5">
<h6 id="static-case">Static case</h6>
<div class="paragraph">
<p>Most clients will start with a WSDL file, and generate some stubs using
JBossWS' tool, <em>wsconsume</em> . This usually generates a set of files, one
of which is the top of the tree. This is the service implementation
class.</p>
</div>
<div class="paragraph">
<p>The generated implementation class can be recognized as it will have two
public constructors, one with no arguments and one with two arguments.
The two constructor arguments represent the wsdl location (a <code>java.net.URL</code> ) and the service name
(a <code>javax.xml.namespace.QName</code> ) respectively.</p>
</div>
<div class="paragraph">
<p>Usually the no-argument constructor will be used. In this case the WSDL
location and service name are those found in the WSDL. These are set
implicitly from the <code>@WebServiceClient</code> annotation that decorates the
generated class.</p>
</div>
<div class="paragraph">
<p>The following code snippet shows the generated constructors from the
generated class:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// Generated Service Class

@WebServiceClient(name="StockQuoteService", targetNamespace="http://example.com/stocks", wsdlLocation="http://example.com/stocks.wsdl")
public class StockQuoteService extends jakarta.xml.ws.Service
{
   public StockQuoteService()
   {
      super(new URL("http://example.com/stocks.wsdl"), new QName("http://example.com/stocks", "StockQuoteService"));
   }

   public StockQuoteService(String wsdlLocation, QName serviceName)
   {
      super(wsdlLocation, serviceName);
   }

   ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Section Dynamic Proxy explains how to obtain a port from the service and
how to invoke an operation on the port. If you need to work with the XML
payload directly or with the XML representation of the entire SOAP
message, have a look at <code>Dispatch</code> .</p>
</div>
</div>
<div class="sect5">
<h6 id="dynamic-case">Dynamic case</h6>
<div class="paragraph">
<p>In the dynamic case, when nothing is generated, a web service client
uses <code>Service.create</code> to create Service instances, the following code
illustrates this process.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>URL wsdlLocation = new URL("http://example.org/my.wsdl");
QName serviceName = new QName("http://example.org/sample", "MyService");
Service service = Service.create(wsdlLocation, serviceName);</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="handler-resolver">Handler Resolver</h5>
<div class="paragraph">
<p>JAX-WS provides a flexible plug-in framework for message processing
modules, known as handlers, that may be used to extend the capabilities
of a JAX-WS runtime system. The Handler Framework describes the handler
framework in detail. A Service instance provides access to a
<code>HandlerResolver</code> via a pair of <code>getHandlerResolver</code> /
<code>setHandlerResolver</code> methods that may be used to configure a set of
handlers on a per-service, per-port or per-protocol binding basis.</p>
</div>
<div class="paragraph">
<p>When a Service instance is used to create a proxy or a Dispatch instance
then the handler resolver currently registered with the service is used
to create the required handler chain. Subsequent changes to the handler
resolver configured for a Service instance do not affect the handlers on
previously created proxies, or Dispatch instances.</p>
</div>
</div>
<div class="sect4">
<h5 id="executor">Executor</h5>
<div class="paragraph">
<p>Service instances can be configured with a
<code>java.util.concurrent.Executor</code> . The executor will then be used to
invoke any asynchronous callbacks requested by the application. The
<code>setExecutor</code> and <code>getExecutor</code> methods of <code>Service</code> can be used to
modify and retrieve the executor configured for a service.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-proxy">Dynamic Proxy</h4>
<div class="paragraph">
<p>An instance of a client proxy can be created using one of <code>getPort</code>
methods on the <code>Service</code> .</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/**
 * The getPort method returns a proxy. A service client
 * uses this proxy to invoke operations on the target
 * service endpoint. The &lt;code&gt;serviceEndpointInterface&lt;/code&gt;
 * specifies the service endpoint interface that is supported by
 * the created dynamic proxy instance.
 **/
public &lt;T&gt; T getPort(QName portName, Class&lt;T&gt; serviceEndpointInterface)
{
   ...
}

/**
 * The getPort method returns a proxy. The parameter
 * &lt;code&gt;serviceEndpointInterface&lt;/code&gt; specifies the service
 * endpoint interface that is supported by the returned proxy.
 * In the implementation of this method, the JAX-WS
 * runtime system takes the responsibility of selecting a protocol
 * binding (and a port) and configuring the proxy accordingly.
 * The returned proxy should not be reconfigured by the client.
 *
 **/
public &lt;T&gt; T getPort(Class&lt;T&gt; serviceEndpointInterface)
{
   ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>The service endpoint interface (SEI) is usually generated using tools.
For details see Top Down (WSDL to Java)</p>
</div>
<div class="paragraph">
<p>A generated static Service usually offers typed methods to get
ports. These methods also return dynamic proxies that implement the SEI.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebServiceClient(name = "TestEndpointService", targetNamespace = "http://org.jboss.ws/wsref",
   wsdlLocation = "http://localhost.localdomain:8080/jaxws-samples-webserviceref?wsdl")

public class TestEndpointService extends Service
{
    ...

    public TestEndpointService(URL wsdlLocation, QName serviceName) {
        super(wsdlLocation, serviceName);
    }

    @WebEndpoint(name = "TestEndpointPort")
    public TestEndpoint getTestEndpointPort()
    {
        return (TestEndpoint)super.getPort(TESTENDPOINTPORT, TestEndpoint.class);
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webserviceref">WebServiceRef</h4>
<div class="paragraph">
<p>The <code>@WebServiceRef</code> annotation is used to declare a reference to a Web
service. It follows the resource pattern exemplified by the
<code>jakarta.annotation.Resource</code> annotation in
<a href="https://jakarta.ee/specifications/annotations">Jakarta Annotations</a> .</p>
</div>
<div class="paragraph">
<p>There are two uses to the WebServiceRef annotation:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>To define a reference whose type is a generated service class. In this
case, the type and value element both refer to the generated
service class type. Moreover, if the reference type can be inferred by
the field/method declaration the annotation is applied to, the type and
value elements MAY have the default value (Object.class, that is). If
the type cannot be inferred, then at least the type element MUST be
present with a non-default value.</p>
</li>
<li>
<p>To define a reference whose type is a SEI. In this case, the type
element MAY be present with its default value if the type of the
reference can be inferred from the annotated field/method declaration,
but the value element MUST always be present and refer to a generated
service class type (a subtype of jakarta.xml.ws.Service). The wsdlLocation
element, if present, overrides theWSDL location information specified in
the WebService annotation of the referenced generated service class.</p>
<div class="literalblock">
<div class="content">
<pre>public class EJB3Client implements EJB3Remote
{
   @WebServiceRef
   public TestEndpointService service4;

   @WebServiceRef
   public TestEndpoint port3;</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="webserviceref-customization">WebServiceRef customization</h5>
<div class="paragraph">
<p>A number of overrides and extensions are offered to the WebServiceRef
annotation. These include</p>
</div>
<div class="ulist">
<ul>
<li>
<p>define the port that should be used to resolve a container-managed
port</p>
</li>
<li>
<p>define default Stub property settings for Stub objects</p>
</li>
<li>
<p>define the URL of a final WSDL document to be used Example:</p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="content">
<pre>  &lt;service-ref&gt;
   &lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;
   &lt;wsdl-override&gt;file:/wsdlRepository/organization-service.wsdl&lt;/wsdl-override&gt;
  &lt;/service-ref&gt;

  &lt;service-ref&gt;
   &lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;
   &lt;config-name&gt;Secure Client Config&lt;/config-name&gt;
   &lt;config-file&gt;META-INF/jbossws-client-config.xml&lt;/config-file&gt;
   &lt;handler-chain&gt;META-INF/jbossws-client-handlers.xml&lt;/handler-chain&gt;
  &lt;/service-ref&gt;
 
  &lt;service-ref&gt;
   &lt;service-ref-name&gt;SecureService&lt;/service-ref-name&gt;
   &lt;service-impl-class&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpointService&lt;/service-impl-class&gt;
   &lt;service-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointService&lt;/service-qname&gt;
    &lt;port-component-ref&gt;
     &lt;service-endpoint-interface&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpoint&lt;/service-endpoint-interface&gt;
     &lt;port-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointPort&lt;/port-qname&gt;
     &lt;stub-property&gt;
      &lt;prop-name&gt;jakarta.xml.ws.security.auth.username&lt;/prop-name&gt;
      &lt;prop-value&gt;kermit&lt;/prop-value&gt;
     &lt;/stub-property&gt;
     &lt;stub-property&gt;
      &lt;prop-name&gt;jakarta.xml.ws.security.auth.password&lt;/prop-name&gt;
      &lt;prop-value&gt;thefrog&lt;/prop-value&gt;
     &lt;/stub-property&gt;
   &lt;/port-component-ref&gt;
  &lt;/service-ref&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>For details please see
<em><a href="http://www.jboss.org/j2ee/dtd/service-ref_5_0.dtd">service-ref_5_0.dtd</a></em>
.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dispatch">Dispatch</h4>
<div class="paragraph">
<p>XML Web Services use XML messages for communication between services and
service clients. The higher level JAX-WS APIs are designed to hide the
details of converting between Java method invocations and the
corresponding XML messages, but in some cases operating at the XML
message level is desirable. The Dispatch interface provides support for
this mode of interaction.</p>
</div>
<div class="paragraph">
<p><code>Dispatch</code> supports two usage modes, identified by the constants
<code>jakarta.xml.ws.Service.Mode.MESSAGE</code> and
<code>jakarta.xml.ws.Service.Mode.PAYLOAD</code> respectively:</p>
</div>
<div class="paragraph">
<p><strong><em>Message</em></strong> In this mode, client applications work directly with
protocol-specific message structures. E.g., when used with a SOAP
protocol binding, a client application would work directly with a SOAP
message.</p>
</div>
<div class="paragraph">
<p><strong><em>Message Payload</em></strong> In this mode, client applications work with the
payload of messages rather than the messages themselves. E.g., when used
with a SOAP protocol binding, a client application would work with the
contents of the SOAP Body rather than the SOAP message as a whole.</p>
</div>
<div class="paragraph">
<p>Dispatch is a low level API that requires clients to construct messages
or message payloads as XML and requires an intimate knowledge of the
desired message or payload structure. Dispatch is a generic class that
supports input and output of messages or message payloads of any type.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Service service = Service.create(wsdlURL, serviceName);
Dispatch dispatch = service.createDispatch(portName, StreamSource.class, Mode.PAYLOAD);

String payload = "&lt;ns1:ping xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
dispatch.invokeOneWay(new StreamSource(new StringReader(payload)));

payload = "&lt;ns1:feedback xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
Source retObj = (Source)dispatch.invoke(new StreamSource(new StringReader(payload)));</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="asynchronous-invocations">Asynchronous Invocations</h4>
<div class="paragraph">
<p>The <code>BindingProvider</code> interface represents a component that provides a
protocol binding for use by clients, it is implemented by proxies and is
extended by the <code>Dispatch</code> interface.</p>
</div>
<div class="paragraph">
<p><code>BindingProvider</code> instances may provide asynchronous operation
capabilities. When used, asynchronous operation invocations are
decoupled from the <code>BindingProvider</code> instance at invocation time such
that the response context is not updated when the operation completes.
Instead a separate response context is made available using the
<code>Response</code> interface.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void testInvokeAsync() throws Exception
{
   URL wsdlURL = new URL("http://" + getServerHost() + ":8080/jaxws-samples-asynchronous?wsdl");
   QName serviceName = new QName(targetNS, "TestEndpointService");
   Service service = Service.create(wsdlURL, serviceName);
   TestEndpoint port = service.getPort(TestEndpoint.class);
   Response response = port.echoAsync("Async");
   // access future
   String retStr = (String) response.get();
   assertEquals("Async", retStr);
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oneway-invocations">Oneway Invocations</h4>
<div class="paragraph">
<p><code>@Oneway</code> indicates that the given web method has only an input message
and no output. Typically, a oneway method returns the thread of control
to the calling application prior to executing the actual business
method.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebService (name="PingEndpoint")
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class PingEndpointImpl
{
   private static String feedback;
  
   @WebMethod
   @Oneway
   publicvoid ping()
   {
      log.info("ping");
      feedback = "ok";
   }
  
   @WebMethod
   public String feedback()
   {
      log.info("feedback");
      return feedback;
   }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="timeout-configuration">Timeout Configuration</h4>
<div class="paragraph">
<p>There are two properties to configure the http connection timeout and
client receive time out:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void testConfigureTimeout() throws Exception
{
   //Set timeout until a connection is established
   ((BindingProvider)port).getRequestContext().put("jakarta.xml.ws.client.connectionTimeout", "6000");

   //Set timeout until the response is received
   ((BindingProvider) port).getRequestContext().put("jakarta.xml.ws.client.receiveTimeout", "1000");

   port.echo("testTimeout");
}</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="common-api">Common API</h3>
<div class="paragraph">
<p>This sections describes concepts that apply equally to Web Service
Endpoints and Web Service Clients.</p>
</div>
<div class="sect3">
<h4 id="handler-framework">Handler Framework</h4>
<div class="paragraph">
<p>The handler framework is implemented by a JAX-WS protocol binding in
both client and server side runtimes. Proxies, and Dispatch instances,
known collectively as binding providers, each use protocol bindings to
bind their abstract functionality to specific protocols.</p>
</div>
<div class="paragraph">
<p>Client and server-side handlers are organized into an ordered list known
as a handler chain. The handlers within a handler chain are invoked each
time a message is sent or received. Inbound messages are processed by
handlers prior to binding provider processing. Outbound messages are
processed by handlers after any binding provider processing.</p>
</div>
<div class="paragraph">
<p>Handlers are invoked with a message context that provides methods to
access and modify inbound and outbound messages and to manage a set of
properties. Message context properties may be used to facilitate
communication between individual handlers and between handlers and
client and service implementations. Different types of handlers are
invoked with different types of message context.</p>
</div>
<div class="sect4">
<h5 id="logical-handler">Logical Handler</h5>
<div class="paragraph">
<p>Handlers that only operate on message context properties and message
payloads. Logical handlers are protocol agnostic and are unable to
affect protocol specific parts of a message. Logical handlers are
handlers that implement <code>jakarta.xml.ws.handler.LogicalHandler</code> .</p>
</div>
</div>
<div class="sect4">
<h5 id="protocol-handler">Protocol Handler</h5>
<div class="paragraph">
<p>Handlers that operate on message context properties and protocol
specific messages. Protocol handlers are specific to a particular
protocol and may access and change protocol specific aspects of a
message. Protocol handlers are handlers that implement any interface
derived from <code>jakarta.xml.ws.handler.Handler</code> except
<code>jakarta.xml.ws.handler.LogicalHandler</code> .</p>
</div>
</div>
<div class="sect4">
<h5 id="service-endpoint-handlers">Service endpoint handlers</h5>
<div class="paragraph">
<p>On the service endpoint, handlers are defined using the <code>@HandlerChain</code>
annotation.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebService
@HandlerChain(file = "jaxws-server-source-handlers.xml")
public class SOAPEndpointSourceImpl
{
   ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>The location of the handler chain file supports 2 formats</p>
</div>
<div class="paragraph">
<p>1. An absolute java.net.URL in externalForm. (ex:
<a href="http://myhandlers.foo.com/handlerfile1.xml" class="bare">http://myhandlers.foo.com/handlerfile1.xml</a> )</p>
</div>
<div class="paragraph">
<p>2. A relative path from the source file or class file. (ex:
bar/handlerfile1.xml)</p>
</div>
</div>
<div class="sect4">
<h5 id="service-client-handlers">Service client handlers</h5>
<div class="paragraph">
<p>On the client side, handler can be configured using the <code>@HandlerChain</code>
annotation on the SEI or dynamically using the API.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Service service = Service.create(wsdlURL, serviceName);
Endpoint port = (Endpoint)service.getPort(Endpoint.class);
     
BindingProvider bindingProvider = (BindingProvider)port;
List&lt;Handler&gt; handlerChain = new ArrayList&lt;Handler&gt;();
handlerChain.add(new LogHandler());
handlerChain.add(new AuthorizationHandler());
handlerChain.add(new RoutingHandler());
bindingProvider.getBinding().setHandlerChain(handlerChain); // important!</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="message-context">Message Context</h4>
<div class="paragraph">
<p><code>MessageContext</code> is the super interface for all JAX-WS message contexts.
It extends <code>Map&lt;String,Object&gt;</code> with additional methods and constants to
manage a set of properties that enable handlers in a handler chain to
share processing related state. For example, a handler may use the put
method to insert a property in the message context that one or more
other handlers in the handler chain may subsequently obtain via the get
method.</p>
</div>
<div class="paragraph">
<p>Properties are scoped as either APPLICATION or HANDLER. All properties
are available to all handlers for an instance of an MEP on a particular
endpoint. E.g., if a logical handler puts a property in the message
context, that property will also be available to any protocol handlers
in the chain during the execution of an MEP instance. APPLICATION scoped
properties are also made available to client applications (see section
4.2.1) and service endpoint implementations. The defaultscope for a
property is HANDLER.</p>
</div>
<div class="sect4">
<h5 id="logical-message-context">Logical Message Context</h5>
<div class="paragraph">
<p>Logical Handlers are passed a message context of type
<code>LogicalMessageContext</code> when invoked. <code>LogicalMessageContext</code> extends
<code>MessageContext</code> with methods to obtain and modify the message payload,
it does not provide access to the protocol specific aspects of amessage.
A protocol binding defines what component of a message are available via
a logical message context. The SOAP binding defines that a logical
handler deployed in a SOAP binding can access the contents of the SOAP
body but not the SOAP headers whereas the XML/HTTP binding defines that
a logical handler can access the entire XML payload of a message.</p>
</div>
</div>
<div class="sect4">
<h5 id="soap-message-context">SOAP Message Context</h5>
<div class="paragraph">
<p>SOAP handlers are passed a <code>SOAPMessageContext</code> when invoked.
<code>SOAPMessageContext</code> extends <code>MessageContext</code> with methods to obtain and
modify the SOAP message payload.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fault-handling">Fault Handling</h4>
<div class="paragraph">
<p>An implementation may throw a <code>SOAPFaultException</code></p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void throwSoapFaultException()
{
   SOAPFactory factory = SOAPFactory.newInstance();
   SOAPFault fault = factory.createFault("this is a fault string!", new QName("http://foo", "FooCode"));
   fault.setFaultActor("mr.actor");
   fault.addDetail().addChildElement("test");
   thrownew SOAPFaultException(fault);
}</pre>
</div>
</div>
<div class="paragraph">
<p>or an application specific user exception</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void throwApplicationException() throws UserException
{
   thrownew UserException("validation", 123, "Some validation error");
}</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>In case of the latter, JBossWS generates the required fault wrapper
beans at runtime if they are not part of the deployment</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ws-annotations">WS Annotations</h3>
<div class="paragraph">
<p>For details, see <a href="https://jakarta.ee/specifications/xml-web-services/">Jakarta XML Web Services</a></p>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-servicemode">jakarta.xml.ws.ServiceMode</h4>
<div class="paragraph">
<p>The <code>ServiceMode</code> annotation is used to specify the mode for a provider
class, i.e. whether a provider wants to have access to protocol message
payloads (e.g. a SOAP body) or the entire protocol messages (e.g. a SOAP
envelope).</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webfault">jakarta.xml.ws.WebFault</h4>
<div class="paragraph">
<p>The <code>WebFault</code> annotation is used when mapping WSDL faults to Java
exceptions, see section 2.5. It is used to capture the name of the fault
element used when marshalling the JAXB type generated from the global
element referenced by the WSDL fault message. It can also be used to
customize the mapping of service specific exceptions to WSDL faults.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-requestwrapper">jakarta.xml.ws.RequestWrapper</h4>
<div class="paragraph">
<p>The <code>RequestWrapper</code> annotation is applied to the methods of an SEI. It
is used to capture the JAXB generated request wrapper bean and the
element name and namespace for marshalling / unmarshalling the bean. The
default value of localName element is the operationName as defined in
<code>WebMethod</code> annotation and the default value for the targetNamespace
element is the target namespace of the SEI.When starting from Java, this
annotation is used to resolve overloading conflicts in document literal
mode. Only the className element is required in this case.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-responsewrapper">jakarta.xml.ws.ResponseWrapper</h4>
<div class="paragraph">
<p>The <code>ResponseWrapper</code> annotation is applied to the methods of an SEI. It
is used to capture the JAXB generated response wrapper bean and the
element name and namespace for marshalling / unmarshalling the bean. The
default value of the localName element is the operationName as defined
in the <code>WebMethod</code> appended with ”Response” and the default value of the
targetNamespace element is the target namespace of the SEI. When
starting from Java, this annotation is used to resolve overloading
conflicts in document literal mode. Only the className element is
required in this case.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webserviceclient">jakarta.xml.ws.WebServiceClient</h4>
<div class="paragraph">
<p>The <code>WebServiceClient</code> annotation is specified on a generated service
class (see 2.7). It is used to associate a class with a specific Web
service, identify by a URL to a WSDL document and the qualified name of
a wsdl:service element.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webendpoint">jakarta.xml.ws.WebEndpoint</h4>
<div class="paragraph">
<p>The <code>WebEndpoint</code> annotation is specified on the getPortName() methods
of a generated service class (see 2.7). It is used to associate a get
method with a specific wsdl:port, identified by its local name (a
NCName).</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webserviceprovider">jakarta.xml.ws.WebServiceProvider</h4>
<div class="paragraph">
<p>The <code>WebServiceProvider</code> annotation is specified on classes that
implement a strongly typed <code>jakarta.xml.ws.Provider</code> . It is used to
declare that a class that satisfies the requirements for a provider (see
5.1) does indeed define a Web service endpoint, much like the
<code>WebService</code> annotation does for SEI-based endpoints.</p>
</div>
<div class="paragraph">
<p>The <code>WebServiceProvider</code> and <code>WebService</code> annotations are mutually
exclusive.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-bindingtype">jakarta.xml.ws.BindingType</h4>
<div class="paragraph">
<p>The <code>BindingType</code> annotation is applied to an endpoint implementation
class. It specifies the binding to use when publishing an endpoint of
this type.</p>
</div>
<div class="paragraph">
<p>The default binding for an endpoint is the SOAP 1.1/HTTP one.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webserviceref">jakarta.xml.ws.WebServiceRef</h4>
<div class="paragraph">
<p>The <code>WebServiceRef</code> annotation is used to declare a reference to a Web
service. It follows the resource pattern exemplified by the
<code>jakarta.annotation.Resource</code> annotation in Jakarta Annotations [32]. The
<code>WebServiceRef</code> annotation is required to be honored when running on the
JakartaEE platform, where it is subject to the common resource injection
rules described by the platform specification [33].</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webservicerefs">jakarta.xml.ws.WebServiceRefs</h4>
<div class="paragraph">
<p>The <code>WebServiceRefs</code> annotation is used to declare multiple references
to Web services on a single class. It is necessary to work around the
limitation against specifying repeated annotations of the same type on any
given class, which prevents listing multiple <code>javax.ws.WebServiceRef</code>
annotations one after the other. This annotation follows the resource
pattern exemplified by the <code>javax.annotation.Resources</code> annotation in
JSR-250.</p>
</div>
<div class="paragraph">
<p>Since no name and type can be inferred in this case, each
<code>WebServiceRef</code> annotation inside a WebServiceRefs MUST contain name and
type elements with non-default values. The <code>WebServiceRef</code> annotation is
required to be honored when running on the Java EE 5 platform, where it
is subject to the common resource injection rules described by the
platform specification.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-action">jakarta.xml.ws.Action</h4>
<div class="paragraph">
<p>The <code>Action</code> annotation is applied to the methods of a SEI. It used to
generate the wsa:Action on wsdl:input and wsdl:output of each
wsdl:operation mapped from the annotated methods.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-faultaction">jakarta.xml.ws.FaultAction</h4>
<div class="paragraph">
<p>The <code>FaultAction</code> annotation is used within the <code>Action</code> annotation to
generate the wsa:Action element on the wsdl:fault element of each
wsdl:operation mapped from the annotated methods.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jakarta-web-service-metadata-annotations">Jakarta Web Service Metadata Annotations</h3>
<div class="paragraph">
<p>Jakarta Web Service Metadata defines the syntax and semantics of JAX-WS
metadata and default values.</p>
</div>
<div class="paragraph">
<p>For details, see <a href="https://jakarta.ee/specifications/web-services-metadata/">Jakarta Web Service
Metadata</a> .</p>
</div>
<div class="sect3">
<h4 id="jakarta-jws-webservice">jakarta.jws.WebService</h4>
<div class="paragraph">
<p>Marks a Java class as implementing a Web Service, or a Java interface as
defining a Web Service interface.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-webmethod">jakarta.jws.WebMethod</h4>
<div class="paragraph">
<p>Customizes a method that is exposed as a Web Service operation.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-oneway">jakarta.jws.OneWay</h4>
<div class="paragraph">
<p>Indicates that the given web method has only an input message and no
output. Typically, a oneway method returns the thread of control to the
calling application prior to executing the actual business method. A
JSR-181 processor is REQUIRED to report an error if an operation marked
<code>@Oneway</code> has a return value, declares any checked exceptions or has any
INOUT or OUT parameters.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-webparam">jakarta.jws.WebParam</h4>
<div class="paragraph">
<p>Customizes the mapping of an individual parameter to a Web Service
message part and XML element.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-webresult">jakarta.jws.WebResult</h4>
<div class="paragraph">
<p>Customizes the mapping of the return value to a WSDL part and XML
element.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-soapbinding">jakarta.jws.SOAPBinding</h4>
<div class="paragraph">
<p>Specifies the mapping of the Web Service onto the SOAP message protocol.</p>
</div>
<div class="paragraph">
<p>The <code>SOAPBinding</code> annotation has a target of <code>TYPE</code> and <code>METHOD</code> . The
annotation may be placed on a method if and only if the
<code>SOAPBinding.style</code> is <code>DOCUMENT</code> . Implementations MUST report an error
if the <code>SOAPBinding</code> annotation is placed on a method with a
<code>SOAPBinding.style</code> of <code>RPC</code> . Methods that do not have a <code>SOAPBinding</code>
annotation accept the <code>SOAPBinding</code> behavior defined on the type.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-handlerchain">jakarta.jws.HandlerChain</h4>
<div class="paragraph">
<p>The <code>@HandlerChain</code> annotation associates the Web Service with an
externally defined handler chain.</p>
</div>
<div class="paragraph">
<p>It is an error to combine this annotation with the
<code>@SOAPMessageHandlers</code> annotation.</p>
</div>
<div class="paragraph">
<p>The <code>@HandlerChain</code> annotation MAY be present on the endpoint interface
and service implementation bean. The service implementation bean&#8217;s
<code>@HandlerChain</code> is used if <code>@HandlerChain</code> is present on both.</p>
</div>
<div class="paragraph">
<p>The <code>@HandlerChain</code> annotation MAY be specified on the type only. The
annotation target includes <code>METHOD</code> and <code>FIELD</code> for use by JAX-WS-2.x.</p>
</div>
</div>
</div>
</div>
</div>

                  </div><!-- end main -->
               </div>

    <div id="rightcolumn" class="column">

    <div class="projectpage-socialmedia">
        <span class="st_sharethis_large">&nbsp;</span>
        <span class="st_facebook_large">&nbsp;</span>
        <span class="st_twitter_large">&nbsp;</span>
        <span class="st_linkedin_large">&nbsp;</span>
        <span class="st_email_large">&nbsp;</span>
    </div>


    <div id="proj_quick-start">
        <h3>Useful Links</h3>
        <ul>
            <li><a href="/downloads-latest/">Download</a></li>
            <li><a href="/docs">Documentation</a></li>
            <li><a href="/blogs">Blog</a></li>
            <li><a href="https://issues.redhat.com/browse/JBWS">JIRA</a></li>
            <li><a href="https://github.com/jbossws">Code</a></li>
            <li><a href="https://github.com/jbossws/jbossws-cxf/discussions">Discussion</a></li>
        </ul>
    </div>

    <div class="clear"><br/></div>

    <div class="uploaded-img">

        <a href="https://www.ej-technologies.com/products/jprofiler/overview.html">

            <img width="180" alt="" height="75"
                 src="/img/logo_jprofiler01.gif"
                 style="margin:0 auto;"/>

        </a>
    </div>

    <h5>We use JProfiler for profiling</h5>

    <table>
        <tr>
            <td>
            </td>
        </tr>
    </table>


    <div>
        <a href="https://www.jboss.org/security.html">
            <div class="projectpage-sprite projectpage-sprite-securityimage">&nbsp;</div>
        </a>
    </div>
</div>

</div><!-- end wrapper-3 -->

</div><!-- end wrapper-content -->
<div style="clear: both;"></div>
</div><!-- end wrapper-2 -->
</div>
       <div id="site-info">
      <div>
      </div>

      <div class="footer">
         <div class="container" id="companyfooter">
            <div class="redhatlogo" style="text-align:center;">
               <div id="logospacer"></div>
               <a href="https://www.redhat.com/">
                  <img src="https://static.jboss.org/images/rhbar/redhatlogo.png">
               </a>
            </div>
         </div>
      </div>
   </div><!-- end site-info -->
</div><!-- end wrapper -->

    </body>
</html>
