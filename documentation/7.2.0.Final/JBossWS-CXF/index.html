<!DOCTYPE html>
<html>
    <head>
   <META HTTP-EQUIV='Content-Security-Policy'
         CONTENT="default-src 'none'; object-src 'none'; style-src 'self' https://static.jboss.org ; script-src 'self' https://static.jboss.org ; font-src 'none'; img-src 'self' https://static.jboss.org; base-uri 'none'; form-action 'none'; frame-ancestors 'none' "/>
   <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
   <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <meta name="keywords" content="JBoss Web Services"/>
   <meta name="description" content=""/>
   <meta name="author" content=""/>
   <meta name="robots" content="all"/>
   <meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8"/>

   <title>JBoss Web Services - JBoss Community</title>

   <link rel="stylesheet" type="text/css" href="/css/clearspace_common.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="/css/stkdefault-styles.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/theme/css/common/org_common.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/css/magnolia/styles.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/theme/css/magnolia/jquery-ui.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/theme/css/magnolia/project.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/theme/css/magnolia/wide.css" media="only screen and (min-width: 1200px)" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/css/jbossdeveloper-thin.css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="https://static.jboss.org/css/rhbar.css" media="screen, projection" />
</head>

    <body id="project" class="col-float3 rightcol-layout">
    <div id="rhbar">
   <a class="jbdevlogo" href="https://developers.redhat.com"></a>
   <a class="rhlogo" href="https://www.redhat.com/"></a>
</div>

<div id="wrapper">
   <div id="maincontent-wrapper">

      <div id="top_subnav_branding">
         <div id="banner">

            <div style="z-index: 999; position: absolute; top: 0px; height:15px;">
            </div>

            <div id="projectname">
               JBoss Web Services
            </div>

            <div id="tagline">Web Services Framework for WildFly</div>

         </div>

         <div id="proj_announce">
            <div id="proj_logo"><h2>JBoss WS</h2></div>
            <div id="proj_tagline"><h3>Web Services Framework for WildFly</h3></div>
         </div>

         <div id="proj_nav" class="">
            <ul class="sf-menu">

               <li class="current">
                  <span class="notch">&nbsp;</span>
                  <a href="/index.html" class="menu-title">Overview</a>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/downloads" class="menu-title">Downloads</a>
                  <ul class="level1">
                     <li class="leaf"><a href="/downloads-latest"> Latest</a></li>
                     <li class="leaf"><a href="/downloads-4x"> 4.x</a></li>
                     <li class="leaf"><a href="/downloads-3x"> 3.x</a></li>
                  </ul>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/docs" class="menu-title">Documentation</a>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/blogs" class="menu-title">Blog</a>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/community" class="menu-title">Community</a>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="https://issues.redhat.com/projects/JBWS/issues" class="menu-title">Issue Tracker</a>
                  <ul class="level1 jiralink">
                     <li class="leaf"><a href="https://issues.redhat.com/projects/JBWS/issues">JIRA</a></li>
                  </ul>
               </li>

               <li class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/sourcecode" class="menu-title">Source Code</a>
                  <ul class="level1">
                     <li class="leaf"><a href="https://github.com/jbossws">GitHub</a></li>
                  </ul>
               </li>

               <li id="buildmenu" class="open">
                  <span class="notch">&nbsp;</span>
                  <a href="/build" class="menu-title">Build</a>
               </li>
            </ul>
         </div>

      </div>
          <div id="wrapper-2">
         <div id="wrap-content">
            <div id="wrapper-3">
               <div id="main-wrapper">
                  <div id="main">
                     <div id="breadcrumb">
                       <span>
                              <a href="/">JBoss Web Services</a>
                                &gt;
                              <a href="/docs">JBossWS Documentation</a>
                                &gt;
                              <a href="#">7.2.0.Final</a>
                       </span>
                     </div><!-- end breadcrumb -->
                     <div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#preface-JBoss_Web_Services_Documentation">Preface</a>
<ul class="sectlevel1">
<li><a href="#web-services-introduction">1. Web Services Introduction</a>
<ul class="sectlevel2">
<li><a href="#what-is-a-web-service">1.1. What is a web service?</a>
<ul class="sectlevel3">
<li><a href="#who-needs-web-services">1.1.1. Who needs web services?</a></li>
<li><a href="#what-web-services-are-not">1.1.2. What web services are not&#8230;&#8203;</a></li>
</ul>
</li>
<li><a href="#from-concepts-to-technology">1.2. From concepts to technology</a>
<ul class="sectlevel3">
<li><a href="#service-contracts">1.2.1. Service contracts</a></li>
<li><a href="#message-exchange">1.2.2. Message exchange</a></li>
<li><a href="#advanced-web-services-technologies">1.2.3. Advanced Web Services technologies</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#quick-start">2. Quick Start</a>
<ul class="sectlevel2">
<li><a href="#developing-web-service-implementations">2.1. Developing web service implementations</a>
<ul class="sectlevel3">
<li><a href="#the-service-implementation-class">2.1.1. The service implementation class</a></li>
<li><a href="#deploying-service-implementations">2.1.2. Deploying service implementations</a></li>
</ul>
</li>
<li><a href="#consuming-web-services">2.2. Consuming web services</a>
<ul class="sectlevel3">
<li><a href="#creating-the-client-artifacts">2.2.1. Creating the client artifacts</a></li>
<li><a href="#constructing-a-service-stub">2.2.2. Constructing a service stub</a></li>
<li><a href="#resolving-dependencies-and-running-the-client">2.2.3. Resolving dependencies and running the client</a></li>
</ul>
</li>
<li><a href="#maven-archetype-quick-start">2.3. Maven archetype quick start</a></li>
<li><a href="#appendix">2.4. Appendix</a>
<ul class="sectlevel3">
<li><a href="#sample-wsdl-contract">2.4.1. Sample wsdl contract</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jakarta-xml-web-services-user-guide">3. Jakarta XML Web Services User Guide</a>
<ul class="sectlevel2">
<li><a href="#web-service-endpoints">3.1. Web Service Endpoints</a>
<ul class="sectlevel3">
<li><a href="#plain-old-java-object-pojo">3.1.1. Plain old Java Object (POJO)</a></li>
<li><a href="#ejb3-stateless-session-bean-slsb">3.1.2. EJB3 Stateless Session Bean (SLSB)</a></li>
<li><a href="#endpoint-provider">3.1.3. Endpoint Provider</a></li>
</ul>
</li>
<li><a href="#web-service-clients">3.2. Web Service Clients</a>
<ul class="sectlevel3">
<li><a href="#service">3.2.1. Service</a></li>
<li><a href="#dynamic-proxy">3.2.2. Dynamic Proxy</a></li>
<li><a href="#webserviceref">3.2.3. WebServiceRef</a></li>
<li><a href="#dispatch">3.2.4. Dispatch</a></li>
<li><a href="#asynchronous-invocations">3.2.5. Asynchronous Invocations</a></li>
<li><a href="#oneway-invocations">3.2.6. Oneway Invocations</a></li>
<li><a href="#timeout-configuration">3.2.7. Timeout Configuration</a></li>
<li><a href="#http2-support">3.2.8. HTTP/2 Support</a></li>
</ul>
</li>
<li><a href="#common-api">3.3. Common API</a>
<ul class="sectlevel3">
<li><a href="#handler-framework">3.3.1. Handler Framework</a></li>
<li><a href="#message-context">3.3.2. Message Context</a></li>
<li><a href="#fault-handling">3.3.3. Fault Handling</a></li>
</ul>
</li>
<li><a href="#ws-annotations">3.4. WS Annotations</a>
<ul class="sectlevel3">
<li><a href="#jakarta-xml-ws-servicemode">3.4.1. jakarta.xml.ws.ServiceMode</a></li>
<li><a href="#jakarta-xml-ws-webfault">3.4.2. jakarta.xml.ws.WebFault</a></li>
<li><a href="#jakarta-xml-ws-requestwrapper">3.4.3. jakarta.xml.ws.RequestWrapper</a></li>
<li><a href="#jakarta-xml-ws-responsewrapper">3.4.4. jakarta.xml.ws.ResponseWrapper</a></li>
<li><a href="#jakarta-xml-ws-webserviceclient">3.4.5. jakarta.xml.ws.WebServiceClient</a></li>
<li><a href="#jakarta-xml-ws-webendpoint">3.4.6. jakarta.xml.ws.WebEndpoint</a></li>
<li><a href="#jakarta-xml-ws-webserviceprovider">3.4.7. jakarta.xml.ws.WebServiceProvider</a></li>
<li><a href="#jakarta-xml-ws-bindingtype">3.4.8. jakarta.xml.ws.BindingType</a></li>
<li><a href="#jakarta-xml-ws-webserviceref">3.4.9. jakarta.xml.ws.WebServiceRef</a></li>
<li><a href="#jakarta-xml-ws-webservicerefs">3.4.10. jakarta.xml.ws.WebServiceRefs</a></li>
<li><a href="#jakarta-xml-ws-action">3.4.11. jakarta.xml.ws.Action</a></li>
<li><a href="#jakarta-xml-ws-faultaction">3.4.12. jakarta.xml.ws.FaultAction</a></li>
</ul>
</li>
<li><a href="#jakarta-web-service-metadata-annotations">3.5. Jakarta Web Service Metadata Annotations</a>
<ul class="sectlevel3">
<li><a href="#jakarta-jws-webservice">3.5.1. jakarta.jws.WebService</a></li>
<li><a href="#jakarta-jws-webmethod">3.5.2. jakarta.jws.WebMethod</a></li>
<li><a href="#jakarta-jws-oneway">3.5.3. jakarta.jws.OneWay</a></li>
<li><a href="#jakarta-jws-webparam">3.5.4. jakarta.jws.WebParam</a></li>
<li><a href="#jakarta-jws-webresult">3.5.5. jakarta.jws.WebResult</a></li>
<li><a href="#jakarta-jws-soapbinding">3.5.6. jakarta.jws.SOAPBinding</a></li>
<li><a href="#jakarta-jws-handlerchain">3.5.7. jakarta.jws.HandlerChain</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jax-ws-tools">4. JAX-WS Tools</a>
<ul class="sectlevel2">
<li><a href="#server-side">4.1. Server side</a>
<ul class="sectlevel3">
<li><a href="#bottom-up-using-wsprovide">4.1.1. Bottom-Up (Using wsprovide)</a></li>
<li><a href="#down-using-wsconsume">4.1.2. Down (Using wsconsume)</a></li>
</ul>
</li>
<li><a href="#client-side">4.2. Client Side</a></li>
<li><a href="#ws-binding-customization">4.3. WS binding customization</a></li>
<li><a href="#wsconsume">4.4. wsconsume</a>
<ul class="sectlevel3">
<li><a href="#command-line-tool">4.4.1. Command Line Tool</a></li>
<li><a href="#maven-plugin">4.4.2. Maven Plugin</a></li>
<li><a href="#ant-task">4.4.3. Ant Task</a></li>
</ul>
</li>
<li><a href="#wsprovide">4.5. wsprovide</a>
<ul class="sectlevel3">
<li><a href="#command-line-tool-2">4.5.1. Command Line Tool</a></li>
<li><a href="#maven-plugin-2">4.5.2. Maven Plugin</a></li>
<li><a href="#ant-task-2">4.5.3. Ant Task</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#advanced-user-guide">5. Advanced User Guide</a>
<ul class="sectlevel2">
<li><a href="#logging">5.1. Logging</a>
<ul class="sectlevel3">
<li><a href="#jax-ws-handler-approach">5.1.1. JAX-WS Handler approach</a></li>
<li><a href="#apache-cxf-approach">5.1.2. Apache CXF approach</a></li>
</ul>
</li>
<li><a href="#ws-support">5.2. WS-* support</a></li>
<li><a href="#address-rewrite">5.3. Address rewrite</a>
<ul class="sectlevel3">
<li><a href="#server-configuration-options">5.3.1. Server configuration options</a></li>
<li><a href="#dynamic-rewrite">5.3.2. Dynamic rewrite</a></li>
</ul>
</li>
<li><a href="#configuration-through-deployment-descriptor">5.4. Configuration through deployment descriptor</a>
<ul class="sectlevel3">
<li><a href="#context-root-element">5.4.1. context-root element</a></li>
<li><a href="#config-name-and-config-file-elements">5.4.2. config-name and config-file elements</a></li>
<li><a href="#property-element">5.4.3. property element</a></li>
<li><a href="#component-element">5.4.4. component element</a></li>
<li><a href="#webservice-description-element">5.4.5. webservice-description element</a></li>
</ul>
</li>
<li><a href="#schema-validation-of-soap-messages">5.5. Schema validation of SOAP messages</a></li>
<li><a href="#jaxb-introductions">5.6. JAXB Introductions</a></li>
<li><a href="#wsdl-system-properties-expansion">5.7. WSDL system properties expansion</a></li>
<li><a href="#predefined-client-and-endpoint-configurations">5.8. Predefined client and endpoint configurations</a>
<ul class="sectlevel3">
<li><a href="#overview">5.8.1. Overview</a></li>
<li><a href="#assigning-configurations">5.8.2. Assigning configurations</a></li>
</ul>
</li>
<li><a href="#authentication">5.9. Authentication</a>
<ul class="sectlevel3">
<li><a href="#authentication-2">5.9.1. Authentication</a></li>
</ul>
</li>
<li><a href="#apache-cxf-integration">5.10. Apache CXF integration</a>
<ul class="sectlevel3">
<li><a href="#jbossws-integration-layer-with-apache-cxf">5.10.1. JBossWS integration layer with Apache CXF</a></li>
<li><a href="#building-ws-applications-the-jboss-way">5.10.2. Building WS applications the JBoss way</a></li>
<li><a href="#bus-usage">5.10.3. Bus usage</a></li>
<li><a href="#server-side-integration-customization">5.10.4. Server Side Integration Customization</a></li>
<li><a href="#apache-cxf-interceptors">5.10.5. Apache CXF interceptors</a></li>
<li><a href="#apache-cxf-features">5.10.6. Apache CXF features</a></li>
<li><a href="#properties-driven-bean-creation">5.10.7. Properties driven bean creation</a></li>
<li><a href="#httpconduit-configuration">5.10.8. HTTPConduit configuration</a></li>
</ul>
</li>
<li><a href="#addressing">5.11. Addressing</a>
<ul class="sectlevel3">
<li><a href="#enabling-ws-addressing">5.11.1. Enabling WS-Addressing</a></li>
<li><a href="#addressing-policy">5.11.2. Addressing Policy</a></li>
<li><a href="#example">5.11.3. Example</a></li>
</ul>
</li>
<li><a href="#ws-security">5.12. WS-Security</a>
<ul class="sectlevel3">
<li><a href="#ws-security-overview">5.12.1. WS-Security overview</a></li>
<li><a href="#jboss-ws-security-support">5.12.2. JBoss WS-Security support</a></li>
<li><a href="#examples-7">5.12.3. Examples</a></li>
</ul>
</li>
<li><a href="#ws-trust-and-sts">5.13. WS-Trust and STS</a>
<ul class="sectlevel3">
<li><a href="#ws-trust-overview">5.13.1. WS-Trust overview</a></li>
<li><a href="#security-token-service">5.13.2. Security Token Service</a></li>
<li><a href="#apache-cxf-support">5.13.3. Apache CXF support</a></li>
<li><a href="#a-basic-ws-trust-scenario">5.13.4. A Basic WS-Trust Scenario</a></li>
<li><a href="#actas-ws-trust-scenario">5.13.5. ActAs WS-Trust Scenario</a></li>
<li><a href="#onbehalfof-ws-trust-scenario">5.13.6. OnBehalfOf WS-Trust Scenario</a></li>
<li><a href="#saml-bearer-assertion-scenario">5.13.7. SAML Bearer Assertion Scenario</a></li>
<li><a href="#saml-holder-of-key-assertion-scenario">5.13.8. SAML Holder-Of-Key Assertion Scenario</a></li>
</ul>
</li>
<li><a href="#ws-reliable-messaging">5.14. WS-Reliable Messaging</a>
<ul class="sectlevel3">
<li><a href="#enabling-ws-reliable-messaging">5.14.1. Enabling WS-Reliable Messaging</a></li>
<li><a href="#example-2">5.14.2. Example</a></li>
</ul>
</li>
<li><a href="#soap-over-jms">5.15. SOAP over JMS</a>
<ul class="sectlevel3">
<li><a href="#configuring-soap-over-jms">5.15.1. Configuring SOAP over JMS</a></li>
<li><a href="#examples-8">5.15.2. Examples</a></li>
</ul>
</li>
<li><a href="#http-proxy">5.16. HTTP Proxy</a>
<ul class="sectlevel3">
<li><a href="#configuration">5.16.1. Configuration</a></li>
</ul>
</li>
<li><a href="#ws-discovery">5.17. WS-Discovery</a>
<ul class="sectlevel3">
<li><a href="#enabling-ws-discovery">5.17.1. Enabling WS-Discovery</a></li>
<li><a href="#probing-services">5.17.2. Probing services</a></li>
</ul>
</li>
<li><a href="#ws-policy">5.18. WS-Policy</a>
<ul class="sectlevel3">
<li><a href="#apache-cxf-ws-policy-support">5.18.1. Apache CXF WS-Policy support</a></li>
<li><a href="#jbossws-additions">5.18.2. JBossWS additions</a></li>
</ul>
</li>
<li><a href="#published-wsdl-customization">5.19. Published WSDL customization</a>
<ul class="sectlevel3">
<li><a href="#endpoint-address-rewrite">5.19.1. Endpoint address rewrite</a></li>
<li><a href="#system-property-references">5.19.2. System property references</a></li>
</ul>
</li>
<li><a href="#throtlling">5.20. Throtlling</a></li>
</ul>
</li>
<li><a href="#jboss-modules">6. JBoss Modules</a>
<ul class="sectlevel2">
<li><a href="#setting-module-dependencies">6.1. Setting module dependencies</a>
<ul class="sectlevel3">
<li><a href="#using-manifest-mf">6.1.1. Using MANIFEST.MF</a></li>
<li><a href="#using-jboss-deployment-descriptor-xml">6.1.2. Using jboss-deployment-descriptor.xml</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#build-and-testsuite-framework">7. Build and testsuite framework</a>
<ul class="sectlevel2">
<li><a href="#introduction">7.1. Introduction</a>
<ul class="sectlevel3">
<li><a href="#prerequisites-and-requirements">7.1.1. Prerequisites and requirements</a></li>
</ul>
</li>
<li><a href="#architecture-overview">7.2. Architecture overview</a>
<ul class="sectlevel3">
<li><a href="#target-container-identification">7.2.1. Target Container Identification</a></li>
<li><a href="#port-mapping">7.2.2. Port Mapping</a></li>
</ul>
</li>
<li><a href="#command-line-options">7.3. Command Line Options</a>
<ul class="sectlevel3">
<li><a href="#profile">7.3.1. Profile</a></li>
<li><a href="#options">7.3.2. Options</a></li>
<li><a href="#examples-9">7.3.3. Examples</a></li>
</ul>
</li>
<li><a href="#container-remote-debugging">7.4. Container remote debugging</a></li>
</ul>
</li>
<li><a href="#legal-notice">8. Legal Notice</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="preface-JBoss_Web_Services_Documentation" class="sect0">Preface</h1>
<div class="openblock partintro">
<div class="content">
This book covers the documentation for the current JBossWS release.
</div>
</div>
<div class="sect1">
<h2 id="web-services-introduction">1. Web Services Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="what-is-a-web-service">1.1. What is a web service?</h3>
<div class="paragraph">
<p><em>A Web service is a software system designed to support interoperable
machine-to-machine interaction over a network. It has an interface
described in a machine-processable format (specifically WSDL). Other
systems interact with the Web service in a manner prescribed by its
description using SOAP messages, typically conveyed using HTTP with an
XML serialization in conjunction with other Web-related standards.</em></p>
</div>
<div class="paragraph">
<p>From <em>W3C Web Services Architecture</em>
<a href="http://www.w3.org/TR/2004/NOTE-ws-arch-20040211">[1</a>]</p>
</div>
<div class="paragraph">
<p>Technical details will be later explained in the documentation. What
comes out is that web services provide a standard means of
interoperating between different software applications. Each of these
applications may run on a variety of platforms and/or frameworks
providing a set of functionalities. The main concern is about
interoperability between services.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A service provider publishes a service contract that exposes the
public functions (operations) it provides.  A service
consumers uses those operations to communicate with the provider.</p>
</li>
<li>
<p>Both service providers and service consumers implement concrete
software that sends and receives messages in accordance with the service contract agreed to before the communication.</p>
</li>
<li>
<p>Web services specifications define the rules for publishing a service contract.</p>
</li>
<li>
<p>Web services stacks (like <em>JBossWS</em> ) that conform to the specifications provide a software infrastructure to developers for implementing service providers and consumers.  This infrastructure enables developers to focus on developing their own business logic in their preferred way, without dealing with the low-level details of message exchange.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="who-needs-web-services">1.1.1. Who needs web services?</h4>
<div class="paragraph">
<p>Enterprise systems communication may benefit from adoption of WS
technologies.  The Exposure of well designed contracts allows developers to extract an abstract view of service capabilities.  The standardization of software contracts can help improve communication with third-party systems and business-to-business integration.  It is easier to expand services for the consumer.  No more vendor specific implementation details, home-brew communication protocol or custom per-customer settings.</p>
</div>
<div class="paragraph">
<p>Enterprise system may benefit from web service technologies also for
internal heterogeneous subsystems communication.
Departments are free to implement providers and consumers in different software languages.  As long as a department adheres to the contract, there should be no need for one department to rewrite whole functionalities when another makes alterations and enhancements to their code.</p>
</div>
</div>
<div class="sect3">
<h4 id="what-web-services-are-not">1.1.2. What web services are not&#8230;&#8203;</h4>
<div class="paragraph">
<p>Web services are not the solution for every software system communication.</p>
</div>
<div class="paragraph">
<p>Web services are meant to be used for loosely-coupled coarse-grained
communication and message (document) exchange.</p>
</div>
<div class="paragraph">
<p>Web service specifications (
<a href="http://community.jboss.org/docs/DOC-13554#Future_of_Web_Services">WS-*</a> )
have evolved to standardize ws-related advanced aspects including reliable messaging, message-level security, cross-service transactions, etc.
Web service specifications also include the notion of registries to collect service contract references and mechanisms to discover service implementations.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="from-concepts-to-technology">1.2. From concepts to technology</h3>
<div class="sect3">
<h4 id="service-contracts">1.2.1. Service contracts</h4>
<div class="paragraph">
<p>Contracts carry technical constraints and requirements of the exposed
service as well as information about data to be exchange to interact
with the service. They comprise technical descriptions and optional
non-technical documents. The latter might include human readable
description of the service and the business process it is part of as
well as service level agreement / quality of provided service
information.</p>
</div>
<div class="sect4">
<h5 id="technical-description">Technical description</h5>
<div class="paragraph">
<p>Service description is mainly provided using the standard
<a href="http://www.w3.org/TR/wsdl">Web Service Description Language (WSDL)</a> .
Practically speaking this means one or more XML files contains
information including the service location ( <em>endpoint address</em> ), the
service functionalities ( <em>operations</em> ), the input/output messages
involved in the communication and the business data structure. The
latter is basically one or more <a href="http://www.w3.org/TR/xmlschema-0/">XML
Schema definition</a> . Moreover recent specifications like (
<a href="http://schemas.xmlsoap.org/ws/2004/09/policy/">WS-Policy</a> ) allow for
advanced service capabilities to be stated in the contract through
WSDL extensions.</p>
</div>
<div class="paragraph">
<p>Web service stacks like JBossWS usually have tools to both generate and
consume technical contracts. This helps ensure that owners of service producer ( <em>server</em> ) and consumer ( <em>client</em> ) declare valid contracts to establish the communication.</p>
</div>
</div>
<div class="sect4">
<h5 id="contract-delivery-process">Contract delivery process</h5>
<div class="paragraph">
<p>One of the main concerns about service contracts is the way they&#8217;re
obtained.</p>
</div>
<div class="sect5">
<h6 id="bottom-up-approach">Bottom-Up approach</h6>
<div class="paragraph">
<p>As previously said, tools allow developers to automatically generate
WSDL contract files given their service implementation. Advantages and
disadvantage of this delivery process include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Developers do not have to deal with contracts by hand thus deep
knowledge of WSDL and XML is not required.</p>
</li>
<li>
<p>Less effort and time is required for services to be developed and go live
to a production environment.</p>
</li>
<li>
<p>Contracts usually need frequent maintenance, refactoring and
versioning.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="down-approach">Down approach</h6>
<div class="paragraph">
<p>Developers may write contracts first instead. This usually implies an
initial collaboration of architects and business analysts to define a
conceptual service design together.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Services with contracts obtained this way may easily cooperate in a
service oriented architecture</p>
</li>
<li>
<p>More effort and time is required for web service project start-up</p>
</li>
<li>
<p>Deep knowledge of WSDL and related technology is required</p>
</li>
<li>
<p>Contracts tend to have longer lifespans and usually require less
maintenance.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="message-exchange">1.2.2. Message exchange</h4>
<div class="paragraph">
<p>As stated by the
<a href="http://www.w3.org/TR/2004/NOTE-ws-arch-20040211/#whatis">W3C definition</a>
, the communication between web services is standardized by the
<a href="http://www.w3.org/TR/soap/">SOAP</a> specification. This means XML messages
flow from the provider and consumer endpoints.</p>
</div>
<div class="paragraph">
<p>Messages' content is described in the wsdl contract. The WSDL file also
states the  to be used for the transmission. The most common transport protocol is HTTP, however JMS, SMTP and other ones are allowed.</p>
</div>
</div>
<div class="sect3">
<h4 id="advanced-web-services-technologies">1.2.3. Advanced Web Services technologies</h4>
<div class="paragraph">
<p>The above specifications are quite common nowadays in the IT
industry. Many enterprises have used them for years.</p>
</div>
<div class="paragraph">
<p>In recent years specifications have been created for security (WS-Security) and reliable messaging (WS-Reliable Messaging).
Important functionality in delivering mission critical enterprise services.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quick-start">2. Quick Start</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JBossWS uses WildFly as its target container. The following examples
focus on web service features that leverage EJB3 service
implementations and the JAX-WS programming models. For further
information on POJO service implementations and advanced topics
consult the <a href="#jakarta-xml-web-services-user-guide">Jakarta XML Web Services User Guide</a> .</p>
</div>
<div class="sect2">
<h3 id="developing-web-service-implementations">2.1. Developing web service implementations</h3>
<div class="paragraph">
<p>Jakarta XML Web Services leverages annotations in order to express web service meta data on Java components and to describe the mapping between Java data types and XML. When developing web service implementations one needs to decide whether to start with an abstract contract (WSDL) or a Java component.</p>
</div>
<div class="paragraph">
<p>It is common practice for a developer create the web service in Java
and use vendor tools to generate the corresponding WSDL.
For this reason we are going to look at a service implementation that leverages
<a href="https://jakarta.ee/specifications/web-services-metadata/">Jakarta Web Service Metadata</a> .</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Even though detailed knowledge of web service meta data is not required,
it will definitely help if you make yourself familiar with it. For
further information see</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://jakarta.ee/specifications/web-services-metadata/">Jakarta Web Service Metadata</a></p>
</li>
<li>
<p><a href="https://jakarta.ee/specifications/xml-binding">Jakarta XML Binding
(JAXB)</a></p>
</li>
<li>
<p><a href="https://jakarta.ee/specifications/xml-web-services/">Jakarta XML Web Services</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="the-service-implementation-class">2.1.1. The service implementation class</h4>
<div class="paragraph">
<p>When starting from Java, a service (endpoint) implementation must be provided. A valid endpoint implementation class must meet the following
requirements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It <em>must</em> carry a <code>jakarta.jws.WebService</code> annotation (see Jakarta Web Service Metadata)</p>
</li>
<li>
<p>All method parameters and return types <em>must</em> be compatible with the
JAXB 3.0</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s look at a sample EJB3 component that exposes as a web service.</p>
</div>
<div class="paragraph">
<p>For now ignore the EJB3 annotation <code>@Stateless</code> . Focus on the <code>@WebService</code> annotation.</p>
</div>
<div class="sect4">
<h5 id="implementing-the-service">Implementing the service</h5>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.retail.profile;

import jakarta.ejb.Stateless;
import jakarta.jws.WebService;
import jakarta.jws.WebMethod;
import jakarta.jws.soap.SOAPBinding;

@Stateless                                                             (1)
@WebService(                                                           (2)
   name="ProfileMgmt",
   targetNamespace = "http://org.jboss.ws/samples/retail/profile",
   serviceName = "ProfileMgmtService")
@SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)         (3)
public class ProfileMgmtBean {

   @WebMethod                                                          (4)
   public DiscountResponse getCustomerDiscount(DiscountRequest request) {
      return new DiscountResponse(request.getCustomer(), 10.00);
   }
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>1. This endpoint is using a stateless session bean implementation
2. This web service has an explicit namespace, (http://org.jboss.ws/samples/retail/profile)
3. The endpoint is declared to use a doc/lit bare parameter style.  This affects the endpoint statements generated in the WSDL.
4. 'getCustomerDiscount' is the public operation that a consumer can call.</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="what-about-the-payload">What about the payload?</h5>
<div class="paragraph">
<p>The method parameters and return values represent the XML
payload, because this is a stateless session bean the parameters and return value must be compatible with JAXB3. No JAXB annotations are needed for this example.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.retail.profile;

import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlType;

import org.jboss.test.ws.jaxws.samples.retail.Customer;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(                                                  (1)
  name = "discountRequest",
  namespace="http://org.jboss.ws/samples/retail/profile",
  propOrder = { "customer" }
)
public class DiscountRequest {

   protected Customer customer;

   public DiscountRequest() {
   }

   public DiscountRequest(Customer customer) {
      this.customer = customer;
   }

   public Customer getCustomer() {
      return customer;
   }

   public void setCustomer(Customer value) {
      this.customer = value;
   }

}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>1. @XmlType is used to declare an XML type named, discountRequest, and a namespace name, (http://org.jboss.ws/samples/retail/profile).</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>For more complex XML mapping consult the
<a href="https://jakarta.ee/specifications/xml-binding">JAXB documentation</a> .</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="deploying-service-implementations">2.1.2. Deploying service implementations</h4>
<div class="paragraph">
<p>Web service deployment depends on the implementation type. Web services can be implemented as plain old Java objects, POJO or as EJB3 components.</p>
</div>
<div class="sect4">
<h5 id="ejb3-services">EJB3 services</h5>
<div class="paragraph">
<p>Create a JAR containing the service implementation class, the endpoint interface and any custom data types needed.  Drop the JAR in the <em>deployment</em> directory.  No additional deployment descriptors required. Any meta data
required for the deployment of the actual web service is taken from the
annotations provided in the implementation class and the service
endpoint interface. JBossWS intercepts the EJB3 deployment (the
bean will be there) and creates an HTTP endpoint at deploy-time.</p>
</div>
</div>
<div class="sect4">
<h5 id="the-jar-package-structure">The JAR package structure</h5>
<div class="paragraph">
<p>jar -tf jaxws-samples-retail.jar</p>
</div>
<div class="literalblock">
<div class="content">
<pre>org/jboss/test/ws/jaxws/samples/retail/profile/DiscountRequest.class
org/jboss/test/ws/jaxws/samples/retail/profile/DiscountResponse.class
org/jboss/test/ws/jaxws/samples/retail/profile/ObjectFactory.class
org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmt.class
org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmtBean.class
org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmtService.class
org/jboss/test/ws/jaxws/samples/retail/profile/package-info.class</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>If the deployment was successful you should be able to see your endpoint
in the application server management console.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="consuming-web-services">2.2. Consuming web services</h3>
<div class="paragraph">
<p>When creating web service clients, one usually starts from the WSDL, but deciphering the WSDL can be complicated.
JBossWS ships with a set of tools to generate the required JAX-WS
artifacts to build client implementations. The following section
looks at a basic usage pattern. For a more detailed
introduction to the web service client please consult the user guide.</p>
</div>
<div class="sect3">
<h4 id="creating-the-client-artifacts">2.2.1. Creating the client artifacts</h4>
<div class="sect4">
<h5 id="using-wsconsume">Using wsconsume</h5>
<div class="paragraph">
<p>The <em>wsconsume</em> tool is used to consume the abstract contract (WSDL) and
produce annotated Java classes.
The following discussion starts with the WSDL from our retail example
(ProfileMgmtService.wsdl) above. For a detailed tool reference
consult the user guide.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsconsume is a command line tool that generates
portable JAX-WS artifacts from a WSDL file.

usage: org.jboss.ws.tools.jaxws.command.wsconsume [options] &lt;wsdl-url&gt;

options:
    -h, --help                  Show this help message
    -b, --binding=&lt;file&gt;        One or more JAX-WS or JAXB binding files
    -k, --keep                  Keep/Generate Java source
    -c  --catalog=&lt;file&gt;        Oasis XML Catalog file for entity resolution
    -p  --package=&lt;name&gt;        The target package for generated source
    -w  --wsdlLocation=&lt;loc&gt;    Value to use for @WebService.wsdlLocation
    -o, --output=&lt;directory&gt;    The directory to put generated artifacts
    -s, --source=&lt;directory&gt;    The directory to put Java source
    -q, --quiet                 Be somewhat more quiet
    -t, --show-traces           Show full exception stack traces</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s try it on our sample:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>~./wsconsume.sh -k -p org.jboss.test.ws.jaxws.samples.retail.profile ProfileMgmtService.wsdl  (1)

org/jboss/test/ws/jaxws/samples/retail/profile/Customer.java
org/jboss/test/ws/jaxws/samples/retail/profile/DiscountRequest.java
org/jboss/test/ws/jaxws/samples/retail/profile/DiscountResponse.java
org/jboss/test/ws/jaxws/samples/retail/profile/ObjectFactory.java
org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmt.java
org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmtService.java
org/jboss/test/ws/jaxws/samples/retail/profile/package-info.java</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Note we used the <code>-p</code> switch to specify the package name
of the generated sources.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="the-generated-artifacts-explained">The generated artifacts explained</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">File</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ProfileMgmt.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Service Endpoint Interface</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Customer.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom data type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Discount*.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom data type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectFactory.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JAXB XML Registry</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">package-info.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holder for JAXB package annotations</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ProfileMgmtService.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Service factory</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><em>wsconsume</em> generates all the custom data types (JAXB annotated
classes), the service endpoint interface and a service factory class.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="constructing-a-service-stub">2.2.2. Constructing a service stub</h4>
<div class="paragraph">
<p>Web service clients make use of a service stub that hides the details of
a remote web service invocation. To a client application a WS invocation
looks like an invocation of any other business component. In this
case the service endpoint interface is the business interface.
JAX-WS does use a service factory class to construct this as particular
service stub:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import jakarta.xml.ws.Service;
[...]
Service service = Service.create(                                 (1)
new URL("http://example.org/service?wsdl"),
new QName("MyService")
);
ProfileMgmt profileMgmt = service.getPort(ProfileMgmt.class);     (2)

// do something with the service stub here...                     (3)</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a service factory using the WSDL location and the service name</p>
</li>
<li>
<p>Use the tool created service endpoint interface to build the service
stub</p>
</li>
<li>
<p>Use the stub like any other business interface</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="resolving-dependencies-and-running-the-client">2.2.3. Resolving dependencies and running the client</h4>
<div class="paragraph">
<p>To successfully run a WS client application, a classloader
needs to be properly setup to include the JBossWS components and its
required transitive dependencies. Depending on the environment the
client is run in, this might require adding some jars to the
classpath, or adding some artifact dependencies to the maven dependency
tree. Even for simply developing a client, users might
need to resolve proper dependencies (e.g. to setup their IDE).</p>
</div>
<div class="paragraph">
<p>Below you will find some options for resolving dependencies and running a WS
client using the JBossWS libraries:</p>
</div>
<div class="sect4">
<h5 id="maven-project">Maven project</h5>
<div class="paragraph">
<p>The JBossWS project is composed of multiple Maven artifacts that can be
used to declare dependencies in user Maven projects. In particular, the
`
              org.jboss.ws.cxf:jbossws-cxf-client
            ` artifact can be used for getting the whole JBossWS client
dependency. Users should simply add a dependency to it in their Maven
project and make sure JBossWS components (in particular
<code>org.jboss.ws.cxf:jbossws-cxf-factories</code> ) come before jars of any other
JAX-WS implementation in your classpath.</p>
</div>
</div>
<div class="sect4">
<h5 id="jboss-modules-environment">JBoss Modules environment</h5>
<div class="paragraph">
<p>One approach for running a WS client is to leverage JBoss
Modules, creating a classloading environment equivalent to the
server container WS endpoints run in. This is achieved by using the
<em>jboss-modules.jar</em> coming with WildFly as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>java -jar $WILDFLY_HOME/jboss-modules.jar -mp $WILDFLY_HOME/modules -jar client.jar</pre>
</div>
</div>
<div class="paragraph">
<p>The <em>client.jar</em> is meant to contain the WS client application and
include a <em>MANIFEST.MF</em> file specifying the proper <code>Main-Class</code> as well
as <a href="#jboss-modules">JBoss Modules</a> dependencies, for instance:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version: 1.0
Main-Class: org.jboss.test.ws.jaxws.jbws1666.TestClient
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="flat-classpath-setup">Flat classpath setup</h5>
<div class="paragraph">
<p>Alternatively, users can setup their application classpath manually
(e.g when compiling and running the application directly through <code>javac</code>
/ <code>java</code> command or using <code>Ant</code> ).</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="maven-archetype-quick-start">2.3. Maven archetype quick start</h3>
<div class="paragraph">
<p>A convenient approach to start a new project aiming at providing and/or
consuming a JAX-WS endpoint is to use the JBossWS <em>jaxws-codefirst</em>
Maven Archetype. A starting project (including working build and sample
helloworld client and endpoint) is created in few seconds. It&#8217;s simply a
matter of issuing a command and answering several simple questions about the
desired artifact and group ids for the project being generated:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; mvn archetype:generate -Dfilter=org.jboss.ws.plugins.archetypes:</pre>
</div>
</div>
<div class="paragraph">
<p>The generated project includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a sample HelloWorld code-first POJO endpoint</p>
</li>
<li>
<p>an integration test that gets the WSDL contract for the above service,
builds a client and invokes the endpoint</p>
</li>
<li>
<p>a pom.xml for creating a war archive; the project has proper WS
component dependencies and uses both wsprovide and wsconsume maven
plugins for generating the contract for the code-first endpoint and then
generating the client stubs for such contract</p>
</li>
<li>
<p>a plugin for deploying the archive on WildFly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The project is built and tested by running:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; mvn wildfly:deploy
&gt; mvn integration-test</pre>
</div>
</div>
<div class="paragraph">
<p>The build processes the various plugins and calls into the JBossWS tools
to generate all the required classes for building the deployment archive
and client. The user can test the sample, have a look at the project
structure and then either trash the sample endpoint and testcase and
replace them with his own components, or modify them step-by-step to
achieve their own needs.</p>
</div>
</div>
<div class="sect2">
<h3 id="appendix">2.4. Appendix</h3>
<div class="sect3">
<h4 id="sample-wsdl-contract">2.4.1. Sample wsdl contract</h4>
<div class="literalblock">
<div class="content">
<pre>&lt;definitions
    name='ProfileMgmtService'
    targetNamespace='http://org.jboss.ws/samples/retail/profile'
    xmlns='http://schemas.xmlsoap.org/wsdl/'
    xmlns:ns1='http://org.jboss.ws/samples/retail'
    xmlns:soap='http://schemas.xmlsoap.org/wsdl/soap/'
    xmlns:tns='http://org.jboss.ws/samples/retail/profile'
    xmlns:xsd='http://www.w3.org/2001/XMLSchema'&gt;

   &lt;types&gt;

      &lt;xs:schema targetNamespace='http://org.jboss.ws/samples/retail'
                 version='1.0' xmlns:xs='http://www.w3.org/2001/XMLSchema'&gt;
         &lt;xs:complexType name='customer'&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element minOccurs='0' name='creditCardDetails' type='xs:string'/&gt;
               &lt;xs:element minOccurs='0' name='firstName' type='xs:string'/&gt;
               &lt;xs:element minOccurs='0' name='lastName' type='xs:string'/&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:complexType&gt;
      &lt;/xs:schema&gt;

      &lt;xs:schema
          targetNamespace='http://org.jboss.ws/samples/retail/profile'
          version='1.0'
          xmlns:ns1='http://org.jboss.ws/samples/retail'
          xmlns:tns='http://org.jboss.ws/samples/retail/profile'
          xmlns:xs='http://www.w3.org/2001/XMLSchema'&gt;

         &lt;xs:import namespace='http://org.jboss.ws/samples/retail'/&gt;
         &lt;xs:element name='getCustomerDiscount'
                     nillable='true' type='tns:discountRequest'/&gt;
         &lt;xs:element name='getCustomerDiscountResponse'
                     nillable='true' type='tns:discountResponse'/&gt;
         &lt;xs:complexType name='discountRequest'&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element minOccurs='0' name='customer' type='ns1:customer'/&gt;

            &lt;/xs:sequence&gt;
         &lt;/xs:complexType&gt;
         &lt;xs:complexType name='discountResponse'&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element minOccurs='0' name='customer' type='ns1:customer'/&gt;
               &lt;xs:element name='discount' type='xs:double'/&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:complexType&gt;
      &lt;/xs:schema&gt;

   &lt;/types&gt;

   &lt;message name='ProfileMgmt_getCustomerDiscount'&gt;
      &lt;part element='tns:getCustomerDiscount' name='getCustomerDiscount'/&gt;
   &lt;/message&gt;
   &lt;message name='ProfileMgmt_getCustomerDiscountResponse'&gt;
      &lt;part element='tns:getCustomerDiscountResponse'
            name='getCustomerDiscountResponse'/&gt;
   &lt;/message&gt;
   &lt;portType name='ProfileMgmt'&gt;
      &lt;operation name='getCustomerDiscount'
                 parameterOrder='getCustomerDiscount'&gt;

         &lt;input message='tns:ProfileMgmt_getCustomerDiscount'/&gt;
         &lt;output message='tns:ProfileMgmt_getCustomerDiscountResponse'/&gt;
      &lt;/operation&gt;
   &lt;/portType&gt;
   &lt;binding name='ProfileMgmtBinding' type='tns:ProfileMgmt'&gt;
      &lt;soap:binding style='document'
                    transport='http://schemas.xmlsoap.org/soap/http'/&gt;
      &lt;operation name='getCustomerDiscount'&gt;
         &lt;soap:operation soapAction=''/&gt;
         &lt;input&gt;

            &lt;soap:body use='literal'/&gt;
         &lt;/input&gt;
         &lt;output&gt;
            &lt;soap:body use='literal'/&gt;
         &lt;/output&gt;
      &lt;/operation&gt;
   &lt;/binding&gt;
   &lt;service name='ProfileMgmtService'&gt;
      &lt;port binding='tns:ProfileMgmtBinding' name='ProfileMgmtPort'&gt;

         &lt;soap:address
             location='http://&lt;HOST&gt;:&lt;PORT&gt;/jaxws-samples-retail/ProfileMgmtBean'/&gt;
      &lt;/port&gt;
   &lt;/service&gt;
&lt;/definitions&gt;</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jakarta-xml-web-services-user-guide">3. Jakarta XML Web Services User Guide</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://jakarta.ee/specifications/xml-web-services/">Jakarta XML Web Services(JAX-WS)</a>
defines the mapping between WSDL and Java
as well as the classes to be used for accessing webservices and
publishing them. JBossWS implements the latest Jakarta XML Web Services specification,
hence users can reference it for any vendor agnostic webservice usage. Below is a brief overview of the most basic functionalities.</p>
</div>
<div class="sect2">
<h3 id="web-service-endpoints">3.1. Web Service Endpoints</h3>
<div class="paragraph">
<p>Jakarta XML Web Services simplifies the development model for a web service endpoint. An endpoint implementation bean is annotated with
JAX-WS annotations and deployed to the server. The server automatically
generates and publishes the abstract contract (i.e. wsdl+schema) for
client consumption. All marshalling/unmarshalling is delegated to
<a href="https://jakarta.ee/specifications/xml-binding" class="bare">https://jakarta.ee/specifications/xml-binding</a>[Jakarta XML Binding
(JAXB).</p>
</div>
<div class="sect3">
<h4 id="plain-old-java-object-pojo">3.1.1. Plain old Java Object (POJO)</h4>
<div class="paragraph">
<p>The following is a simple POJO endpoint implementation. All endpoint
associated metadata is provided via
<a href="https://jakarta.ee/specifications/web-services-metadata/">Jakarta Web Service Metadata</a>
 annotations</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class JSEBean01
{
   @WebMethod
   public String echo(String input)
   {
      ...
   }
}</pre>
</div>
</div>
<div class="sect4">
<h5 id="the-endpoint-as-a-web-application">The endpoint as a web application</h5>
<div class="paragraph">
<p>A JAX-WS java service endpoint (JSE) is deployed as a web application.
Here is a sample <em>web.xml</em> descriptor:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;web-app ...&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.jsr181pojo.JSEBean01&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="packaging-the-endpoint">Packaging the endpoint</h5>
<div class="paragraph">
<p>A JSR-181 java service endpoint (JSE) is packaged as a web application
in a <em>war</em> file.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;war warfile="${build.dir}/libs/jbossws-samples-jsr181pojo.war" webxml="${build.resources.dir}/samples/jsr181pojo/WEB-INF/web.xml"&gt;
  &lt;classes dir="${build.dir}/classes"&gt;
    &lt;include name="org/jboss/test/ws/samples/jsr181pojo/JSEBean01.class"/&gt;
  &lt;/classes&gt;
&lt;/war&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Note, only the endpoint implementation bean and web.xml are required.</p>
</div>
</div>
<div class="sect4">
<h5 id="accessing-the-generated-wsdl">Accessing the generated WSDL</h5>
<div class="paragraph">
<p>A successfully deployed service endpoint shows up in the WildFly
management console. The deployed endpoint wsdl address can be found there.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Note, it is also possible to generate the abstract contract offline
using JBossWS tools. For details of that please see Bottom-Up (Java to
WSDL).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ejb3-stateless-session-bean-slsb">3.1.2. EJB3 Stateless Session Bean (SLSB)</h4>
<div class="paragraph">
<p>The JAX-WS programming model supports the same set of annotations on
EJB3 stateless session beans as on POJO endpoints.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@Stateless
@Remote(EJB3RemoteInterface.class)
@RemoteBinding(jndiBinding = "/ejb3/EJB3EndpointInterface")

@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class EJB3Bean01 implements EJB3RemoteInterface
{
   @WebMethod
   public String echo(String input)
   {
      ...
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Above you see an EJB-3.0 stateless session bean that exposes one method
both on the remote interface and as an endpoint operation.</p>
</div>
<div class="sect4">
<h5 id="packaging-the-endpoint-2">Packaging the endpoint</h5>
<div class="paragraph">
<p>A Jakarta Web Service Metadata EJB service endpoint is packaged as an ordinary ejb
deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;jar jarfile="${build.dir}/libs/jbossws-samples-jsr181ejb.jar"&gt;
  &lt;fileset dir="${build.dir}/classes"&gt;
    &lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3Bean01.class"/&gt;
    &lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3RemoteInterface.class"/&gt;
  &lt;/fileset&gt;
&lt;/jar&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="accessing-the-generated-wsdl-2">Accessing the generated WSDL</h5>
<div class="paragraph">
<p>A successfully deployed service endpoint shows up in the WildFly
management console. The deployed endpoint wsdl address can be found there.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Note, it is also possible to generate the abstract contract offline
using JBossWS tools. For details of that please see Bottom-Up (Java to
WSDL).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-provider">3.1.3. Endpoint Provider</h4>
<div class="paragraph">
<p>JAX-WS services typically implement a native Java service endpoint
interface (SEI), perhaps mapped from a WSDL port type, either directly
or via the use of annotations.</p>
</div>
<div class="paragraph">
<p>Java SEIs provide a high level Java-centric abstraction that hides the
details of converting between Java objects and their XML representations
for use in XML-based messages. However, in some cases it is desirable
for services to be able to operate at the XML message level. The
Provider interface offers an alternative to SEIs and may be implemented
by services wishing to work at the XML message level.</p>
</div>
<div class="paragraph">
<p>A Provider based service instances invoke method is called for each
message received for the service.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebServiceProvider(wsdlLocation = "WEB-INF/wsdl/Provider.wsdl")
@ServiceMode(value = Service.Mode.PAYLOAD)
public class ProviderBeanPayload implements Provider&lt;Source&gt;
{
   public Source invoke(Source req)
   {
      // Access the entire request PAYLOAD and return the response PAYLOAD
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Note, <code>Service.Mode.PAYLOAD</code> is the default and does not have to be
declared explicitly. The <code>Service.Mode.MESSAGE</code> can be used to access
the entire SOAP message (i.e. with <code>MESSAGE</code> the Provider can also see
SOAP Headers)</p>
</div>
<div class="paragraph">
<p>The abstract contract for a provider endpoint cannot be
derived/generated automatically. Therefore, it is necessary to specify
the <em>wsdlLocation</em> with the <code>@</code> <code>WebServiceProvider</code> annotation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="web-service-clients">3.2. Web Service Clients</h3>
<div class="sect3">
<h4 id="service">3.2.1. Service</h4>
<div class="paragraph">
<p><code>Service</code> is an abstraction that represents a WSDL service. A WSDL
service is a collection of related ports, each of which consists of a
port type bound to a particular protocol and available at a particular
endpoint address.</p>
</div>
<div class="paragraph">
<p>Most clients are started with a set of stubs generated from the
WSDL. One of these will be the service, and you will create objects of
that class in order to work with the service (see "static case" below).</p>
</div>
<div class="sect4">
<h5 id="service-usage">Service Usage</h5>
<div class="sect5">
<h6 id="static-case">Static case</h6>
<div class="paragraph">
<p>Most clients will start with a WSDL file, and generate some stubs using
JBossWS' tool, <em>wsconsume</em> . This usually generates a set of files, one
of which is the top of the tree. This is the service implementation
class.</p>
</div>
<div class="paragraph">
<p>The generated implementation class can be recognized as it will have two
public constructors, one with no arguments and one with two arguments.
The two constructor arguments represent the wsdl location (a <code>java.net.URL</code> ) and the service name
(a <code>javax.xml.namespace.QName</code> ) respectively.</p>
</div>
<div class="paragraph">
<p>Usually the no-argument constructor will be used. In this case the WSDL
location and service name are those found in the WSDL. These are set
implicitly from the <code>@WebServiceClient</code> annotation that decorates the
generated class.</p>
</div>
<div class="paragraph">
<p>The following code snippet shows the generated constructors from the
generated class:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// Generated Service Class

@WebServiceClient(name="StockQuoteService", targetNamespace="http://example.com/stocks", wsdlLocation="http://example.com/stocks.wsdl")
public class StockQuoteService extends jakarta.xml.ws.Service
{
   public StockQuoteService()
   {
      super(new URL("http://example.com/stocks.wsdl"), new QName("http://example.com/stocks", "StockQuoteService"));
   }

   public StockQuoteService(String wsdlLocation, QName serviceName)
   {
      super(wsdlLocation, serviceName);
   }

   ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Section Dynamic Proxy explains how to obtain a port from the service and
how to invoke an operation on the port. If you need to work with the XML
payload directly or with the XML representation of the entire SOAP
message, have a look at <code>Dispatch</code> .</p>
</div>
</div>
<div class="sect5">
<h6 id="dynamic-case">Dynamic case</h6>
<div class="paragraph">
<p>In the dynamic case, when nothing is generated, a web service client
uses <code>Service.create</code> to create Service instances, the following code
illustrates this process.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>URL wsdlLocation = new URL("http://example.org/my.wsdl");
QName serviceName = new QName("http://example.org/sample", "MyService");
Service service = Service.create(wsdlLocation, serviceName);</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="handler-resolver">Handler Resolver</h5>
<div class="paragraph">
<p>JAX-WS provides a flexible plug-in framework for message processing
modules, known as handlers, that may be used to extend the capabilities
of a JAX-WS runtime system. The Handler Framework describes the handler
framework in detail. A Service instance provides access to a
<code>HandlerResolver</code> via a pair of <code>getHandlerResolver</code> /
<code>setHandlerResolver</code> methods that may be used to configure a set of
handlers on a per-service, per-port or per-protocol binding basis.</p>
</div>
<div class="paragraph">
<p>When a Service instance is used to create a proxy or a Dispatch instance
then the handler resolver currently registered with the service is used
to create the required handler chain. Subsequent changes to the handler
resolver configured for a Service instance do not affect the handlers on
previously created proxies, or Dispatch instances.</p>
</div>
</div>
<div class="sect4">
<h5 id="executor">Executor</h5>
<div class="paragraph">
<p>Service instances can be configured with a
<code>java.util.concurrent.Executor</code> . The executor will then be used to
invoke any asynchronous callbacks requested by the application. The
<code>setExecutor</code> and <code>getExecutor</code> methods of <code>Service</code> can be used to
modify and retrieve the executor configured for a service.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-proxy">3.2.2. Dynamic Proxy</h4>
<div class="paragraph">
<p>An instance of a client proxy can be created using one of <code>getPort</code>
methods on the <code>Service</code> .</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/**
 * The getPort method returns a proxy. A service client
 * uses this proxy to invoke operations on the target
 * service endpoint. The &lt;code&gt;serviceEndpointInterface&lt;/code&gt;
 * specifies the service endpoint interface that is supported by
 * the created dynamic proxy instance.
 **/
public &lt;T&gt; T getPort(QName portName, Class&lt;T&gt; serviceEndpointInterface)
{
   ...
}

/**
 * The getPort method returns a proxy. The parameter
 * &lt;code&gt;serviceEndpointInterface&lt;/code&gt; specifies the service
 * endpoint interface that is supported by the returned proxy.
 * In the implementation of this method, the JAX-WS
 * runtime system takes the responsibility of selecting a protocol
 * binding (and a port) and configuring the proxy accordingly.
 * The returned proxy should not be reconfigured by the client.
 *
 **/
public &lt;T&gt; T getPort(Class&lt;T&gt; serviceEndpointInterface)
{
   ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>The service endpoint interface (SEI) is usually generated using tools.
For details see Top Down (WSDL to Java)</p>
</div>
<div class="paragraph">
<p>A generated static Service usually offers typed methods to get
ports. These methods also return dynamic proxies that implement the SEI.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebServiceClient(name = "TestEndpointService", targetNamespace = "http://org.jboss.ws/wsref",
   wsdlLocation = "http://localhost.localdomain:8080/jaxws-samples-webserviceref?wsdl")

public class TestEndpointService extends Service
{
    ...

    public TestEndpointService(URL wsdlLocation, QName serviceName) {
        super(wsdlLocation, serviceName);
    }

    @WebEndpoint(name = "TestEndpointPort")
    public TestEndpoint getTestEndpointPort()
    {
        return (TestEndpoint)super.getPort(TESTENDPOINTPORT, TestEndpoint.class);
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webserviceref">3.2.3. WebServiceRef</h4>
<div class="paragraph">
<p>The <code>@WebServiceRef</code> annotation is used to declare a reference to a Web
service. It follows the resource pattern exemplified by the
<code>jakarta.annotation.Resource</code> annotation in
<a href="https://jakarta.ee/specifications/annotations">Jakarta Annotations</a> .</p>
</div>
<div class="paragraph">
<p>There are two uses to the WebServiceRef annotation:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>To define a reference whose type is a generated service class. In this
case, the type and value element both refer to the generated
service class type. Moreover, if the reference type can be inferred by
the field/method declaration the annotation is applied to, the type and
value elements MAY have the default value (Object.class, that is). If
the type cannot be inferred, then at least the type element MUST be
present with a non-default value.</p>
</li>
<li>
<p>To define a reference whose type is a SEI. In this case, the type
element MAY be present with its default value if the type of the
reference can be inferred from the annotated field/method declaration,
but the value element MUST always be present and refer to a generated
service class type (a subtype of jakarta.xml.ws.Service). The wsdlLocation
element, if present, overrides theWSDL location information specified in
the WebService annotation of the referenced generated service class.</p>
<div class="literalblock">
<div class="content">
<pre>public class EJB3Client implements EJB3Remote
{
   @WebServiceRef
   public TestEndpointService service4;

   @WebServiceRef
   public TestEndpoint port3;</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="webserviceref-customization">WebServiceRef customization</h5>
<div class="paragraph">
<p>A number of overrides and extensions are offered to the WebServiceRef
annotation. These include</p>
</div>
<div class="ulist">
<ul>
<li>
<p>define the port that should be used to resolve a container-managed
port</p>
</li>
<li>
<p>define default Stub property settings for Stub objects</p>
</li>
<li>
<p>define the URL of a final WSDL document to be used Example:</p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="content">
<pre>  &lt;service-ref&gt;
   &lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;
   &lt;wsdl-override&gt;file:/wsdlRepository/organization-service.wsdl&lt;/wsdl-override&gt;
  &lt;/service-ref&gt;

  &lt;service-ref&gt;
   &lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;
   &lt;config-name&gt;Secure Client Config&lt;/config-name&gt;
   &lt;config-file&gt;META-INF/jbossws-client-config.xml&lt;/config-file&gt;
   &lt;handler-chain&gt;META-INF/jbossws-client-handlers.xml&lt;/handler-chain&gt;
  &lt;/service-ref&gt;
 
  &lt;service-ref&gt;
   &lt;service-ref-name&gt;SecureService&lt;/service-ref-name&gt;
   &lt;service-impl-class&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpointService&lt;/service-impl-class&gt;
   &lt;service-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointService&lt;/service-qname&gt;
    &lt;port-component-ref&gt;
     &lt;service-endpoint-interface&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpoint&lt;/service-endpoint-interface&gt;
     &lt;port-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointPort&lt;/port-qname&gt;
     &lt;stub-property&gt;
      &lt;prop-name&gt;jakarta.xml.ws.security.auth.username&lt;/prop-name&gt;
      &lt;prop-value&gt;kermit&lt;/prop-value&gt;
     &lt;/stub-property&gt;
     &lt;stub-property&gt;
      &lt;prop-name&gt;jakarta.xml.ws.security.auth.password&lt;/prop-name&gt;
      &lt;prop-value&gt;thefrog&lt;/prop-value&gt;
     &lt;/stub-property&gt;
   &lt;/port-component-ref&gt;
  &lt;/service-ref&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>For details please see
<em><a href="http://www.jboss.org/j2ee/dtd/service-ref_5_0.dtd">service-ref_5_0.dtd</a></em>
.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dispatch">3.2.4. Dispatch</h4>
<div class="paragraph">
<p>XML Web Services use XML messages for communication between services and
service clients. The higher level JAX-WS APIs are designed to hide the
details of converting between Java method invocations and the
corresponding XML messages, but in some cases operating at the XML
message level is desirable. The Dispatch interface provides support for
this mode of interaction.</p>
</div>
<div class="paragraph">
<p><code>Dispatch</code> supports two usage modes, identified by the constants
<code>jakarta.xml.ws.Service.Mode.MESSAGE</code> and
<code>jakarta.xml.ws.Service.Mode.PAYLOAD</code> respectively:</p>
</div>
<div class="paragraph">
<p><strong><em>Message</em></strong> In this mode, client applications work directly with
protocol-specific message structures. E.g., when used with a SOAP
protocol binding, a client application would work directly with a SOAP
message.</p>
</div>
<div class="paragraph">
<p><strong><em>Message Payload</em></strong> In this mode, client applications work with the
payload of messages rather than the messages themselves. E.g., when used
with a SOAP protocol binding, a client application would work with the
contents of the SOAP Body rather than the SOAP message as a whole.</p>
</div>
<div class="paragraph">
<p>Dispatch is a low level API that requires clients to construct messages
or message payloads as XML and requires an intimate knowledge of the
desired message or payload structure. Dispatch is a generic class that
supports input and output of messages or message payloads of any type.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Service service = Service.create(wsdlURL, serviceName);
Dispatch dispatch = service.createDispatch(portName, StreamSource.class, Mode.PAYLOAD);

String payload = "&lt;ns1:ping xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
dispatch.invokeOneWay(new StreamSource(new StringReader(payload)));

payload = "&lt;ns1:feedback xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
Source retObj = (Source)dispatch.invoke(new StreamSource(new StringReader(payload)));</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="asynchronous-invocations">3.2.5. Asynchronous Invocations</h4>
<div class="paragraph">
<p>The <code>BindingProvider</code> interface represents a component that provides a
protocol binding for use by clients, it is implemented by proxies and is
extended by the <code>Dispatch</code> interface.</p>
</div>
<div class="paragraph">
<p><code>BindingProvider</code> instances may provide asynchronous operation
capabilities. When used, asynchronous operation invocations are
decoupled from the <code>BindingProvider</code> instance at invocation time such
that the response context is not updated when the operation completes.
Instead a separate response context is made available using the
<code>Response</code> interface.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void testInvokeAsync() throws Exception
{
   URL wsdlURL = new URL("http://" + getServerHost() + ":8080/jaxws-samples-asynchronous?wsdl");
   QName serviceName = new QName(targetNS, "TestEndpointService");
   Service service = Service.create(wsdlURL, serviceName);
   TestEndpoint port = service.getPort(TestEndpoint.class);
   Response response = port.echoAsync("Async");
   // access future
   String retStr = (String) response.get();
   assertEquals("Async", retStr);
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oneway-invocations">3.2.6. Oneway Invocations</h4>
<div class="paragraph">
<p><code>@Oneway</code> indicates that the given web method has only an input message
and no output. Typically, a oneway method returns the thread of control
to the calling application prior to executing the actual business
method.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebService (name="PingEndpoint")
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class PingEndpointImpl
{
   private static String feedback;
  
   @WebMethod
   @Oneway
   publicvoid ping()
   {
      log.info("ping");
      feedback = "ok";
   }
  
   @WebMethod
   public String feedback()
   {
      log.info("feedback");
      return feedback;
   }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="timeout-configuration">3.2.7. Timeout Configuration</h4>
<div class="paragraph">
<p>There are two properties to configure the http connection timeout and
client receive time out:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void testConfigureTimeout() throws Exception
{
   //Set timeout until a connection is established
   ((BindingProvider)port).getRequestContext().put("jakarta.xml.ws.client.connectionTimeout", "6000");

   //Set timeout until the response is received
   ((BindingProvider) port).getRequestContext().put("jakarta.xml.ws.client.receiveTimeout", "1000");

   port.echo("testTimeout");
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="http2-support">3.2.8. HTTP/2 Support</h4>
<div class="paragraph">
<p>Starting from JBossWS 7.1.0,the new CXF HTTP client transport has been created to better support HTTP/2.
This client which is using java.net.http.HttpClient now seamlessly upgrades to HTTP/2 if supported by the server.
Otherwise, it falls back to HTTP/1.1. To enable this new client, you must ensure that the
contextual property <code>force.urlconnection.http.conduit</code> is explicitly set to false, either in the System
properties or the Bus. Otherwise, the default(old) client which based on java.net.HttpURLConnection/javax.net.ssl.HttpsURLConnection
is enabled.</p>
</div>
<div class="paragraph">
<p>To http version for the new client can be defined with the <code>org.apache.cxf.transport.http.forceVersion</code> property.
This property can be set to system or bus property. Below is an example illustrating how to enable this new client
and enforce the http version to 1.1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code> BusFactory.getDefaultBus().setProperty("force.urlconnection.http.conduit", false);
 BusFactory.getDefaultBus().setProperty("org.apache.cxf.transport.http.forceVersion", "1.1");
 HelloWorld port = getPort();
 String response = port.echo("hello");</code></pre>
</div>
</div>
<div class="paragraph">
<p>But from our tests, this new http client is a bit slower than the old client. Therefore, it&#8217;s only recommended to consider using it when the client performance
isn&#8217;t critical and HTTP/2 support is required.
For more information, please check out [CXF documentation](<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=49941#ClientHTTPTransport(includingSSLsupport)-DefaultClientTransport" class="bare">https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=49941#ClientHTTPTransport(includingSSLsupport)-DefaultClientTransport</a>).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="common-api">3.3. Common API</h3>
<div class="paragraph">
<p>This sections describes concepts that apply equally to Web Service
Endpoints and Web Service Clients.</p>
</div>
<div class="sect3">
<h4 id="handler-framework">3.3.1. Handler Framework</h4>
<div class="paragraph">
<p>The handler framework is implemented by a JAX-WS protocol binding in
both client and server side runtimes. Proxies, and Dispatch instances,
known collectively as binding providers, each use protocol bindings to
bind their abstract functionality to specific protocols.</p>
</div>
<div class="paragraph">
<p>Client and server-side handlers are organized into an ordered list known
as a handler chain. The handlers within a handler chain are invoked each
time a message is sent or received. Inbound messages are processed by
handlers prior to binding provider processing. Outbound messages are
processed by handlers after any binding provider processing.</p>
</div>
<div class="paragraph">
<p>Handlers are invoked with a message context that provides methods to
access and modify inbound and outbound messages and to manage a set of
properties. Message context properties may be used to facilitate
communication between individual handlers and between handlers and
client and service implementations. Different types of handlers are
invoked with different types of message context.</p>
</div>
<div class="sect4">
<h5 id="logical-handler">Logical Handler</h5>
<div class="paragraph">
<p>Handlers that only operate on message context properties and message
payloads. Logical handlers are protocol agnostic and are unable to
affect protocol specific parts of a message. Logical handlers are
handlers that implement <code>jakarta.xml.ws.handler.LogicalHandler</code> .</p>
</div>
</div>
<div class="sect4">
<h5 id="protocol-handler">Protocol Handler</h5>
<div class="paragraph">
<p>Handlers that operate on message context properties and protocol
specific messages. Protocol handlers are specific to a particular
protocol and may access and change protocol specific aspects of a
message. Protocol handlers are handlers that implement any interface
derived from <code>jakarta.xml.ws.handler.Handler</code> except
<code>jakarta.xml.ws.handler.LogicalHandler</code> .</p>
</div>
</div>
<div class="sect4">
<h5 id="service-endpoint-handlers">Service endpoint handlers</h5>
<div class="paragraph">
<p>On the service endpoint, handlers are defined using the <code>@HandlerChain</code>
annotation.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebService
@HandlerChain(file = "jaxws-server-source-handlers.xml")
public class SOAPEndpointSourceImpl
{
   ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>The location of the handler chain file supports 2 formats</p>
</div>
<div class="paragraph">
<p>1. An absolute java.net.URL in externalForm. (ex:
<a href="http://myhandlers.foo.com/handlerfile1.xml" class="bare">http://myhandlers.foo.com/handlerfile1.xml</a> )</p>
</div>
<div class="paragraph">
<p>2. A relative path from the source file or class file. (ex:
bar/handlerfile1.xml)</p>
</div>
</div>
<div class="sect4">
<h5 id="service-client-handlers">Service client handlers</h5>
<div class="paragraph">
<p>On the client side, handler can be configured using the <code>@HandlerChain</code>
annotation on the SEI or dynamically using the API.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Service service = Service.create(wsdlURL, serviceName);
Endpoint port = (Endpoint)service.getPort(Endpoint.class);
     
BindingProvider bindingProvider = (BindingProvider)port;
List&lt;Handler&gt; handlerChain = new ArrayList&lt;Handler&gt;();
handlerChain.add(new LogHandler());
handlerChain.add(new AuthorizationHandler());
handlerChain.add(new RoutingHandler());
bindingProvider.getBinding().setHandlerChain(handlerChain); // important!</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="message-context">3.3.2. Message Context</h4>
<div class="paragraph">
<p><code>MessageContext</code> is the super interface for all JAX-WS message contexts.
It extends <code>Map&lt;String,Object&gt;</code> with additional methods and constants to
manage a set of properties that enable handlers in a handler chain to
share processing related state. For example, a handler may use the put
method to insert a property in the message context that one or more
other handlers in the handler chain may subsequently obtain via the get
method.</p>
</div>
<div class="paragraph">
<p>Properties are scoped as either APPLICATION or HANDLER. All properties
are available to all handlers for an instance of an MEP on a particular
endpoint. E.g., if a logical handler puts a property in the message
context, that property will also be available to any protocol handlers
in the chain during the execution of an MEP instance. APPLICATION scoped
properties are also made available to client applications (see section
4.2.1) and service endpoint implementations. The defaultscope for a
property is HANDLER.</p>
</div>
<div class="sect4">
<h5 id="logical-message-context">Logical Message Context</h5>
<div class="paragraph">
<p>Logical Handlers are passed a message context of type
<code>LogicalMessageContext</code> when invoked. <code>LogicalMessageContext</code> extends
<code>MessageContext</code> with methods to obtain and modify the message payload,
it does not provide access to the protocol specific aspects of amessage.
A protocol binding defines what component of a message are available via
a logical message context. The SOAP binding defines that a logical
handler deployed in a SOAP binding can access the contents of the SOAP
body but not the SOAP headers whereas the XML/HTTP binding defines that
a logical handler can access the entire XML payload of a message.</p>
</div>
</div>
<div class="sect4">
<h5 id="soap-message-context">SOAP Message Context</h5>
<div class="paragraph">
<p>SOAP handlers are passed a <code>SOAPMessageContext</code> when invoked.
<code>SOAPMessageContext</code> extends <code>MessageContext</code> with methods to obtain and
modify the SOAP message payload.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fault-handling">3.3.3. Fault Handling</h4>
<div class="paragraph">
<p>An implementation may throw a <code>SOAPFaultException</code></p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void throwSoapFaultException()
{
   SOAPFactory factory = SOAPFactory.newInstance();
   SOAPFault fault = factory.createFault("this is a fault string!", new QName("http://foo", "FooCode"));
   fault.setFaultActor("mr.actor");
   fault.addDetail().addChildElement("test");
   thrownew SOAPFaultException(fault);
}</pre>
</div>
</div>
<div class="paragraph">
<p>or an application specific user exception</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void throwApplicationException() throws UserException
{
   thrownew UserException("validation", 123, "Some validation error");
}</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>In case of the latter, JBossWS generates the required fault wrapper
beans at runtime if they are not part of the deployment</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ws-annotations">3.4. WS Annotations</h3>
<div class="paragraph">
<p>For details, see <a href="https://jakarta.ee/specifications/xml-web-services/">Jakarta XML Web Services</a></p>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-servicemode">3.4.1. jakarta.xml.ws.ServiceMode</h4>
<div class="paragraph">
<p>The <code>ServiceMode</code> annotation is used to specify the mode for a provider
class, i.e. whether a provider wants to have access to protocol message
payloads (e.g. a SOAP body) or the entire protocol messages (e.g. a SOAP
envelope).</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webfault">3.4.2. jakarta.xml.ws.WebFault</h4>
<div class="paragraph">
<p>The <code>WebFault</code> annotation is used when mapping WSDL faults to Java
exceptions, see section 2.5. It is used to capture the name of the fault
element used when marshalling the JAXB type generated from the global
element referenced by the WSDL fault message. It can also be used to
customize the mapping of service specific exceptions to WSDL faults.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-requestwrapper">3.4.3. jakarta.xml.ws.RequestWrapper</h4>
<div class="paragraph">
<p>The <code>RequestWrapper</code> annotation is applied to the methods of an SEI. It
is used to capture the JAXB generated request wrapper bean and the
element name and namespace for marshalling / unmarshalling the bean. The
default value of localName element is the operationName as defined in
<code>WebMethod</code> annotation and the default value for the targetNamespace
element is the target namespace of the SEI.When starting from Java, this
annotation is used to resolve overloading conflicts in document literal
mode. Only the className element is required in this case.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-responsewrapper">3.4.4. jakarta.xml.ws.ResponseWrapper</h4>
<div class="paragraph">
<p>The <code>ResponseWrapper</code> annotation is applied to the methods of an SEI. It
is used to capture the JAXB generated response wrapper bean and the
element name and namespace for marshalling / unmarshalling the bean. The
default value of the localName element is the operationName as defined
in the <code>WebMethod</code> appended with ”Response” and the default value of the
targetNamespace element is the target namespace of the SEI. When
starting from Java, this annotation is used to resolve overloading
conflicts in document literal mode. Only the className element is
required in this case.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webserviceclient">3.4.5. jakarta.xml.ws.WebServiceClient</h4>
<div class="paragraph">
<p>The <code>WebServiceClient</code> annotation is specified on a generated service
class (see 2.7). It is used to associate a class with a specific Web
service, identify by a URL to a WSDL document and the qualified name of
a wsdl:service element.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webendpoint">3.4.6. jakarta.xml.ws.WebEndpoint</h4>
<div class="paragraph">
<p>The <code>WebEndpoint</code> annotation is specified on the getPortName() methods
of a generated service class (see 2.7). It is used to associate a get
method with a specific wsdl:port, identified by its local name (a
NCName).</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webserviceprovider">3.4.7. jakarta.xml.ws.WebServiceProvider</h4>
<div class="paragraph">
<p>The <code>WebServiceProvider</code> annotation is specified on classes that
implement a strongly typed <code>jakarta.xml.ws.Provider</code> . It is used to
declare that a class that satisfies the requirements for a provider (see
5.1) does indeed define a Web service endpoint, much like the
<code>WebService</code> annotation does for SEI-based endpoints.</p>
</div>
<div class="paragraph">
<p>The <code>WebServiceProvider</code> and <code>WebService</code> annotations are mutually
exclusive.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-bindingtype">3.4.8. jakarta.xml.ws.BindingType</h4>
<div class="paragraph">
<p>The <code>BindingType</code> annotation is applied to an endpoint implementation
class. It specifies the binding to use when publishing an endpoint of
this type.</p>
</div>
<div class="paragraph">
<p>The default binding for an endpoint is the SOAP 1.1/HTTP one.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webserviceref">3.4.9. jakarta.xml.ws.WebServiceRef</h4>
<div class="paragraph">
<p>The <code>WebServiceRef</code> annotation is used to declare a reference to a Web
service. It follows the resource pattern exemplified by the
<code>jakarta.annotation.Resource</code> annotation in Jakarta Annotations [32]. The
<code>WebServiceRef</code> annotation is required to be honored when running on the
JakartaEE platform, where it is subject to the common resource injection
rules described by the platform specification [33].</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-webservicerefs">3.4.10. jakarta.xml.ws.WebServiceRefs</h4>
<div class="paragraph">
<p>The <code>WebServiceRefs</code> annotation is used to declare multiple references
to Web services on a single class. It is necessary to work around the
limitation against specifying repeated annotations of the same type on any
given class, which prevents listing multiple <code>javax.ws.WebServiceRef</code>
annotations one after the other. This annotation follows the resource
pattern exemplified by the <code>javax.annotation.Resources</code> annotation in
JSR-250.</p>
</div>
<div class="paragraph">
<p>Since no name and type can be inferred in this case, each
<code>WebServiceRef</code> annotation inside a WebServiceRefs MUST contain name and
type elements with non-default values. The <code>WebServiceRef</code> annotation is
required to be honored when running on the Java EE 5 platform, where it
is subject to the common resource injection rules described by the
platform specification.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-action">3.4.11. jakarta.xml.ws.Action</h4>
<div class="paragraph">
<p>The <code>Action</code> annotation is applied to the methods of a SEI. It used to
generate the wsa:Action on wsdl:input and wsdl:output of each
wsdl:operation mapped from the annotated methods.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-xml-ws-faultaction">3.4.12. jakarta.xml.ws.FaultAction</h4>
<div class="paragraph">
<p>The <code>FaultAction</code> annotation is used within the <code>Action</code> annotation to
generate the wsa:Action element on the wsdl:fault element of each
wsdl:operation mapped from the annotated methods.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jakarta-web-service-metadata-annotations">3.5. Jakarta Web Service Metadata Annotations</h3>
<div class="paragraph">
<p>Jakarta Web Service Metadata defines the syntax and semantics of JAX-WS
metadata and default values.</p>
</div>
<div class="paragraph">
<p>For details, see <a href="https://jakarta.ee/specifications/web-services-metadata/">Jakarta Web Service
Metadata</a> .</p>
</div>
<div class="sect3">
<h4 id="jakarta-jws-webservice">3.5.1. jakarta.jws.WebService</h4>
<div class="paragraph">
<p>Marks a Java class as implementing a Web Service, or a Java interface as
defining a Web Service interface.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-webmethod">3.5.2. jakarta.jws.WebMethod</h4>
<div class="paragraph">
<p>Customizes a method that is exposed as a Web Service operation.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-oneway">3.5.3. jakarta.jws.OneWay</h4>
<div class="paragraph">
<p>Indicates that the given web method has only an input message and no
output. Typically, a oneway method returns the thread of control to the
calling application prior to executing the actual business method. A
JSR-181 processor is REQUIRED to report an error if an operation marked
<code>@Oneway</code> has a return value, declares any checked exceptions or has any
INOUT or OUT parameters.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-webparam">3.5.4. jakarta.jws.WebParam</h4>
<div class="paragraph">
<p>Customizes the mapping of an individual parameter to a Web Service
message part and XML element.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-webresult">3.5.5. jakarta.jws.WebResult</h4>
<div class="paragraph">
<p>Customizes the mapping of the return value to a WSDL part and XML
element.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-soapbinding">3.5.6. jakarta.jws.SOAPBinding</h4>
<div class="paragraph">
<p>Specifies the mapping of the Web Service onto the SOAP message protocol.</p>
</div>
<div class="paragraph">
<p>The <code>SOAPBinding</code> annotation has a target of <code>TYPE</code> and <code>METHOD</code> . The
annotation may be placed on a method if and only if the
<code>SOAPBinding.style</code> is <code>DOCUMENT</code> . Implementations MUST report an error
if the <code>SOAPBinding</code> annotation is placed on a method with a
<code>SOAPBinding.style</code> of <code>RPC</code> . Methods that do not have a <code>SOAPBinding</code>
annotation accept the <code>SOAPBinding</code> behavior defined on the type.</p>
</div>
</div>
<div class="sect3">
<h4 id="jakarta-jws-handlerchain">3.5.7. jakarta.jws.HandlerChain</h4>
<div class="paragraph">
<p>The <code>@HandlerChain</code> annotation associates the Web Service with an
externally defined handler chain.</p>
</div>
<div class="paragraph">
<p>It is an error to combine this annotation with the
<code>@SOAPMessageHandlers</code> annotation.</p>
</div>
<div class="paragraph">
<p>The <code>@HandlerChain</code> annotation MAY be present on the endpoint interface
and service implementation bean. The service implementation bean&#8217;s
<code>@HandlerChain</code> is used if <code>@HandlerChain</code> is present on both.</p>
</div>
<div class="paragraph">
<p>The <code>@HandlerChain</code> annotation MAY be specified on the type only. The
annotation target includes <code>METHOD</code> and <code>FIELD</code> for use by JAX-WS-2.x.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jax-ws-tools">4. JAX-WS Tools</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The JAX-WS tools provided by JBossWS can be used in a variety of ways.
First we will look at server-side development strategies, and then
proceed to the client.</p>
</div>
<div class="sect2">
<h3 id="server-side">4.1. Server side</h3>
<div class="paragraph">
<p>When developing a Web Service Endpoint (the server-side) you have the
option of starting from Java ( <em>bottom-up development</em> ), or from the
abstact contract (WSDL) that defines your service ( <em>top-down
development</em> ). If this is a new service (no existing contract), the
bottom-up approach is the fastest route; you only need to add a few
annotations to your classes to get a service up and running. However, if
developing a service with an already defined contract, it is far
simpler to use the top-down approach, since the provided tool will
generate the annotated code for you.</p>
</div>
<div class="paragraph">
<p>Bottom-up use cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Exposing an already existing EJB3 bean as a Web Service</p>
</li>
<li>
<p>Providing a new service, and wanting the contract to be generated for
you</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Top-down use cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Replacing the implementation of an existing Web Service, and you can&#8217;t
break compatibility with older clients</p>
</li>
<li>
<p>Exposing a service that conforms to a contract specified by a third
party (e.g. a vendor that calls back using an already defined
protocol).</p>
</li>
<li>
<p>Creating a service that adheres to the XML Schema and WSDL you
developed by hand up front</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following JAX-WS command line tools are included in JBossWS:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Command</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsprovide</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generates JAX-WS portable artifacts, and provides the
abstract contract. Used for bottom-up development.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsconsume</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Consumes the abstract contract (WSDL and Schema files), and
produces artifacts for both a server and client. Used for top-down and
client development</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="bottom-up-using-wsprovide">4.1.1. Bottom-Up (Using wsprovide)</h4>
<div class="paragraph">
<p>The bottom-up strategy involves developing the Java code for your
service, and then annotating it using JAX-WS annotations. These
annotations can be used to customize the contract that is generated for
the service. For example, you can change the operation name to map to
anything you like. However, all of the annotations have sensible
defaults, so only the @WebService annotation is required.</p>
</div>
<div class="paragraph">
<p>This can be as simple as creating a single class:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package echo;

@jakarta.jws.WebService
public class Echo
{
   public String echo(String input)
   {
      return input;
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>A JSE or EJB3 deployment can be built using this class, and it is the
only Java code needed to deploy on JBossWS. The WSDL, and all other Java
artifacts called "wrapper classes" will be generated at deploy
time. This actually goes beyond the JAX-WS specification, which requires
that wrapper classes be generated using an offline tool. The reason for
this requirement is purely a vendor implementation problem, and since we
do not believe in burdening a developer with a bunch of additional
steps, we generate these as well. However, if you want your deployment
to be portable to other application servers, you will need
to use a tool and add the generated classes to your deployment.</p>
</div>
<div class="paragraph">
<p>This is the primary purpose of the <em>wsprovide</em> tool, to generate
portable JAX-WS artifacts. Additionally, it can be used to "provide" the
abstract contract (WSDL file) for your service. This can be obtained by
invoking <em>wsprovide</em> using the "-w" option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ javac -d . Echo.java
$ wsprovide -w echo.Echo
Generating WSDL:
EchoService.wsdl
Writing Classes:
echo/jaxws/Echo.class
echo/jaxws/EchoResponse.class</pre>
</div>
</div>
<div class="paragraph">
<p>Inspecting the WSDL reveals a service called <em>EchoService</em> :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;service name='EchoService'&gt;
 &lt;port binding='tns:EchoBinding' name='EchoPort'&gt;
  &lt;soap:address location='REPLACE_WITH_ACTUAL_URL'/&gt;
 &lt;/port&gt;
&lt;/service&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>As expected, this service defines one operation, " <em>echo</em> ":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;portType name='Echo'&gt;
 &lt;operation name='echo' parameterOrder='echo'&gt;
  &lt;input message='tns:Echo_echo'/&gt;
  &lt;output message='tns:Echo_echoResponse'/&gt;
 &lt;/operation&gt;
&lt;/portType&gt;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Remember that when deploying on JBossWS you do not need to run this
tool. It is only needed for generating portable artifacts and/or the
abstract contract for the service.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s create a POJO endpoint for deployment on WildFly. A simple
<em>web.xml</em> needs to be created:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"
  version="5.0"&gt;

  &lt;servlet&gt;
    &lt;servlet-name&gt;Echo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;echo.Echo&lt;/servlet-class&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Echo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/Echo&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The <em>web.xml</em> and the single class can now be used to create a war:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ mkdir -p WEB-INF/classes
$ cp -rp echo WEB-INF/classes/
$ cp web.xml WEB-INF
$ jar cvf echo.war WEB-INF
added manifest
adding: WEB-INF/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/echo/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/echo/Echo.class(in = 340) (out= 247)(deflated 27%)
adding: WEB-INF/web.xml(in = 576) (out= 271)(deflated 52%)</pre>
</div>
</div>
<div class="paragraph">
<p>The war can then be deployed to the JBoss Application Server; this will internally
invoke wsprovide, which will generate the WSDL. If deployment was
successful, and you are using the default settings, it should be
available in the server management console.</p>
</div>
<div class="paragraph">
<p>For a portable JAX-WS deployment, the wrapper classes generated earlier
could be added to the deployment.</p>
</div>
</div>
<div class="sect3">
<h4 id="down-using-wsconsume">4.1.2. Down (Using wsconsume)</h4>
<div class="paragraph">
<p>The top-down development strategy begins with the abstract contract for
the service, which includes the WSDL file and zero or more schema files.
The <em>wsconsume</em> tool is then used to consume this contract, and produce
annotated Java classes (and optionally sources) that define it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>wsconsume may have problems with symlinks on Unix systems</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Using the WSDL file from the bottom-up example, a new Java
implementation that adheres to this service can be generated. The "-k"
option is passed to <em>wsconsume</em> to preserve the Java source files that
are generated, instead of providing just classes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ wsconsume -k EchoService.wsdl
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java</pre>
</div>
</div>
<div class="paragraph">
<p>The following table shows the purpose of each generated file:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">File</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Echo.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Service Endpoint Interface</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Echo_Type.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wrapper bean for request message</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EchoResponse.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wrapper bean for response message</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectFactory.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JAXB XML Registry</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">package-info.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holder for JAXB package annotations</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EchoService.java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used only by JAX-WS clients</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Examining the Service Endpoint Interface reveals annotations that are
more explicit than in the class written by hand in the bottom-up
example, however, these evaluate to the same contract:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebService(name = "Echo", targetNamespace = "http://echo/")
public interface Echo {
    @WebMethod
    @WebResult(targetNamespace = "")
    @RequestWrapper(localName = "echo", targetNamespace = "http://echo/", className = "echo.Echo_Type")
    @ResponseWrapper(localName = "echoResponse", targetNamespace = "http://echo/", className = "echo.EchoResponse")
    public String echo(
        @WebParam(name = "arg0", targetNamespace = "")
        String arg0);

}</pre>
</div>
</div>
<div class="paragraph">
<p>The only missing piece (for packaging) is the implementation
class, which can now be written, using the above interface.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package echo;

@jakarta.jws.WebService(endpointInterface="echo.Echo")
public class EchoImpl implements Echo
{
   public String echo(String arg0)
   {
      return arg0;
   }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client-side">4.2. Client Side</h3>
<div class="paragraph">
<p>Before going into detail on the client-side it is important to understand
the decoupling concept that is central to Web Services. Web Services are
not the best fit for internal RPC, even though they can be used in this
way. There are much better technologies for this (CORBA, and RMI for
example). Web Services was designed specifically for interoperable
coarse-grained correspondence. There is no expectation or guarantee that
any party participating in a Web Service interaction will be at any
particular location, running on any particular OS, or written in any
particular programming language, because of this, it is important to
clearly separate client and server implementations. The only thing they
should have in common is the abstract contract definition. If, for
whatever reason, your software does not adhere to this principal, then
you should not be using Web Services. For the above reasons, the
<strong><em>recommended methodology for developing a client is</em></strong> to follow <strong><em>the
top-down approach</em></strong> , even if the client is running on the same server.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s repeat the process of the top-down section, although using the
deployed WSDL, instead of the one generated offline by <em>wsprovide</em> . The
reason we do this is to get the right value for soap:address.
This value must be computed at deploy time, since it is based on
container configuration specifics. You could of course edit the WSDL
file yourself, although you need to ensure that the path is correct.</p>
</div>
<div class="paragraph">
<p>Offline version:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;service name='EchoService'&gt;
  &lt;port binding='tns:EchoBinding' name='EchoPort'&gt;
   &lt;soap:address location='REPLACE_WITH_ACTUAL_URL'/&gt;
  &lt;/port&gt;
&lt;/service&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Online version:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;service name="EchoService"&gt;
  &lt;port binding="tns:EchoBinding" name="EchoPort"&gt;
    &lt;soap:address location="http://localhost.localdomain:8080/echo/Echo"/&gt;
  &lt;/port&gt;
&lt;/service&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Using the online deployed version with <em>wsconsume</em> :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ wsconsume -k http://localhost:8080/echo/Echo?wsdl
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java</pre>
</div>
</div>
<div class="paragraph">
<p>The one class that was not examined in the top-down section, was
<code>EchoService.java</code> . Notice how it stores the location the WSDL was
obtained from.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebServiceClient(name = "EchoService", targetNamespace = "http://echo/", wsdlLocation = "http://localhost:8080/echo/Echo?wsdl")
public class EchoService extends Service
{
    private final static URL ECHOSERVICE_WSDL_LOCATION;

    static {
        URL url = null;
        try
        {
           url = new URL("http://localhost:8080/echo/Echo?wsdl");
        }
        catch (MalformedURLException e)
        {
           e.printStackTrace();
        }
        ECHOSERVICE_WSDL_LOCATION = url;
    }

    public EchoService(URL wsdlLocation, QName serviceName)
    {
         super(wsdlLocation, serviceName);
    }

    public EchoService()
    {
         super(ECHOSERVICE_WSDL_LOCATION, new QName("http://echo/", "EchoService"));
    }

    @WebEndpoint(name = "EchoPort")
    public Echo getEchoPort()
    {
         return (Echo)super.getPort(new QName("http://echo/", "EchoPort"), Echo.class);
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>This generated class extends the main client entry point
in JAX-WS, <code>jakarta.xml.ws.Service</code> . While <code>Service</code> can be used
directly, this is far simpler since it provides the configuration info
for you. The only method we really care about is the <code>getEchoPort()</code>
method, which returns an instance of the Service Endpoint Interface. Any
WS operation can then be called by just invoking a method on the
returned interface.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>It&#8217;s not recommended to refer to a remote WSDL URL in a production
application. This causes network I/O every time you instantiate the
Service Object. Instead, use the tool on a saved local copy, or use the
URL version of the constructor to provide a new WSDL location.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All that is left to do, is write and compile the client:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import echo.*;

public class EchoClient
{
   public static void main(String args[])
   {
      if (args.length != 1)
      {
          System.err.println("usage: EchoClient &lt;message&gt;");
          System.exit(1);
      }

      EchoService service = new EchoService();
      Echo echo = service.getEchoPort();
      System.out.println("Server said: " + echo.echo(args[0]));
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>It is easy to change the endpoint address of your operation at runtime,
setting the <em>ENDPOINT_ADDRESS_PROPERTY</em> as shown below:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>      EchoService service = new EchoService();
      Echo echo = service.getEchoPort();

      /* Set NEW Endpoint Location */
      String endpointURL = "http://NEW_ENDPOINT_URL";
      BindingProvider bp = (BindingProvider)echo;
      bp.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endpointURL);

      System.out.println("Server said: " + echo.echo(args[0]));</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ws-binding-customization">4.3. WS binding customization</h3>
<div class="paragraph">
<p>An introduction to binding customizations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://java.sun.com/webservices/docs/2.0/jaxws/customizations.html" class="bare">http://java.sun.com/webservices/docs/2.0/jaxws/customizations.html</a></p>
</li>
<li>
<p><a href="https://jax-ws.dev.java.net/source/browse/jax-ws/guide/docs/wsdl-customization.xsd?rev=1.2&amp;view=log">binding
schema</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The schema for the binding customization files can be found here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/1.5/tutorial/doc/JAXBUsing4.html" class="bare">https://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/1.5/tutorial/doc/JAXBUsing4.html</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="wsconsume">4.4. wsconsume</h3>
<div class="paragraph">
<p><em>wsconsume</em> is a command line tool and ant task that "consumes" the
abstract contract (WSDL file) and produces portable JAX-WS service and
client artifacts.</p>
</div>
<div class="sect3">
<h4 id="command-line-tool">4.4.1. Command Line Tool</h4>
<div class="paragraph">
<p>The command line tool has the following usage:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>usage: wsconsume [options] &lt;wsdl-url&gt;
options:
  -h, --help                  Show this help message
  -b, --binding=&lt;file&gt;        One or more JAX-WS or JAXB binding files
  -k, --keep                  Keep/Generate Java source
  -c  --catalog=&lt;file&gt;        Oasis XML Catalog file for entity resolution
  -j  --clientjar=&lt;name&gt;      Create a jar file of the generated artifacts for calling the webservice
  -p  --package=&lt;name&gt;        The target package for generated source
  -w  --wsdlLocation=&lt;loc&gt;    Value to use for @WebServiceClient.wsdlLocation
  -o, --output=&lt;directory&gt;    The directory to put generated artifacts
  -s, --source=&lt;directory&gt;    The directory to put Java source
  -q, --quiet                 Be somewhat more quiet
  -v, --verbose               Show full exception stack traces
  -l, --load-consumer         Load the consumer and exit (debug utility)
  -e, --extension             Enable SOAP 1.2 binding extension
  -a, --additionalHeaders     Enables processing of implicit SOAP headers
  -d, --encoding=&lt;charset&gt;    The charset encoding to use for generated sources
  -n, --nocompile             Do not compile generated sources</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>The wsdlLocation is used when creating the Service to be used by clients
and will be added to the @WebServiceClient annotation, for an endpoint
implementation based on the generated service endpoint interface you
will need to manually add the wsdlLocation to the @WebService annotation
on your web service implementation and not the service endpoint
interface.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="examples">Examples</h5>
<div class="paragraph">
<p>Generate artifacts in Java class form only:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsconsume Example.wsdl</pre>
</div>
</div>
<div class="paragraph">
<p>Generate source and class files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsconsume -k Example.wsdl</pre>
</div>
</div>
<div class="paragraph">
<p>Generate source and class files in a custom directory:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsconsume -k -o custom Example.wsdl</pre>
</div>
</div>
<div class="paragraph">
<p>Generate source and class files in the org.foo package:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsconsume -k -p org.foo Example.wsdl</pre>
</div>
</div>
<div class="paragraph">
<p>Generate source and class files using multiple binding files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsconsume -k -b wsdl-binding.xml -b schema1-binding.xml -b schema2-binding.xml</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="maven-plugin">4.4.2. Maven Plugin</h4>
<div class="paragraph">
<p>The wsconsume tools is included in the
<strong>org.jboss.ws.plugins:jaxws-tools-</strong> <strong>maven-</strong> <strong>plugin</strong> plugin. The plugin
has two goals for running the tool, <em>wsconsume</em> and <em>wsconsume-test</em> ,
which basically do the same during different maven build phases (the
former triggers the source generation during <em>generate-sources</em> phase,
the latter during the <em>generate-test-sources</em> one).</p>
</div>
<div class="paragraph">
<p>The <em>wsconsume</em> plugin has the following parameters:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bindingFiles</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JAXWS or JAXB binding file</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">classpathElements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Each classpathElement provides a library file to be
added to classpath</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$\{project.compileClasspathElements} or
$\{project.testClasspathElements}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">catalog</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oasis XML Catalog file for entity resolution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">targetPackage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The target Java package for generated code.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">generated</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bindingFiles</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One or more JAX-WS or JAXB binding file</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdlLocation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value to use for @WebServiceClient.wsdlLocation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">generated</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">outputDirectory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The output directory for generated artifacts.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$\{project.build.outputDirectory} or
$\{project.build.testOutputDirectory}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sourceDirectory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The output directory for Java source.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$\{project.build.directory}/generated-sources/wsconsume</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">verbose</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables more informational output about command progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdls</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The WSDL files or URLs to consume</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">extension</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enable SOAP 1.2 binding extension.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">encoding</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The charset encoding to use for generated sources.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$\{project.build.sourceEncoding}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">argLine</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional additional argline to be used when running in fork
mode; can be used to set endorse dir, enable debugging, etc. <strong><em>Example</em></strong>
<code>&lt;argLine&gt;-Djava.endorsed.dirs=&#8230;&#8203;&lt;/argLine&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fork</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not to run the generation task in a separate VM.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="examples-2">Examples</h5>
<div class="paragraph">
<p><em>wsconsume</em> can be used in your own project build by simply referencing the
<em>jaxws-tools-</em> <em>maven-</em> <em>plugin</em> in the configured plugins in the projects
pom.xml file.</p>
</div>
<div class="paragraph">
<p>The following example makes the plugin consume the test.wsdl file and
generate SEI and wrappers' java sources. The generated sources are then
compiled together with the other project classes.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.jboss.ws.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;jaxws-tools-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.2.0.Final&lt;/version&gt;
      &lt;configuration&gt;
        &lt;wsdls&gt;
          &lt;wsdl&gt;${basedir}/test.wsdl&lt;/wsdl&gt;
        &lt;/wsdls&gt;
      &lt;/configuration&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;goals&gt;
            &lt;goal&gt;wsconsume&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>You can also specify multiple wsdl files, as well as force the target
package, enable SOAP 1.2 binding and turn the tool&#8217;s verbose mode on:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.jboss.ws.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;jaxws-tools-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.2.0.Final&lt;/version&gt;
      &lt;configuration&gt;
       &lt;wsdls&gt;
        &lt;wsdl&gt;${basedir}/test.wsdl&lt;/wsdl&gt;
        &lt;wsdl&gt;${basedir}/test2.wsdl&lt;/wsdl&gt;
       &lt;/wsdls&gt;
       &lt;targetPackage&gt;foo.bar&lt;/targetPackage&gt;
       &lt;extension&gt;true&lt;/extension&gt;
       &lt;verbose&gt;true&lt;/verbose&gt;
      &lt;/configuration&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;goals&gt;
            &lt;goal&gt;wsconsume&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>If the wsconsume invocation is required for consuming a wsdl to
be used in the testsuite only, you might want to use the
<em>wsconsume-test</em> goal as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.jboss.ws.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;jaxws-tools-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.2.0.Final&lt;/version&gt;
      &lt;configuration&gt;
        &lt;wsdls&gt;
          &lt;wsdl&gt;${basedir}/test.wsdl&lt;/wsdl&gt;
        &lt;/wsdls&gt;
      &lt;/configuration&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;goals&gt;
            &lt;goal&gt;wsconsume-test&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="plugin-stack-dependency">Plugin stack dependency</h5>
<div class="paragraph">
<p>The plugin itself does not have an explicit
dependency on a JBossWS stack, as it&#8217;s meant for use with
implementations of any supported version of the <em>JBossWS SPI</em> . The
user is expected to set a dependency in his own <code>pom.xml</code> to the desired
<em>JBossWS</em> stack version. The plugin will rely on that in using the
proper tooling.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.jboss.ws.cxf&lt;/groupId&gt;
    &lt;artifactId&gt;jbossws-cxf-client&lt;/artifactId&gt;
    &lt;version&gt;5.1.0.Final&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Be careful when using this plugin with the Maven War Plugin as that
includes project dependencies into the generated application war
archive. To avoid that situation set <code>&lt;scope&gt;provided&lt;/scope&gt;</code> for the
<em>JBossWS</em> stack dependency.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Up to version 1.1.2.Final, the <em>artifactId</em> of the plugin was
<strong>maven-jaxws-tools-plugin</strong> .</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ant-task">4.4.3. Ant Task</h4>
<div class="paragraph">
<p>The <em>wsconsume</em> Ant task ( <em>org.jboss.ws.tools.ant.WSConsumeTask</em> ) has
the following attributes:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fork</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not to run the generation task in a separate VM.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">keep</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keep/Enable Java source code generation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">catalog</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oasis XML Catalog file for entity resolution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">package</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The target Java package for generated code.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">generated</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">binding</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A JAX-WS or JAXB binding file</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdlLocation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value to use for @WebServiceClient.wsdlLocation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">generated</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">encoding</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The charset encoding to use for generated sources</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">destdir</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The output directory for generated artifacts.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"output"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sourcedestdir</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The output directory for Java source.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">value of destdir</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">verbose</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables more informational output about command progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The WSDL file or URL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">extension</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enable SOAP 1.2 binding extension.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">additionalHeaders</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables processing of implicit SOAP headers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Users also need to put streamBuffer.jar and stax-ex.jar in the classpath
of the ant task to generate the appropriate artefacts.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The wsdlLocation is used when creating the Service to be used by clients
and will be added to the @WebServiceClient annotation.  For an endpoint
implementation based on the generated service endpoint interface, you
will need to manually add the wsdlLocation to the @WebService annotation
on your web service implementation and not the service endpoint
interface.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also, the following nested elements are supported:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Element</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">binding</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A JAXWS or JAXB binding file</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">jvmarg</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows setting of custom jvm arguments</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> </p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="examples-3">Examples</h5>
<div class="paragraph">
<p>The following command generates JAX-WS sources and classes in a separate
JVM with separate directories, a custom wsdl location attribute, and a list of binding files from foo.wsdl:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;wsconsume
  fork="true"
  verbose="true"
  destdir="output"
  sourcedestdir="gen-src"
  keep="true"
  wsdllocation="handEdited.wsdl"
  wsdl="foo.wsdl"&gt;
  &lt;binding dir="binding-files" includes="*.xml" excludes="bad.xml"/&gt;
&lt;/wsconsume&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wsprovide">4.5. wsprovide</h3>
<div class="paragraph">
<p><em>wsprovide</em> is a command line tool, Maven plugin and Ant task that
generates portable JAX-WS artifacts for a service endpoint
implementation. It also has the option to "provide" the abstract
contract for offline usage.</p>
</div>
<div class="sect3">
<h4 id="command-line-tool-2">4.5.1. Command Line Tool</h4>
<div class="paragraph">
<p>The command line tool has the following usage:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>usage: wsprovide [options] &lt;endpoint class name&gt;
options:
  -h, --help                  Show this help message
  -k, --keep                  Keep/Generate Java source
  -w, --wsdl                  Enable WSDL file generation
  -a, --address               The generated port soap:address in wsdl
  -c. --classpath=&lt;path&gt;      The classpath that contains the endpoint
  -o, --output=&lt;directory&gt;    The directory to put generated artifacts
  -r, --resource=&lt;directory&gt;  The directory to put resource artifacts
  -s, --source=&lt;directory&gt;    The directory to put Java source
  -e, --extension             Enable SOAP 1.2 binding extension
  -q, --quiet                 Be somewhat more quiet
  -t, --show-traces           Show full exception stack traces</pre>
</div>
</div>
<div class="sect4">
<h5 id="examples-4">Examples</h5>
<div class="paragraph">
<p>Generates wrapper classes for portable artifacts in the "generated"
directory:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsprovide -o generated foo.Endpoint</pre>
</div>
</div>
<div class="paragraph">
<p>Generates wrapper classes and WSDL in the "generated" directory</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsprovide -o generated -w foo.Endpoint</pre>
</div>
</div>
<div class="paragraph">
<p>Using an endpoint that references other jars</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsprovide -o generated -c application1.jar:application2.jar foo.Endpoint</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="maven-plugin-2">4.5.2. Maven Plugin</h4>
<div class="paragraph">
<p>The <em>wsprovide</em> tools is included in the
<strong>org.jboss.ws.plugins:jaxws-tools-</strong> <strong>maven-</strong> <strong>plugin</strong> plugin. The plugin
has two goals for running the tool, <em>wsprovide</em> and <em>wsprovide-test</em> ,
which basically do the same during different Maven build phases (the
former triggers the sources generation during <em>process-classes</em> phase,
the latter during the <em>process-test-classes</em> one).</p>
</div>
<div class="paragraph">
<p>The <em>wsprovide</em> plugin has the following parameters:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">testClasspathElements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Each classpathElement provides a library file to
be added to classpath</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$\{project.compileClasspathElements} or
$\{project.testClasspathElements}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">outputDirectory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The output directory for generated artifacts.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$\{project.build.outputDirectory} or
$\{project.build.testOutputDirectory}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">resourceDirectory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The output directory for resource artifacts
(WSDL/XSD).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$\{project.build.directory}/wsprovide/resources</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sourceDirectory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The output directory for Java source.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$\{project.build.directory}/wsprovide/java</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">extension</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enable SOAP 1.2 binding extension.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">generateWsdl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not to generate WSDL.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">verbose</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables more informational output about command progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">portSoapAddress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The generated port soap:address in the WSDL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>endpointClass</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Service Endpoint Implementation.</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> </p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="examples-5">Examples</h5>
<div class="paragraph">
<p><em>wsprovide</em> can be used in your own project build by simply referencing the
<em>jaxws-tools-</em> <em>maven-</em> <em>plugin</em> in the configured plugins in the
<em>pom.xml</em> file.</p>
</div>
<div class="paragraph">
<p>The following example makes the plugin provide the wsdl file and
artifact sources for the specified endpoint class:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.jboss.ws.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;jaxws-tools-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.2.0.Final&lt;/version&gt;
      &lt;configuration&gt;
        &lt;verbose&gt;true&lt;/verbose&gt;
        &lt;endpointClass&gt;org.jboss.test.ws.plugins.tools.wsprovide.TestEndpoint&lt;/endpointClass&gt;
        &lt;generateWsdl&gt;true&lt;/generateWsdl&gt;
      &lt;/configuration&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;goals&gt;
            &lt;goal&gt;wsprovide&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The following example does the same, but is meant for use in your own
testsuite:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.jboss.ws.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;jaxws-tools-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.2.0.Final&lt;/version&gt;
      &lt;configuration&gt;
        &lt;verbose&gt;true&lt;/verbose&gt;
        &lt;endpointClass&gt;org.jboss.test.ws.plugins.tools.wsprovide.TestEndpoint2&lt;/endpointClass&gt;
        &lt;generateWsdl&gt;true&lt;/generateWsdl&gt;
      &lt;/configuration&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;goals&gt;
            &lt;goal&gt;wsprovide-test&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="plugin-stack-dependency-2">Plugin stack dependency</h5>
<div class="paragraph">
<p>The plugin itself does not have an explicit
dependency on a JBossWS stack, as it&#8217;s meant for uses with
implementations of any supported version of the <em>JBossWS SPI</em> . The
user is expected to set a dependency in his own <code>pom.xml</code> to the desired
<em>JBossWS</em> stack version. The plugin will rely on the that for using the
proper tooling.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.jboss.ws.cxf&lt;/groupId&gt;
    &lt;artifactId&gt;jbossws-cxf-client&lt;/artifactId&gt;
    &lt;version&gt;5.1.0.Final&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Be careful when using this plugin with the Maven War Plugin as that
includes project dependencies in the generated application war
archive. Set <code>&lt;scope&gt;provided&lt;/scope&gt;</code> on the
<em>JBossWS</em> stack dependency to avoid that.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Up to version 1.1.2.Final, the <em>artifactId</em> of the plugin was
<strong>maven-jaxws-tools-plugin</strong> .</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ant-task-2">4.5.3. Ant Task</h4>
<div class="paragraph">
<p>The wsprovide ant task ( <em>org.jboss.ws.tools.ant.WSProvideTask</em> ) has
the following attributes:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fork</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not to run the generation task in a separate VM.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">keep</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keep/Enable Java source code generation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">destdir</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The output directory for generated artifacts.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"output"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">resourcedestdir</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The output directory for resource artifacts
(WSDL/XSD).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">value of destdir</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sourcedestdir</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The output directory for Java source.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">value of destdir</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">extension</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enable SOAP 1.2 binding extension.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">genwsdl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not to generate WSDL.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The generated port soap:address in wsdl.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">verbose</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables more informational output about command progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sei</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Service Endpoint Implementation.</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">classpath</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The classpath that contains the service endpoint
implementation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"."</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="examples-6">Examples</h5>
<div class="paragraph">
<p>The following command executes wsprovide in verbose mode with separate output directories for source, resources, and classes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;target name="test-wsproivde" depends="init"&gt;
  &lt;taskdef name="wsprovide" classname="org.jboss.ws.tools.ant.WSProvideTask"&gt;
    &lt;classpath refid="core.classpath"/&gt;
  &lt;/taskdef&gt;
  &lt;wsprovide
    fork="false"
    keep="true"
    destdir="out"
    resourcedestdir="out-resource"
    sourcedestdir="out-source"
    genwsdl="true"
    verbose="true"
    sei="org.jboss.test.ws.jaxws.jsr181.soapbinding.DocWrappedServiceImpl"&gt;
    &lt;classpath&gt;
      &lt;pathelement path="${tests.output.dir}/classes"/&gt;
    &lt;/classpath&gt;
  &lt;/wsprovide&gt;
&lt;/target&gt;</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced-user-guide">5. Advanced User Guide</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="logging">5.1. Logging</h3>
<div class="paragraph">
<p>Logging of inbound and outbound messages is a common need. Different
approaches are available for achieving that:</p>
</div>
<div class="sect3">
<h4 id="jax-ws-handler-approach">5.1.1. JAX-WS Handler approach</h4>
<div class="paragraph">
<p>A portable way of performing logging is writing a simple JAX-WS handler
dumping the messages that are passed to it; the handler can be added to
the desired client/endpoints (programmatically / using <code>@HandlerChain</code>
JAX-WS annotation).</p>
</div>
<div class="paragraph">
<p>The <a href="#predefined-client-and-endpoint-configurations">Predefined client and endpoint configurations</a>
mechanism allows user to add the logging handler to any client/endpoint
or to some of them only (in which case the <code>@EndpointConfig</code> annotation
/ JBossWS API is required though).</p>
</div>
</div>
<div class="sect3">
<h4 id="apache-cxf-approach">5.1.2. Apache CXF approach</h4>
<div class="paragraph">
<p>Apache CXF also comes with logging interceptors that can be easily used
to log messages to the console or configured client/server log files.
Those interceptors can be added to client, endpoint and buses in
multiple ways:</p>
</div>
<div class="sect4">
<h5 id="system-property">System property</h5>
<div class="paragraph">
<p>Setting the <code>org.apache.cxf.logging.enabled</code> system property to true
causes the logging interceptors to be added to any <code>Bus</code> instance being
created on the JVM.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>On WildFly, the system property is set by adding what follows to
the standalone / domain server configuration just after the extensions
section:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;system-properties&gt;
  &lt;property name="org.apache.cxf.logging.enabled" value="true"/&gt;
&lt;/system-properties&gt;</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="manual-interceptor-addition-and-logging-feature">Manual interceptor addition and logging feature</h5>
<div class="paragraph">
<p>Logging interceptors can be selectively added to endpoints using the
Apache CXF annotations <code>@org.apache.cxf.interceptor.InInterceptors</code> and
<code>@org.apache.cxf.interceptor.OutInterceptors</code> . The same is achieved on
the client side by programmatically adding new instances of the logging
interceptors to the client or the bus.</p>
</div>
<div class="paragraph">
<p>Apache CXF 3.2 has designated <code>@org.apache.cxf.feature.Features</code> the
preferred annotation for adding logging capabilities to clients and
endpoints. Annotation <code>@org.apache.cxf.annotations.Logging</code> and class
<code>org.apache.cxf.feature.LoggingFeature</code> have been deprecated.</p>
</div>
<div class="paragraph">
<p>Also in Apache CXF 3.2 classes
<code>LoggingInInterceptor, LoggingOutInterceptor,</code> and
<code>AbstractLoggingInterceptor</code> have been assigned a new package name. The
classes in package <code>org.apache.cxf.interceptor</code> have been deprecated.
These classes can now be found in package <code>org.apache.cxf.ext.logging</code>.</p>
</div>
<div class="paragraph">
<p>Please refer to the
<a href="http://cxf.apache.org/docs/debugging-and-logging.html#DebuggingandLogging-LoggingMessages">Apache
CXF documentation</a> for more details.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ws-support">5.2. WS-* support</h3>
<div class="paragraph">
<p>JBossWS includes most of the WS-* specification functionalities through
the integration with Apache CXF. In particular, the whole WS-Security
Policy framework is fully supported, enabling full contract driven
configuration of complex features like WS-Security.</p>
</div>
<div class="paragraph">
<p>More information can be found later in this chapter.</p>
</div>
</div>
<div class="sect2">
<h3 id="address-rewrite">5.3. Address rewrite</h3>
<div class="paragraph">
<p>JBossWS allows users to configure the <em>soap:address</em> attribute in the
wsdl contract of deployed services.</p>
</div>
<div class="sect3">
<h4 id="server-configuration-options">5.3.1. Server configuration options</h4>
<div class="paragraph">
<p>The configuration options are part of the
<a href="https://docs.wildfly.org/26/Admin_Guide.html#Web_services">webservices
subsystem section</a> of the WildFly domain model.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;subsystem xmlns="urn:jboss:domain:webservices:1.1"&gt;
  &lt;wsdl-host&gt;localhost&lt;/wsdl-host&gt;
  &lt;modify-wsdl-address&gt;true&lt;/modify-wsdl-address&gt;
&lt;!--
  &lt;wsdl-port&gt;8080&lt;/wsdl-port&gt;
  &lt;wsdl-secure-port&gt;8443&lt;/wsdl-secure-port&gt;
--&gt;
&lt;/subsystem&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>If the content of <em>&lt;soap:address&gt;</em> in the wsdl is a valid URL, JBossWS
will not rewrite it unless <em>modify-wsdl-address</em> is true. If the content
of <em>&lt;soap:address&gt;</em> is not a valid URL instead, JBossWS will always
rewrite it using the attribute values given below. Please note that the
variable <em>$\{jboss.bind.address}</em> can be used to set the address which
the application is bound to at each startup.</p>
</div>
<div class="paragraph">
<p>The wsdl-secure-port and wsdl-port attributes are used to explicitly
define the ports to be used for rewriting the SOAP address. If these
attributes are not set, the ports will be identified by querying the
list of installed connectors. If multiple connectors are found the port
of the first connector is used.</p>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-rewrite">5.3.2. Dynamic rewrite</h4>
<div class="paragraph">
<p>When the application server is bound to multiple addresses or
non-trivial real-world network architectures cause request for different
external addresses to hit the same endpoint, a static rewrite of the
soap:address may not be enough. JBossWS allows for both the soap:address
in the wsdl and the wsdl address in the console to be rewritten with the
host use in the client request. This way, users always get the right
wsdl address assuming they&#8217;re connecting to an instance having the
endpoint they&#8217;re looking for. To trigger this behaviour, the
<em>jbossws.undefined.host</em> value has to be specified for the <em>wsdl-host</em>
element.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;wsdl-host&gt;jbossws.undefined.host&lt;/wsdl-host&gt;
&lt;modify-wsdl-address&gt;true&lt;/modify-wsdl-address&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Of course, when a confidential transport address is required, the
addresses are always rewritten using https protocol and the port
currently configured for the https/ssl connector.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-through-deployment-descriptor">5.4. Configuration through deployment descriptor</h3>
<div class="paragraph">
<p>The <code>jboss-webservices.xml</code> deployment descriptor can be used to provide
additional configuration for a given deployment. The expected location
of it is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>META-INF/jboss-webservices.xml</code> for EJB webservice deployments (JAR
archives)</p>
</li>
<li>
<p><code>WEB-INF/jboss-webservices.xml</code> for POJO webservice deployments and
EJB webservice endpoints bundled in <code>WAR</code> archives</p>
</li>
<li>
<p>META-INF/jboss-webservices.xml for EAR archives containing webservices
deployment archives.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In case of jboss-webservices.xml descriptor included in both EAR and
included JAR/WAR archive, the contents of the descriptor included in the
JAR/WAR archives override the contents of the descriptor in the parent
EAR archive.</p>
</div>
<div class="paragraph">
<p>The structure of the file is the following (schemas are available
<a href="https://github.com/jbossws/jbossws-spi/tree/main/src/main/resources/schema">here</a>
):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;webservices&gt;
  &lt;context-root/&gt;?
  &lt;config-name/&gt;?
  &lt;config-file/&gt;?
  &lt;property&gt;*
    &lt;name/&gt;
    &lt;value/&gt;
  &lt;/property&gt;
  &lt;port-component&gt;*
    &lt;ejb-name/&gt;
    &lt;port-component-name/&gt;
    &lt;port-component-uri/&gt;?
    &lt;auth-method/&gt;?
    &lt;transport-guarantee/&gt;?
    &lt;secure-wsdl-access/&gt;?
  &lt;/port-component&gt;
  &lt;webservice-description&gt;*
    &lt;webservice-description-name/&gt;
    &lt;wsdl-publish-location/&gt;?
  &lt;/webservice-description&gt;
&lt;/webservices&gt;</pre>
</div>
</div>
<div class="sect3">
<h4 id="context-root-element">5.4.1. context-root element</h4>
<div class="paragraph">
<p>Element <code>&lt;context-root&gt;</code> can be used to customize context root of
webservices deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;webservices&gt;
  &lt;context-root&gt;foo&lt;/context-root&gt;
&lt;/webservices&gt;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="config-name-and-config-file-elements">5.4.2. config-name and config-file elements</h4>
<div class="paragraph">
<p>Elements <code>&lt;config-name&gt;</code> and <code>&lt;config-file&gt;</code> can be used to associate
any endpoint provided in the deployment with a given
<a href="#predefined-client-and-endpoint-configurations">Predefined client and endpoint configurations</a> . Endpoint configuration are
either specified in the referenced config file or in the WildFly domain
model (webservices subsystem). For further details on the endpoint
configurations and their management in the domain model, please see the
related
<a href="https://docs.wildfly.org/26/Admin_Guide.html#Web_services">documentation</a>
.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;webservices&gt;
  &lt;config-name&gt;Standard WSSecurity Endpoint&lt;/config-name&gt;
  &lt;config-file&gt;META-INF/custom.xml&lt;/config-file&gt;
&lt;/webservices&gt;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="property-element">5.4.3. property element</h4>
<div class="paragraph">
<p><code>&lt;property&gt;</code> elements can be used to setup simple property values to
configure the ws stack behavior. Allowed property names and values are
mentioned in the guide under related topics.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;property&gt;
  &lt;name&gt;prop.name&lt;/name&gt;
  &lt;value&gt;prop.value&lt;/value&gt;
&lt;/property&gt;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="component-element">5.4.4. component element</h4>
<div class="paragraph">
<p>Element <code>&lt;port-component&gt;</code> can be used to customize EJB endpoint target
URI or to configure security related properties.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;webservices&gt;
  &lt;port-component&gt;
    &lt;ejb-name&gt;TestService&lt;/ejb-name&gt;
    &lt;port-component-name&gt;TestServicePort&lt;/port-component-name&gt;
    &lt;port-component-uri&gt;/*&lt;/port-component-uri&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
    &lt;transport-guarantee&gt;NONE&lt;/transport-guarantee&gt;
    &lt;secure-wsdl-access&gt;true&lt;/secure-wsdl-access&gt;
  &lt;/port-component&gt;
&lt;/webservices&gt;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webservice-description-element">5.4.5. webservice-description element</h4>
<div class="paragraph">
<p>Element <code>&lt;webservice-description&gt;</code> can be used to customize (override)
webservice WSDL publish location.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;webservices&gt;
  &lt;webservice-description&gt;
    &lt;webservice-description-name&gt;TestService&lt;/webservice-description-name&gt;
    &lt;wsdl-publish-location&gt;file:///bar/foo.wsdl&lt;/wsdl-publish-location&gt;
  &lt;/webservice-description&gt;
&lt;/webservices&gt;</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="schema-validation-of-soap-messages">5.5. Schema validation of SOAP messages</h3>
<div class="paragraph">
<p>Apache CXF has a feature for validating incoming and outgoing SOAP
messages on both client and server side. The validation is performed
against the relevant schema in the endpoint wsdl contract (server side)
or the wsdl contract used for building up the service proxy (client
side).</p>
</div>
<div class="paragraph">
<p>Schema validation can be turned on programmatically on client side</p>
</div>
<div class="literalblock">
<div class="content">
<pre>((BindingProvider)proxy).getRequestContext().put("schema-validation-enabled", true);</pre>
</div>
</div>
<div class="paragraph">
<p>or using the <code>@org.apache.cxf.annotations.SchemaValidation</code> annotation
on server side</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import jakarta.jws.WebService;
import org.apache.cxf.annotations.SchemaValidation;

@WebService(...)
@SchemaValidation
public class ValidatingHelloImpl implements Hello {
   ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, any endpoint and client running in-container can be
associated to a JBossWS <a href="#predefined-client-and-endpoint-configurations">Predefined client and endpoint configurations</a>
having the <code>schema-validation-enabled</code> property set to <code>true</code> in the
referenced config file.</p>
</div>
<div class="paragraph">
<p>Finally, JBossWS also allows for server-wide (default) setup of schema
validation by using the <em>Standard-Endpoint-Config</em> and
<em>Standard-Client-Config</em> special configurations (which apply to any
client / endpoint unless a different configuration is specified for
them)</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;subsystem xmlns="urn:jboss:domain:webservices:1.2"&gt;
    ...
    &lt;endpoint-config name="Standard-Endpoint-Config"&gt;
        &lt;property name="schema-validation-enabled" value="true"/&gt;
    &lt;/endpoint-config&gt;
    ...
    &lt;client-config name="Standard-Client-Config"&gt;
        &lt;property name="schema-validation-enabled" value="true"/&gt;
    &lt;/client-config&gt;
&lt;/subsystem&gt;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaxb-introductions">5.6. JAXB Introductions</h3>
<div class="paragraph">
<p>One common complaint from the JAXB users is the lack of support
for binding 3rd party classes. The scenario is this: you are trying to
annotate your classes with JAXB annotations to make it XML bindable, but
some classes are coming from libraries and JDK, and thus you
cannot put necessary JAXB annotations on it.</p>
</div>
<div class="paragraph">
<p>To solve this JAXB has been designed to provide hooks for programmatic
introduction of annotations to the runtime.</p>
</div>
<div class="paragraph">
<p>This is currently leveraged by the JBoss JAXB Introductions project,
in which users can define annotations in XML and make JAXB see those
as if those were in the class files (perhaps coming from 3rd party
libraries).</p>
</div>
<div class="paragraph">
<p>Look at the <a href="http://community.jboss.org/docs/DOC-10075">JAXB
Introductions page</a> on the wiki and at the examples in the sources.</p>
</div>
</div>
<div class="sect2">
<h3 id="wsdl-system-properties-expansion">5.7. WSDL system properties expansion</h3>
<div class="paragraph">
<p>See <a href="#published-wsdl-customization">Published WSDL customization</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="predefined-client-and-endpoint-configurations">5.8. Predefined client and endpoint configurations</h3>
<div class="sect3">
<h4 id="overview">5.8.1. Overview</h4>
<div class="paragraph">
<p>JBossWS permits extra setup configuration data to be predefined and
associated with an endpoint or a client. Configurations can include
JAX-WS handlers and key/value property declarations that control JBossWS
and Apache CXF internals. Predefined configurations can be used for
JAX-WS client and JAX-WS endpoint setup.</p>
</div>
<div class="paragraph">
<p>Configurations can be defined in the webservice subsystem and in an
application&#8217;s deployment descriptor file. There can be many
configuration definitions in the webservice subsystem and in an
application. Each configuration must have a name that is unique within
the server. Configurations defined in an application are local to the
application. Endpoint implementations declare the use of a specific
configuration through the use of the
<code>org.jboss.ws.api.annotation.EndpointConfig</code> annotation. An endpoint
configuration defined in the webservices subsystem is available to all
deployed applications on the server container and can be referenced by
name in the annotation. An endpoint configuration defined in an
application must be referenced by both deployment descriptor file name
and configuration name by the annotation.</p>
</div>
<div class="paragraph">
<p><strong>Handlers</strong></p>
</div>
<div class="paragraph">
<p>Each endpoint configuration may be associated with zero or more PRE and
POST handler chains. Each handler chain may include JAX-WS handlers. For
outbound messages the PRE handler chains are executed before any handler
that is attached to the endpoint using the standard means, such as with
annotation @HandlerChain, and POST handler chains are executed after
those objects have executed. For inbound messages the POST handler
chains are executed before any handler that is attached to the endpoint
using the standard means and the PRE handler chains are executed after
those objects have executed.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>* Server inbound messages
Client --&gt; ... --&gt; POST HANDLER --&gt; ENDPOINT HANDLERS --&gt; PRE HANDLERS --&gt; Endpoint

* Server outbound messages
Endpoint --&gt; PRE HANDLER --&gt; ENDPOINT HANDLERS --&gt; POST HANDLERS --&gt; ... --&gt; Client</pre>
</div>
</div>
<div class="paragraph">
<p>The same applies for client configurations.</p>
</div>
<div class="paragraph">
<p><strong>Properties</strong></p>
</div>
<div class="paragraph">
<p>Key/value properties are used for controlling both some Apache CXF
internals and some JBossWS options. Specific supported values are
mentioned where relevant in the rest of the documentation.</p>
</div>
</div>
<div class="sect3">
<h4 id="assigning-configurations">5.8.2. Assigning configurations</h4>
<div class="paragraph">
<p>Endpoints and clients are assigned configuration through different
means. Users can explicitly require a given configuration or rely on
container defaults. The assignment process can be split up as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Explicit assignment through annotations (for endpoints) or API
programmatic usage (for clients)</p>
</li>
<li>
<p>Automatic assignment of configurations from default descriptors</p>
</li>
<li>
<p>Automatic assignment of configurations from container</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="explicit-configuration-assignment">Explicit configuration assignment</h5>
<div class="paragraph">
<p>The explicit configuration assignment is meant for developer that know
in advance their endpoint or client has to be setup according to a
specified configuration. The configuration is either coming from a
descriptor that is included in the application deployment, or is
included in the application server webservices subsystem management
model.</p>
</div>
<div class="sect5">
<h6 id="configuration-deployment-descriptor">Configuration Deployment Descriptor</h6>
<div class="paragraph">
<p>Jakarta EE archives that can contain JAX-WS client and endpoint
implementations can also contain predefined client and endpoint
configuration declarations. All endpoint/client configuration
definitions for a given archive must be provided in a single deployment
descriptor file, which must be an implementation of schema
<a href="https://github.com/jbossws/jbossws-spi/blob/main/src/main/resources/schema/jbossws-jaxws-config_5_0.xsd">jbossws-jaxws-config</a>
. Many endpoint/client configurations can be defined in the deployment
descriptor file. Each configuration must have a name that is unique
within the server on which the application is deployed. The
configuration name can&#8217;t be referred to by endpoint/client
implementations outside the application. Here is an example of a
descriptor, containing two endpoint configurations:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:5.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jakartaee="xmlns:jakartaee="https://jakarta.ee/xml/ns/jakartaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:5.0 schema/jbossws-jaxws-config_5_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.jbws3282.Endpoint4Impl&lt;/config-name&gt;
    &lt;pre-handler-chains&gt;
      &lt;jakartaee:handler-chain&gt;
        &lt;jakartaee:handler&gt;
          &lt;jakartaee:handler-name&gt;Log Handler&lt;/jakartaee:handler-name&gt;
          &lt;jakartaee:handler-class&gt;org.jboss.test.ws.jaxws.jbws3282.LogHandler&lt;/jakartaee:handler-class&gt;
        &lt;/jakartaee:handler&gt;
      &lt;/jakartaee:handler-chain&gt;
    &lt;/pre-handler-chains&gt;
    &lt;post-handler-chains&gt;
      &lt;jakartaee:handler-chain&gt;
        &lt;jakartaee:handler&gt;
          &lt;jakartaee:handler-name&gt;Routing Handler&lt;/jakartaee:handler-name&gt;
          &lt;jakartaee:handler-class&gt;org.jboss.test.ws.jaxws.jbws3282.RoutingHandler&lt;/jakartaee:handler-class&gt;
        &lt;/jakartaee:handler&gt;
      &lt;/jakartaee:handler-chain&gt;
    &lt;/post-handler-chains&gt;
  &lt;/endpoint-config&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;EP6-config&lt;/config-name&gt;
    &lt;post-handler-chains&gt;
      &lt;jakartaee:handler-chain&gt;
        &lt;jakartaee:handler&gt;
          &lt;jakartaee:handler-name&gt;Authorization Handler&lt;/jakartaee:handler-name&gt;
          &lt;jakartaee:handler-class&gt;org.jboss.test.ws.jaxws.jbws3282.AuthorizationHandler&lt;/jakartaee:handler-class&gt;
        &lt;/jakartaee:handler&gt;
      &lt;/jakartaee:handler-chain&gt;
    &lt;/post-handler-chains&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, client configurations can be specified in descriptors (still
implementing the schema mentioned above):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:5.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jakartaee="https://jakarta.ee/xml/ns/jakartaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:5.0 schema/jbossws-jaxws-config_5_0.xsd"&gt;
  &lt;client-config&gt;
    &lt;config-name&gt;Custom Client Config&lt;/config-name&gt;
    &lt;pre-handler-chains&gt;
      &lt;jakartaee:handler-chain&gt;
        &lt;jakartaee:handler&gt;
          &lt;jakartaee:handler-name&gt;Routing Handler&lt;/jakartaee:handler-name&gt;
          &lt;jakartaee:handler-class&gt;org.jboss.test.ws.jaxws.clientConfig.RoutingHandler&lt;/jakartaee:handler-class&gt;
        &lt;/jakartaee:handler&gt;
        &lt;jakartaee:handler&gt;
          &lt;jakartaee:handler-name&gt;Custom Handler&lt;/jakartaee:handler-name&gt;
          &lt;jakartaee:handler-class&gt;org.jboss.test.ws.jaxws.clientConfig.CustomHandler&lt;/jakartaee:handler-class&gt;
        &lt;/jakartaee:handler&gt;
      &lt;/jakartaee:handler-chain&gt;
    &lt;/pre-handler-chains&gt;
  &lt;/client-config&gt;
  &lt;client-config&gt;
    &lt;config-name&gt;Another Client Config&lt;/config-name&gt;
    &lt;post-handler-chains&gt;
      &lt;jakartaee:handler-chain&gt;
        &lt;jakartaee:handler&gt;
          &lt;jakartaee:handler-name&gt;Routing Handler&lt;/jakartaee:handler-name&gt;
          &lt;jakartaee:handler-class&gt;org.jboss.test.ws.jaxws.clientConfig.RoutingHandler&lt;/jakartaee:handler-class&gt;
        &lt;/jakartaee:handler&gt;
      &lt;/jakartaee:handler-chain&gt;
    &lt;/post-handler-chains&gt;
  &lt;/client-config&gt;
&lt;/jaxws-config&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="application-server-configurations">Application server configurations</h6>
<div class="paragraph">
<p>WildFly allows declaring JBossWS client and server predefined
configurations in the <em>webservices</em> subsystem section of the server
model. As a consequence it is possible to declare server-wide handlers
to be added to the chain of each endpoint or client assigned to a given
configuration.</p>
</div>
<div class="paragraph">
<p>Please refer to the
<a href="https://docs.wildfly.org/26/Admin_Guide.html#Web_services">WildFly
documentation</a> for details on managing the <em>webservices</em> subsystem such
as adding, removing and modifying handlers and properties.</p>
</div>
<div class="paragraph">
<p>The allowed contents in the <em>webservices</em> subsystem are defined by the
<a href="https://github.com/wildfly/wildfly/blob/main/webservices/server-integration/src/main/resources/schema/jboss-as-webservices_2_0.xsd">schema</a>
included in the application server.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Standard configurations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Clients running in-container as well as endpoints are assigned standard
configurations by default. The defaults are used unless different
configurations are set as described on this page. This enables
administrators to tune the default handler chains for client and
endpoint configurations. The names of the default client and endpoint
configurations, used in the webservices subsystem are
<code>Standard-Client-Config</code> and <code>Standard-Endpoint-Config</code> respectively.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Handlers classloading</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When setting a server-wide handler, please note the handler class needs
to be available through each ws deployment classloader. As a consequence
proper module dependencies might need to be specified in the deployments
that are going to leverage a given predefined configuration. A shortcut
is to add a dependency to the module containing the handler class in one
of the modules which are already automatically set as dependencies to
any deployment, for instance <code>org.jboss.ws.spi</code> .</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Examples</p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;subsystem xmlns="urn:jboss:domain:webservices:2.0"&gt;
    &lt;!-- ... --&gt;
    &lt;endpoint-config name="Standard-Endpoint-Config"/&gt;
    &lt;endpoint-config name="Recording-Endpoint-Config"&gt;
        &lt;pre-handler-chain name="recording-handlers" protocol-bindings="##SOAP11_HTTP ##SOAP11_HTTP_MTOM ##SOAP12_HTTP ##SOAP12_HTTP_MTOM"&gt;
            &lt;handler name="RecordingHandler" class="org.jboss.ws.common.invocation.RecordingServerHandler"/&gt;
        &lt;/pre-handler-chain&gt;
    &lt;/endpoint-config&gt;
    &lt;client-config name="Standard-Client-Config"/&gt;
&lt;/subsystem&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:5.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:jakartaee="https://jakarta.ee/xml/ns/jakartaee" xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:5.0 schema/jbossws-jaxws-config_5_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom WS-Security Endpoint&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.username&lt;/property-name&gt;
      &lt;property-value&gt;bob&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.username&lt;/property-name&gt;
      &lt;property-value&gt;alice&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.callback-handler&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.KeystorePasswordCallback&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;subsystem xmlns="urn:jboss:domain:webservices:2.0"&gt;
    &lt;!-- ... --&gt;
    &lt;endpoint-config name="Standard-Endpoint-Config"&gt;
        &lt;property name="schema-validation-enabled" value="true"/&gt;
    &lt;/endpoint-config&gt;
    &lt;!-- ... --&gt;
    &lt;client-config name="Standard-Client-Config"&gt;
        &lt;property name="schema-validation-enabled" value="true"/&gt;
    &lt;/client-config&gt;
&lt;/subsystem&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="endpointconfig-annotation">EndpointConfig annotation</h6>
<div class="paragraph">
<p>Once a configuration is available to a given application, the
<code>org.jboss.ws.api.annotation.EndpointConfig</code> annotation is used to
assign an endpoint configuration to a JAX-WS endpoint implementation.
When assigning a configuration that is defined in the webservices
subsystem only the configuration name is specified. When assigning a
configuration that is defined in the application, the relative path to
the deployment descriptor and the configuration name must be specified.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@EndpointConfig(configFile = "WEB-INF/my-endpoint-config.xml", configName = "Custom WS-Security Endpoint")
public class ServiceImpl implements ServiceIface
{
   public String sayHello()
   {
      return "Secure Hello World!";
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="jaxws-feature">JAXWS Feature</h6>
<div class="paragraph">
<p>The most practical way of setting a configuration is using
<code>org.jboss.ws.api.configuration.ClientConfigFeature</code> , a JAX-WS <code>Feature</code>
extension provided by JBossWS:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import org.jboss.ws.api.configuration.ClientConfigFeature;

...

Service service = Service.create(wsdlURL, serviceName);
Endpoint port = service.getPort(Endpoint.class, new ClientConfigFeature("META-INF/my-client-config.xml", "Custom Client Config"));
port.echo("Kermit");

... or ....

port = service.getPort(Endpoint.class, new ClientConfigFeature("META-INF/my-client-config.xml", "Custom Client Config"), true); //setup properties too from the configuration
port.echo("Kermit");
... or ...

port = service.getPort(Endpoint.class, new ClientConfigFeature(null, testConfigName)); //reads from current container configurations if available
port.echo("Kermit");</pre>
</div>
</div>
<div class="paragraph">
<p>JBossWS parses the specified configuration file. The configuration file
must be found as a resource by the classloader of the current thread.
The
<a href="https://github.com/jbossws/jbossws-spi/tree/main/src/main/resources/schema/jbossws-jaxws-config_5_0.xsd">jbossws-jaxws-config
schema</a> defines the descriptor contents and is included in the
<em>jbossws-spi</em> artifact.</p>
</div>
</div>
<div class="sect5">
<h6 id="explicit-setup-through-api">Explicit setup through API</h6>
<div class="paragraph">
<p>Alternatively, JBossWS API comes with facility classes that can be used
for assigning configurations when building a client. JAX-WS handlers read
from client configurations as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import org.jboss.ws.api.configuration.ClientConfigUtil;
import org.jboss.ws.api.configuration.ClientConfigurer;

...

Service service = Service.create(wsdlURL, serviceName);
Endpoint port = service.getPort(Endpoint.class);
BindingProvider bp = (BindingProvider)port;
ClientConfigUtil.setConfigHandlers(bp, "META-INF/my-client-config.xml", "Custom Client Config 1");
port.echo("Kermit");

...

ClientConfigurer configurer = ClientConfigUtil.resolveClientConfigurer();
configurer.setConfigHandlers(bp, "META-INF/my-client-config.xml", "Custom Client Config 2");
port.echo("Kermit");

...

configurer.setConfigHandlers(bp, "META-INF/my-client-config.xml", "Custom Client Config 3");
port.echo("Kermit");


...

configurer.setConfigHandlers(bp, null, "Container Custom Client Config"); //reads from current container configurations if available
port.echo("Kermit");</pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>similarly, properties are read from client configurations as
follows:</p>
</li>
</ol>
</div>
<div class="literalblock">
<div class="content">
<pre>import org.jboss.ws.api.configuration.ClientConfigUtil;
import org.jboss.ws.api.configuration.ClientConfigurer;

...

Service service = Service.create(wsdlURL, serviceName);
Endpoint port = service.getPort(Endpoint.class);

ClientConfigUtil.setConfigProperties(port, "META-INF/my-client-config.xml", "Custom Client Config 1");
port.echo("Kermit");

...

ClientConfigurer configurer = ClientConfigUtil.resolveClientConfigurer();
configurer.setConfigProperties(port, "META-INF/my-client-config.xml", "Custom Client Config 2");
port.echo("Kermit");

...

configurer.setConfigProperties(port, "META-INF/my-client-config.xml", "Custom Client Config 3");
port.echo("Kermit");


...

configurer.setConfigProperties(port, null, "Container Custom Client Config"); //reads from current container configurations if available
port.echo("Kermit");</pre>
</div>
</div>
<div class="paragraph">
<p>The default <code>ClientConfigurer</code> implementation parses the specified
configuration file, if any, after having resolved it as a resources
using the current thread context classloader. The
<a href="https://github.com/jbossws/jbossws-spi/tree/main/src/main/resources/schema/jbossws-jaxws-config_5_0.xsd">jbossws-jaxws-config
schema</a> defines the descriptor contents and is included in the
<em>jbossws-spi</em> artifact.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="automatic-configuration-from-default-descriptors">Automatic configuration from default descriptors</h5>
<div class="paragraph">
<p>In some cases, the application developer might not be aware of the
configuration that will need to be used for its client and endpoint
implementation, perhaps because that&#8217;s a concern of the application
deployer. In other cases, explicit usage (compile time dependency) of
JBossWS API might not be accepted. To cope with such scenarios, JBossWS
allows including default client ( <code>jaxws-client-config.xml</code> ) and
endpoint ( <code>jaxws-endpoint-config.xml</code> ) descriptor within the
application (in its root), which are parsed for getting configurations
any time a configuration file name is not specified.</p>
</div>
<div class="paragraph">
<p>If the configuration name is also not specified, JBossWS automatically
looks for a configuration named the same as</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the endpoint implementation class (full qualified name), in case of
JAX-WS endpoints;</p>
</li>
<li>
<p>the service endpoint interface (full qualified name), in case of
JAX-WS clients.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>No automatic configuration name is selected for <code>Dispatch</code> clients.</p>
</div>
<div class="paragraph">
<p>So, for instance, an endpoint implementation class
<code>org.foo.bar.EndpointImpl</code> for which no pre-defined configuration is
explicitly set will cause JBossWS to look for a
<em>org.foo.bar.EndpointImpl</em> named configuration within a
<em>jaxws-endpoint-config.xml</em> descriptor in the root of the application
deployment. Similarly, on the client side, a client proxy implementing
<code>org.foo.bar.Endpoint</code> interface (SEI) will have the setup read from a
<em>org.foo.bar.Endpoint</em> named configuration in <em>jaxws-client-config.xml</em>
descriptor.</p>
</div>
</div>
<div class="sect4">
<h5 id="automatic-configuration-assignment-from-container-setup">Automatic configuration assignment from container setup</h5>
<div class="paragraph">
<p>JBossWS fall-backs to getting predefined configurations from the
container setup whenever no explicit configuration has been provided and
the default descriptors are either not available or do not contain
relevant configurations. This gives additional control on the JAX-WS
client and endpoint setup to administrators, as the container setup can
be managed independently of the deployed applications.</p>
</div>
<div class="paragraph">
<p>JBossWS hence accesses the webservices subsystem the same as explained
above for explicitly named configuration; the default configuration
names used for look are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the endpoint implementation class (full qualified name), in case of
JAX-WS endpoints;</p>
</li>
<li>
<p>the service endpoint interface (full qualified name), in case of
JAX-WS clients.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Dispatch</code> clients are not automatically configured. If no configuration
is found using names computed as above, the <code>Standard-Client-Config</code> and
<code>Standard-Endpoint-Config</code> configurations are used for clients and
endpoints respectively</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="authentication">5.9. Authentication</h3>
<div class="sect3">
<h4 id="authentication-2">5.9.1. Authentication</h4>
<div class="paragraph">
<p>Here the simplest way to authenticate a web service user with JBossWS is
explained.</p>
</div>
<div class="paragraph">
<p>First we secure the access to the SLSB as we would do for normal (non
web service) invocations: this can be easily done through the
@RolesAllowed, @PermitAll, @DenyAll annotation. The allowed user roles
can be set with these annotations both on the bean class and on any of
its business methods.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@Stateless
@RolesAllowed("friend")
public class EndpointEJB implements EndpointInterface
{
  ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Similarly POJO endpoints are secured the same way as we do for normal
web applications in web.xml:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;security-constraint&gt;
  &lt;web-resource-collection&gt;
    &lt;web-resource-name&gt;All resources&lt;/web-resource-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/web-resource-collection&gt;
  &lt;auth-constraint&gt;
    &lt;role-name&gt;friend&lt;/role-name&gt;
  &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;

&lt;security-role&gt;
  &lt;role-name&gt;friend&lt;/role-name&gt;
&lt;/security-role&gt;</pre>
</div>
</div>
<div class="sect4">
<h5 id="specify-the-security-domain">Specify the security domain</h5>
<div class="paragraph">
<p>Next, specify the security domain for this deployment. This is performed
using the <code>@SecurityDomain</code> annotation for EJB3 endpoints</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@Stateless
@SecurityDomain("JBossWS")
@RolesAllowed("friend")
public class EndpointEJB implements EndpointInterface
{
  ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>or modifying the jboss-web.xml for POJO endpoints</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;jboss-web&gt;
&lt;security-domain&gt;JBossWS&lt;/security-domain&gt;
&lt;/jboss-web&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The security domain is the authentication and authorization
mechanism. Security domains are defined differently depending on the server in use.</p>
</div>
</div>
<div class="sect4">
<h5 id="use-bindingprovider-to-set-principalcredential">Use BindingProvider to set principal/credential</h5>
<div class="paragraph">
<p>A web service client may use the <code>jakarta.xml.ws.BindingProvider</code>
interface to set the username/password combination</p>
</div>
<div class="literalblock">
<div class="content">
<pre>URL wsdlURL = new File("resources/jaxws/samples/context/WEB-INF/wsdl/TestEndpoint.wsdl").toURL();
QName qname = new QName("http://org.jboss.ws/jaxws/context", "TestEndpointService");
Service service = Service.create(wsdlURL, qname);
port = (TestEndpoint)service.getPort(TestEndpoint.class);

BindingProvider bp = (BindingProvider)port;
bp.getRequestContext().put(BindingProvider.USERNAME_PROPERTY, "kermit");
bp.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY, "thefrog");</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-http-basic-auth-for-security">Using HTTP Basic Auth for security</h5>
<div class="paragraph">
<p>To enable HTTP Basic authentication use the <code>@WebContext</code> annotation
on the bean class</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@Stateless
@SecurityDomain("JBossWS")
@RolesAllowed("friend")
@WebContext(contextRoot="/my-cxt", urlPattern="/*", authMethod="BASIC", transportGuarantee="NONE", secureWSDLAccess=false)
public class EndpointEJB implements EndpointInterface
{
  ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>For POJO endpoints, we modify the <em>web.xml</em> adding the auth-method
element:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;login-config&gt;
  &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
  &lt;realm-name&gt;Test Realm&lt;/realm-name&gt;
&lt;/login-config&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="apache-cxf-integration">5.10. Apache CXF integration</h3>
<div class="sect3">
<h4 id="jbossws-integration-layer-with-apache-cxf">5.10.1. JBossWS integration layer with Apache CXF</h4>
<div class="paragraph">
<p>All JAX-WS functionalities provided by JBossWS on top of WildFly are
currently served through a proper integration of the JBoss Web Services
stack with most of the <a href="https://cxf.apache.org/">Apache CXF</a> project
modules.</p>
</div>
<div class="paragraph">
<p>Apache CXF is an open source services framework. It allows building and
developing services using frontend programming APIs (including JAX-WS),
with services speaking a variety of protocols such as SOAP and XML/HTTP
over a variety of transports such as HTTP and JMS.</p>
</div>
<div class="paragraph">
<p>The integration layer ( <em>JBossWS-CXF</em> in short hereafter) is mainly
meant for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>allowing using standard webservices APIs (including JAX-WS) on
WildFly; this is performed internally leveraging Apache CXF without
requiring the user to deal with it;</p>
</li>
<li>
<p>allowing using Apache CXF advanced features (including WS-*) on top of
WildFly without requiring the user to deal with / setup / care about the
required integration steps for running in such a container.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order for achieving the goals above, the JBossWS-CXF integration
supports the JBoss ws endpoint deployment mechanism and comes with many
internal customizations on top of Apache CXF.</p>
</div>
<div class="paragraph">
<p>In the next sections a list of technical suggestions and notes on the
integration is provided; please also refer to the
<a href="https://cxf.apache.org/docs/index.html">Apache CXF official documentation</a>
for in-depth details on the CXF architecture.</p>
</div>
</div>
<div class="sect3">
<h4 id="building-ws-applications-the-jboss-way">5.10.2. Building WS applications the JBoss way</h4>
<div class="paragraph">
<p>The Apache CXF client and endpoint configuration as explained in the
<a href="https://cxf.apache.org/docs/index.html">Apache CXF official user guide</a> is
heavily based on Spring. Apache CXF basically parses Spring <code>cxf.xml</code>
descriptors; those may contain any basic bean plus specific ws client
and endpoint beans which CXF has custom parsers for. Apache CXF can be
used to deploy webservice endpoints on any servlet container by
including its libraries in the deployment; in such a scenario Spring
basically serves as a convenient configuration option, given direct
Apache CXF API usage won&#8217;t be very handy. Similar reasoning applies on
client side, where a Spring based descriptor offers to a shortcut for
setting up Apache CXF internals.</p>
</div>
<div class="paragraph">
<p>This said, nowadays almost any Apache CXF functionality can be
configured and used through direct API usage, without Spring. As a
consequence and given the considerations in the sections below,
the JBossWS integration with Apache CXF does not rely on Spring
descriptors.</p>
</div>
<div class="sect4">
<h5 id="portable-applications">Portable applications</h5>
<div class="paragraph">
<p>WildFly is much more then a servlet container; it actually provides
users with a fully compliant target platform for Java EE applications.</p>
</div>
<div class="paragraph">
<p>Generally speaking, <em>users are encouraged to write portable
applications</em> by relying only on <em>JAX-WS specification</em> whenever
possible, that would by the way ensure easy migrations to and from other
compliant platforms. Being a Java EE container, WildFly already comes
with a JAX-WS compliant implementation, which is basically Apache CXF
plus the JBossWS-CXF integration layer. So users just need to write
their JAX-WS application; <em>no need for embedding any Apache CXF or any
ws related dependency library in user deployments</em> . Please refer to the
<a href="#advanced-user-guide">Advanced User Guide</a>  of the documentation for getting started.</p>
</div>
<div class="paragraph">
<p>WS-* usage (including WS-Security, WS-Addressing, WS-ReliableMessaging,
&#8230;&#8203;) should also be configured in the most portable way; that is by
<em>relying on proper WS-Policy assertions</em> on the endpoint WSDL contracts,
so that client and endpoint configuration is basically a matter of
setting few ws context properties. The WS-* related sections of this
documentation cover all the details on configuring applications making
use of WS-* through policies.</p>
</div>
<div class="paragraph">
<p>As a consequence of the reasoning above, the JBossWS-CXF integration is
currently built directly on the Apache CXF API and aims at allowing
users to configure webservice clients and endpoints <em>without Spring
descriptors</em> .</p>
</div>
</div>
<div class="sect4">
<h5 id="direct-apache-cxf-api-usage">Direct Apache CXF API usage</h5>
<div class="paragraph">
<p>Whenever users can&#8217;t meet their application requirements with
JAX-WS plus WS-Policy, it is still possible to rely on direct
Apache CXF API usage (given that&#8217;s included in the AS).  The
transition to Jakarta EE could affect portability of newer applications
to legacy systems, that could be the case of a user
needing specific Apache CXF functionalities, or having to consume WS-*
enabled endpoints advertised through legacy wsdl contracts without
WS-Policy assertions.</p>
</div>
<div class="paragraph">
<p>On server side, direct Apache CXF API usage might not always be possible
or end up being not very easy. For this reason, the JBossWS integration
comes with a convenient alternative through customization options in the
<code>jboss-webservices.xml</code> descriptor described below on this page.
Properties can be declared in <code>jboss-webservices.xml</code> to control Apache
CXF internals like <em>interceptors</em> , <em>features</em> , etc.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bus-usage">5.10.3. Bus usage</h4>
<div class="sect4">
<h5 id="creating-a-bus-instance">Creating a Bus instance</h5>
<div class="paragraph">
<p>Most of the Apache CXF features are configurable using the
<code>org.apache.cxf.Bus</code> class. While for basic JAX-WS usage the user might
never need to explicitly deal with Bus, using Apache CXF specific
features generally requires getting a handle to a <code>org.apache.cxf.Bus</code>
instance. This can happen on client side as well as in a ws endpoint or
handler business code.</p>
</div>
<div class="paragraph">
<p>New Bus instances are produced by the currently configured
<code>org.apache.cxf.BusFactory</code> implementation the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Bus bus = BusFactory.newInstance().createBus();</pre>
</div>
</div>
<div class="paragraph">
<p>The algorithm for selecting the actual implementation of <code>BusFactory</code> to
be used leverages the Service API, looking for optional
configurations in <em>META-INF/services/&#8230;&#8203;</em> location using the current
thread context classloader. JBossWS-CXF integration comes with its own
implementation of <code>BusFactory</code> ,
<code>org.jboss.wsf.stack.cxf.client.configuration.JBossWSBusFactory</code> , that
allows for seamless setup of JBossWS customizations on top of Apache
CXF. Assuming the JBossWS-CXF libraries are available in the current
thread context classloader, the <code>JBossWSBusFactory</code> is <em>automatically</em>
retrieved by the <code>BusFactory.newInstance()</code> call above.</p>
</div>
<div class="paragraph">
<p>JBossWS users willing to explicitly use functionalities of
<code>org.apache.cxf.bus.CXFBusFactory</code> <em>,</em> get the same API with JBossWS
additions through <code>JBossWSBusFactory</code> :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Map&lt;Class, Object&gt; myExtensions = new HashMap&lt;Class, Object&gt;();
myExtensions.put(...);
Bus bus = new JBossWSBusFactory().createBus(myExtensions);</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-existing-bus-instances">Using existing Bus instances</h5>
<div class="paragraph">
<p>Apache CXF keeps reference to a global default <code>Bus</code> instance as well as
to a thread default bus for each thread.  That is performed through
static members in <code>org.apache.cxf.BusFactory</code> <em>,</em> which also comes with
the following methods in the public API:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public static synchronized Bus getDefaultBus()
public static synchronized Bus getDefaultBus(boolean createIfNeeded)
public static synchronized void setDefaultBus(Bus bus)
public static Bus getThreadDefaultBus()
public static Bus getThreadDefaultBus(boolean createIfNeeded)
public static void setThreadDefaultBus(Bus bus)</pre>
</div>
</div>
<div class="paragraph">
<p>Please note that the default behaviour of <code>getDefaultBus()</code> <em>/</em>
<code>getDefaultBus(true)</code> <em>/</em> <code>getThreadDefaultBus()</code> <em>/</em>
<code>getThreadDefaultBus(true)</code> is to create a new Bus instance if that&#8217;s
not set yet. Moreover <em>getThreadDefaultBus()</em> and
<em>getThreadDefaultBus(true)</em> first fallback to retrieving the configured
global default bus before trying to create a new instance (and
the created new instance is set as global default bus if it is not yet
set).</p>
</div>
<div class="paragraph">
<p>The drawback of this mechanism (which is fine in JSE
environment) is that when running in the WildFly container you need to be
careful in order not to (mis)use a bus over multiple applications
(assuming the Apache CXF classes are loaded by the same classloader,
which is currently the case with WildFly).</p>
</div>
<div class="paragraph">
<p>Here is a list of general suggestions to avoid problems when running
in-container:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>forget about the global default bus; you don&#8217;t need that, so don&#8217;t do
<code>getDefaultBus()</code> <em>/</em> <code>getDefaultBus(true)</code> <em>/</em> <code>setDefaultBus()</code> in
your code;</p>
</li>
<li>
<p>avoid <code>getThreadDefaultBus()</code> <em>/</em> <code>getThreadDefaultBus(true)</code> unless
you already know for sure the default bus is already set;</p>
</li>
<li>
<p>keep in mind thread pooling whenever customizing a thread default
bus instance (for instance adding bus scope interceptors, &#8230;&#8203;), as that
thread and bus might be later reused; either shutdown the bus when
you&#8217;re done or explicitly remove it from the BusFactory thread
association.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, remember that each time you explictly create a new Bus instance
(factory.createBus()) that is set as thread default bus and global
default bus if those are not set yet.</p>
</div>
<div class="paragraph">
<p>The JAX-WS <code>Provider</code> implementation also creates <code>Bus</code> instances
internally, in particular the JBossWS version of JAX-WS <code>Provider</code> makes
sure the default bus is never internally used and instead a new <code>Bus</code> is
created if required (more details on this in the next paragraph).</p>
</div>
</div>
<div class="sect4">
<h5 id="bus-selection-strategies-for-jaxws-clients">Bus selection strategies for JAXWS clients</h5>
<div class="paragraph">
<p>JAX-WS clients require an Apache CXF Bus to be available; the client is
registered within the Bus and the Bus affects the client behavior (e.g.
through the configured CXF interceptors). The way a bus is internally
selected for serving a given JAX-WS client is very important, especially
for in-container clients; for this reason, JBossWS users can choose the
preferred Bus selection strategy. The strategy is enforced in the
<code>jakarta.xml.ws.spi.Provider</code> implementation from the JBossWS integration,
being that called whenever a JAX-WS <code>Service</code> (client) is requested.</p>
</div>
<div class="sect5">
<h6 id="thread-bus-strategy-thread_bus">Thread bus strategy (THREAD_BUS)</h6>
<div class="paragraph">
<p>Each time the vanilla JAX-WS api is used to create a Bus, the JBossWS-CXF
integration will automatically make sure a Bus is currently associated
to the current thread in the BusFactory. If that&#8217;s not the case, a new
Bus is created and linked to the current thread (to prevent the user
from relying on the default Bus). The Apache CXF engine will then create
the client using the current thread Bus.</p>
</div>
<div class="paragraph">
<p>This is the default strategy, and the most straightforward one in Java
SE environments; it lets users automatically reuse a previously created
Bus instance and allows using customized Bus that can possibly be
created and associated to the thread before building up a JAX-WS client.</p>
</div>
<div class="paragraph">
<p>The drawback of the strategy is that the link between the Bus instance
and the thread needs to be eventually cleaned up (when not needed
anymore). This is really evident in a Jakarta EE environment (hence when
running in-container), as threads from pools (e.g. serving web requests)
are re-used.</p>
</div>
<div class="paragraph">
<p>When relying on this strategy, the safest approach to be sure of
cleaning up the link is to surround the JAX-WS client with a
<code>try/finally</code> block as below:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>try {
  Service service = Service.create(wsdlURL, serviceQName);
  MyEndpoint port = service.getPort(MyEndpoint.class);
  //...
} finally {
  BusFactory.setThreadDefaultBus(null);
  // OR (if you don't need the bus and the client anymore)
  Bus bus = BusFactory.getThreadDefaultBus(false);
  bus.shutdown(true);
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="new-bus-strategy-new_bus">New bus strategy (NEW_BUS)</h6>
<div class="paragraph">
<p>Another strategy is to have the JAX-WS Provider from the JBossWS
integration create a new Bus each time a JAX-WS client is built. The main
benefit of this approach is that a fresh bus won&#8217;t rely on any formerly
cached information (e.g. cached WSDL / schemas) which might have changed
after the previous client creation. The main drawback is of course worse
performance as the Bus creation takes time.</p>
</div>
<div class="paragraph">
<p>If there&#8217;s a bus already associated with the current thread before the
JAX-WS client creation, that is automatically restored when returning
control to the user; in other words, the newly created bus will be used
only for the created JAX-WS client but won&#8217;t stay associated with the
current thread at the end of the process. Similarly, if the thread was
not associated with any bus before the client creation, no bus will be
associated with the thread at the end of the client creation.</p>
</div>
</div>
<div class="sect5">
<h6 id="thread-context-classloader-bus-strategy-tccl_bus">Thread context classloader bus strategy (TCCL_BUS)</h6>
<div class="paragraph">
<p>The last strategy is to have the bus created for serving the client be
associated with the current thread context classloader (TCCL). That
basically means, the same Bus instance is shared by JAX-WS clients running
when the same TCCL is set. This is particularly interesting as each web
application deployment usually has its own context classloader. This
strategy is possibly a way to keep the number of created Bus instances
bound to the application number in a WildFly container.</p>
</div>
<div class="paragraph">
<p>If there&#8217;s a bus already associated with the current thread before the
JAX-WS client creation, that is automatically restored when returning
control to the user; in other words, the bus corresponding to the
current thread context classloader will be used only for the created
JAX-WS client but won&#8217;t stay associated with the current thread at the end
of the process. If the thread was not associated with any bus before the
client creation, a new bus will be created (and later user for any other
client built with this strategy and the same TCCL in place); no bus will
be associated with the thread at the end of the client creation.</p>
</div>
</div>
<div class="sect5">
<h6 id="strategy-configuration">Strategy configuration</h6>
<div class="paragraph">
<p>Users can request a given Bus selection strategy to be used for the
client being built by specifying one of the following JBossWS features
(which extend <code>jakarta.xml.ws.WebServiceFeature</code> ):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top">Strategy</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.jboss.wsf.stack.cxf.client.UseThreadBusFeature</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">THREAD_BUS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.jboss.wsf.stack.cxf.client.UseNewBusFeature</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NEW_BUS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.jboss.wsf.stack.cxf.client.UseTCCLBusFeature</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCCL_BUS</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The feature is specified as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Service service = Service.create(wsdlURL, serviceQName, new UseThreadBusFeature());</pre>
</div>
</div>
<div class="paragraph">
<p>If no feature is explicitly specified, the system default strategy is
used, which can be modified through the
<code>org.jboss.ws.cxf.jaxws-client.bus.strategy</code> system property when
starting the JVM. The valid values for the property are <code>THREAD_BUS</code> ,
<code>NEW_BUS</code> and <code>TCCL_BUS</code> . The default is <code>THREAD_BUS</code> .</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="server-side-integration-customization">5.10.4. Server Side Integration Customization</h4>
<div class="paragraph">
<p>The JBossWS-CXF server side integration takes care of internally
creating proper Apache CXF structures (including a <code>Bus</code> instance, of
course) for the provided ws deployment. Should the deployment include
multiple endpoints, those would all live within the same Apache CXF Bus,
which would be completely separated by the other deployments'
bus instances.</p>
</div>
<div class="paragraph">
<p>While JBossWS sets sensible defaults for most of the Apache CXF
configuration options on server side, users might want to fine tune the
<code>Bus</code> instance that&#8217;s created for their deployment; a
<code>jboss-webservices.xml</code> descriptor can be used for deployment level
customizations.</p>
</div>
<div class="sect4">
<h5 id="deployment-descriptor-properties">Deployment descriptor properties</h5>
<div class="paragraph">
<p>The <code>jboss-webservices.xml</code> descriptor can be used to
provide property values for <a href="#component-element">component element</a></p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;webservices xmlns="http://www.jboss.com/xml/ns/javaee" version="1.2"&gt;
  ...
  &lt;property&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;value&gt;...&lt;/value&gt;
  &lt;/property&gt;
  ...
&lt;/webservices&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>JBossWS-CXF integration comes with a set of allowed property names to
control Apache CXF internals.</p>
</div>
<div class="sect5">
<h6 id="workqueue-configuration">WorkQueue configuration</h6>
<div class="paragraph">
<p>Apache CXF uses WorkQueue instances for dealing with some operations
(e.g. @Oneway requests processing). A
<a href="https://cxf.apache.org/javadoc/latest/org/apache/cxf/workqueue/WorkQueueManager.html">WorkQueueManager</a>
is installed in the Bus as an extension and allows for adding / removing
queues as well as controlling the existing ones.</p>
</div>
<div class="paragraph">
<p>On server side, queues can be provided by using the
<code>cxf.queue.&lt;queue-name&gt;.*</code> properties in <code>jboss-webservices.xml</code> (e.g.
<code>cxf.queue.default.maxQueueSize</code> for controlling the max queue size of
the <code>default</code> workqueue). At deployment time, the JBossWS integration
can add new instances of
<a href="https://cxf.apache.org/javadoc/latest/org/apache/cxf/workqueue/AutomaticWorkQueueImpl.html">AutomaticWorkQueueImpl</a>
to the currently configured WorkQueueManager; the properties below are
used to fill in parameter into the
<a href="https://cxf.apache.org/javadoc/latest/org/apache/cxf/workqueue/AutomaticWorkQueueImpl.html#AutomaticWorkQueueImpl(int,%20int,%20int,%20int,%20long,%20java.lang.String)">AutomaticWorkQueueImpl
constructor</a> :</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cxf.queue.&lt;queue-name&gt;.maxQueueSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">256</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cxf.queue.&lt;queue-name&gt;.initialThreads</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cxf.queue.&lt;queue-name&gt;.highWaterMark</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">25</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cxf.queue.&lt;queue-name&gt;.lowWaterMark</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cxf.queue.&lt;queue-name&gt;.dequeueTimeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">120000</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="policy-alternative-selector">Policy alternative selector</h6>
<div class="paragraph">
<p>The Apache CXF policy engine supports different strategies to deal with
policy alternatives. JBossWS-CXF integration currently defaults to the
<a href="https://cxf.apache.org/javadoc/latest/org/apache/cxf/ws/policy/selector/MaximalAlternativeSelector.html">MaximalAlternativeSelector</a>
, but still allows for setting different selector implementation using
the <code>cxf.policy.alternativeSelector</code> property in <code>jboss-webservices.xml</code>
.</p>
</div>
</div>
<div class="sect5">
<h6 id="mbean-management">MBean management</h6>
<div class="paragraph">
<p>Apache CXF allows managing its MBean objects that are installed into the
WildFly MBean server. The feature is enabled on a deployment basis
through the <code>cxf.management.enabled</code> property in <code>jboss-webservices.xml</code>
. The <code>cxf.management.installResponseTimeInterceptors</code> property can also
be used to control installation of CXF response time interceptors, which
are added by default when enabling MBean management, but might not be
desired in some cases. Here is an example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;webservices xmlns="http://www.jboss.com/xml/ns/javaee" version="1.2"&gt;
  &lt;property&gt;
    &lt;name&gt;cxf.management.enabled&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;cxf.management.installResponseTimeInterceptors&lt;/name&gt;
    &lt;value&gt;false&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="schema-validation">Schema validation</h6>
<div class="paragraph">
<p>Schema validation of exchanged messages can also be enabled in
<code>jboss-webservices.xml</code> . Further details available
<a href="#configuration-through-deployment-descriptor">Configuration through deployment descriptor</a></p>
</div>
</div>
<div class="sect5">
<h6 id="interceptors">Interceptors</h6>
<div class="paragraph">
<p>The <code>jboss-webservices.xml</code> descriptor also allows specifying the
<code>cxf.interceptors.in</code> and <code>cxf.interceptors.out</code> properties; those
allows declaring interceptors to be attached to the Bus instance that&#8217;s
created for serving the deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.1" encoding="UTF-8"?&gt;
&lt;webservices
  xmlns="http://www.jboss.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="1.3"
  xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;

  &lt;property&gt;
    &lt;name&gt;cxf.interceptors.in&lt;/name&gt;
    &lt;value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.BusInterceptor&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;cxf.interceptors.out&lt;/name&gt;
    &lt;value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.BusCounterInterceptor&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features">Features</h6>
<div class="paragraph">
<p>The <code>jboss-webservices.xml</code> descriptor also allows specifying the
<code>cxf.features</code> property; that allows declaring features to be attached
to any endpoint belonging to the Bus instance that&#8217;s created for serving
the deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.1" encoding="UTF-8"?&gt;
&lt;webservices
  xmlns="http://www.jboss.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="1.3"
  xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;

  &lt;property&gt;
    &lt;name&gt;cxf.features&lt;/name&gt;
    &lt;value&gt;org.apache.cxf.feature.FastInfosetFeature&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="discovery-enablement">Discovery enablement</h6>
<div class="paragraph">
<p>WS-Discovery support can be turned on in <code>jboss-webservices</code> for the
current deployment. Further details available <a href="#configuration-through-deployment-descriptor">Configuration through deployment descriptor</a> .</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="apache-cxf-interceptors">5.10.5. Apache CXF interceptors</h4>
<div class="paragraph">
<p>Apache CXF supports declaring interceptors using one of the following
approaches:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Annotation usage on endpoint classes (
<code>@org.apache.cxf.interceptor.InInterceptor</code> ,
<code>@org.apache.cxf.interceptor.OutInterceptor</code> )</p>
</li>
<li>
<p>Direct API usage on client side (through the
<code>org.apache.cxf.interceptor.InterceptorProvider</code> interface)</p>
</li>
<li>
<p>Spring descriptor usage ( <em>cxf.xml</em> )</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As the Spring descriptor usage is not supported, the JBossWS integration
adds an additional descriptor based approach to avoid requiring
modifications to the actual client/endpoint code. Users can declare
interceptors within <a href="#predefined-client-and-endpoint-configurations">Predefined client and endpoint configurations</a> by specifying a list of interceptor class names for the
<code>cxf.interceptors.in</code> and <code>cxf.interceptors.out</code> properties.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:5.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jakartaee="https://jakarta.ee/xml/ns/jakartaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:5.0 schema/jbossws-jaxws-config_5_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.cxf.interceptors.EndpointImpl&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.interceptors.in&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.EndpointInterceptor,org.jboss.test.ws.jaxws.cxf.interceptors.FooInterceptor&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.interceptors.out&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.EndpointCounterInterceptor&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>A new instance of each specified interceptor class will be added to the
client or endpoint the configuration is assigned to. The interceptor
classes must have a no-argument constructor.</p>
</div>
</div>
<div class="sect3">
<h4 id="apache-cxf-features">5.10.6. Apache CXF features</h4>
<div class="paragraph">
<p>Apache CXF supports declaring features using one of the following
approaches:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Annotation usage on endpoint classes (
<code>@org.apache.cxf.feature.Features</code> )</p>
</li>
<li>
<p>Direct API usage on client side (through extensions of the
<code>org.apache.cxf.feature.AbstractFeature</code> class)</p>
</li>
<li>
<p>Spring descriptor usage ( <em>cxf.xml</em> )</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As the Spring descriptor usage is not supported, the JBossWS integration
adds a descriptor based approach to avoid requiring
modifications to the actual client/endpoint code. Users can declare
features by specifying a list of feature class names for the
<code>cxf.features</code> property.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:5.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jakartaee="https://jakarta.ee/xml/ns/jakartaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:5.0 schema/jbossws-jaxws-config_5_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom FI Config&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;org.apache.cxf.feature.FastInfosetFeature&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>A new instance of each specified feature class will be added to the
client or endpoint the configuration is assigned to. The feature classes
must have a no-argument constructor.</p>
</div>
</div>
<div class="sect3">
<h4 id="properties-driven-bean-creation">5.10.7. Properties driven bean creation</h4>
<div class="paragraph">
<p>Sections above explain how to declare CXF interceptors and features
through properties either in a client/endpoint predefined configuration
or in a <code>jboss-webservices.xml</code> descriptor. By getting the
feature/interceptor class name only specified, the container simply
tries to create a bean instance using the class default constructor.
This sets a limitation on the feature/interceptor configuration, unless
custom extensions of vanilla CXF classes are provided, with the default
constructor setting properties before eventually using the super
constructor.</p>
</div>
<div class="paragraph">
<p>To cope with this issue, JBossWS integration comes with a mechanism for
configuring simple bean hierarchies when building them up from
properties. Properties can have bean reference values, that is strings
starting with <code>##</code> . Property reference keys are used to specify the
bean class name and the value for each attribute. So for instance
the following properties:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cxf.features</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><mark>foo, </mark>bar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">##foo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.jboss.Foo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">##foo.par</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">34</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">##bar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.jboss.Bar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">##bar.color</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">blue</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>would result into the stack installing two feature instances, the same
that would have been created by</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import org.Bar;
import org.Foo;

...

Foo foo = new Foo();
foo.setPar(34);
Bar bar = new Bar();
bar.setColor("blue");</pre>
</div>
</div>
<div class="paragraph">
<p>The mechanism assumes that the classes are valid beans with proper
getter and setter methods; value objects are cast to the correct
primitive type by inspecting the class definition. Nested beans can of
course be configured.</p>
</div>
</div>
<div class="sect3">
<h4 id="httpconduit-configuration">5.10.8. HTTPConduit configuration</h4>
<div class="paragraph">
<p>HTTP transport setup in Apache CXF is achieved through
<code>org.apache.cxf.transport.http.HTTPConduit</code>
<a href="https://cxf.apache.org/docs/client-http-transport-including-ssl-support.html">configurations</a>
. When running on top of the JBossWS integration, conduits can be
programmatically modified using the Apache CXF API as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import org.apache.cxf.frontend.ClientProxy;
import org.apache.cxf.transport.http.HTTPConduit;
import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;

//set chunking threshold before using a JAX-WS port client
...
HTTPConduit conduit = (HTTPConduit)ClientProxy.getClient(port).getConduit();
HTTPClientPolicy client = conduit.getClient();

client.setChunkingThreshold(8192);
...</pre>
</div>
</div>
<div class="paragraph">
<p>Users can also control the default values for the most common
HTTPConduit parameters by setting specific system properties; the
provided values will override Apache CXF defaut values.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cxf.client.allowChunking</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A boolean to tell Apache CXF whether to allow
send messages using chunking.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cxf.client.chunkingThreshold</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An integer value to tell Apache CXF the
threshold at which switching from non-chunking to chunking mode.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cxf.client.connectionTimeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A long value to tell Apache CXF how many
milliseconds to set the connection timeout to</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cxf.client.receiveTimeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A long value to tell Apache CXF how many
milliseconds to set the receive timeout to</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cxf.client.connection</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A string to tell Apache CXF to use <code>Keep-Alive</code>
or <code>close</code> connection type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cxf.tls-client.disableCNCheck</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A boolean to tell Apache CXF whether
disabling CN host name check or not</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The vanilla Apache CXF defaults apply when the system properties above
are not set.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="addressing">5.11. Addressing</h3>
<div class="paragraph">
<p>JBoss Web Services inherits full WS-Addressing capabilities from the
underlying Apache CXF implementation. Apache CXF provides support for
2004-08 and <a href="http://www.w3.org/TR/ws-addr-core/">1.0</a> versions of
WS-Addressing.</p>
</div>
<div class="sect3">
<h4 id="enabling-ws-addressing">5.11.1. Enabling WS-Addressing</h4>
<div class="paragraph">
<p>WS-Addressing can be turned on in multiple standard ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>consuming a WSDL contract that specifies a WS-Addressing assertion /
policy</p>
</li>
<li>
<p>using the <code>@jakarta.xml.ws.soap.Addressing</code> annotation</p>
</li>
<li>
<p>using the <code>jakarta.xml.ws.soap.AddressingFeature</code> feature</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>The supported addressing policy elements are:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[http://www.w3.org/2005/02/addressing/wsdl]UsingAddressing
[http://schemas.xmlsoap.org/ws/2004/08/addressing/policy]UsingAddressing
[http://www.w3.org/2006/05/addressing/wsdl]UsingAddressing
[http://www.w3.org/2007/05/addressing/metadata]Addressing</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, Apache CXF proprietary ways are also available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>specifying the <em>[<a href="http://cxf.apache.org/ws/addressing" class="bare">http://cxf.apache.org/ws/addressing</a>]addressing</em>
feature for a given client/endpoint</p>
</li>
<li>
<p>using the <code>org.apache.cxf.ws.addressing.WSAddressingFeature</code> feature
through the API</p>
</li>
<li>
<p>manually configuring the Apache CXF addressing interceptors (
<code>org.apache.cxf.ws.addressing.MAPAggregator</code> and
<code>org.apache.cxf.ws.addressing.soap.MAPCodec</code> )</p>
</li>
<li>
<p>setting the <em>org.apache.cxf.ws.addressing.using</em> property in the
message context</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please refer to the Apache CXF documentation for further information
on the proprietary
<a href="https://cxf.apache.org/docs/ws-addressing.html">WS-Addressing setup</a> and
<a href="https://cxf.apache.org/docs/wsaconfiguration.html">configuration details</a>
.</p>
</div>
</div>
<div class="sect3">
<h4 id="addressing-policy">5.11.2. Addressing Policy</h4>
<div class="paragraph">
<p>The WS-Addressing support is also perfectly integrated with the Apache
CXF WS-Policy engine.</p>
</div>
<div class="paragraph">
<p>This basically means that the WSDL contract generation for code-first
endpoint deployment is policy-aware: users can annotate endpoints with
the <code>@jakarta.xml.ws.soap.Addressing</code> annotation and expect the
published WSDL contract to contain proper WS-Addressing policy (assuming
no <code>wsdlLocation</code> is specified in the endpoint&#8217;s <code>@WebService</code>
annotation).</p>
</div>
<div class="paragraph">
<p>Similarly, on client side users do not need to manually specify the
<code>jakarta.xml.ws.soap.AddressingFeature</code> feature, as the policy engine is
able to properly process the WS-Addressing policy in the consumed WSDL
and turn on addressing as requested.</p>
</div>
</div>
<div class="sect3">
<h4 id="example">5.11.3. Example</h4>
<div class="paragraph">
<p>Here is an example showing how to enable WS-Addressing through
WS-Policy.</p>
</div>
<div class="sect4">
<h5 id="endpoint">Endpoint</h5>
<div class="paragraph">
<p>A simple JAX-WS endpoint is prepared using a java-first approach;
WS-Addressing is enforced through <code>@Addressing</code> annotation and no
<code>wsdlLocation</code> is provided in <code>@WebService</code> :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsa;

import jakarta.jws.WebService;
import jakarta.xml.ws.soap.Addressing;
import org.jboss.logging.Logger;

@WebService
(
   portName = "AddressingServicePort",
   serviceName = "AddressingService",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wsaddressing",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsa.ServiceIface"
)
@Addressing(enabled=true, required=true)
public class ServiceImpl implements ServiceIface
{
   private Logger log = Logger.getLogger(this.getClass());

   public String sayHello(String name)
   {
      return "Hello " + name + "!";
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The WSDL contract that&#8217;s generated at deploy time and published looks
like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;wsdl:definitions ....&gt;
...
  &lt;wsdl:binding name="AddressingServiceSoapBinding" type="tns:ServiceIface"&gt;
    &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsaw:UsingAddressing wsdl:required="true"/&gt;
    &lt;wsp:PolicyReference URI="#AddressingServiceSoapBinding_WSAM_Addressing_Policy"/&gt;

    &lt;wsdl:operation name="sayHello"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="sayHello"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="sayHelloResponse"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;

  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="AddressingService"&gt;
    &lt;wsdl:port binding="tns:AddressingServiceSoapBinding" name="AddressingServicePort"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-samples-wsa"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
    &lt;wsp:Policy wsu:Id="AddressingServiceSoapBinding_WSAM_Addressing_Policy"
       xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"&gt;
      &lt;wsam:Addressing xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"&gt;
        &lt;wsp:Policy/&gt;
      &lt;/wsam:Addressing&gt;
    &lt;/wsp:Policy&gt;
&lt;/wsdl:definitions&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="client">Client</h5>
<div class="paragraph">
<p>Since the WS-Policy engine is on by default, the client side code is
a pure JAX-WS client app:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wsaddressing", "AddressingService");
URL wsdlURL = new URL("http://localhost:8080/jaxws-samples-wsa?wsdl");
Service service = Service.create(wsdlURL, serviceName);
ServiceIface proxy = (ServiceIface)service.getPort(ServiceIface.class);
proxy.sayHello("World");</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ws-security">5.12. WS-Security</h3>
<div class="sect3">
<h4 id="ws-security-overview">5.12.1. WS-Security overview</h4>
<div class="paragraph">
<p>WS-Security provides the means to secure your services beyond transport
level protocols such as <em>HTTPS</em> . Through a number of standards such as
<a href="http://www.w3.org/TR/xmlenc-core/">XML-Encryption</a> , and headers defined
in the
<a href="http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=wss">WS-Security</a>
standard, it allows you to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pass authentication tokens between services.</p>
</li>
<li>
<p>Encrypt messages or parts of messages.</p>
</li>
<li>
<p>Sign messages.</p>
</li>
<li>
<p>Timestamp messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>WS-Security makes heavy use of public and private key cryptography. It
is helpful to understand the basics to understand how to
configure WS-Security. With public key cryptography, a user has a pair
of public and private keys. These are generated using a large prime
number and a key function.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Public_key_making.png" alt="Public key making">
</div>
</div>
<div class="paragraph">
<p>The keys are related mathematically, but cannot be derived from one
another. With these keys we can encrypt messages. For example, if Bob
wants to send a message to Alice, he can encrypt a message using her
public key. Alice can then decrypt this message using her private key.
Only Alice can decrypt this message as she is the only one with the
private key.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Public_key_encryption-mod.svg.png" alt="Public key encryption mod.svg">
</div>
</div>
<div class="paragraph">
<p>Messages can also be signed. This allows you to ensure the authenticity
of the message. If Alice wants to send a message to Bob, and Bob wants
to be sure that it is from Alice, Alice can sign the message using her
private key. Bob can then verify that the message is from Alice by using
her public key.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="250px-Public_key_making.svg.png" alt="250px Public key making.svg">
</div>
</div>
</div>
<div class="sect3">
<h4 id="jboss-ws-security-support">5.12.2. JBoss WS-Security support</h4>
<div class="paragraph">
<p>JBoss Web Services supports many real world scenarios requiring
WS-Security functionalities. This includes signature and encryption
support through X509 certificates, authentication and authorization
through username tokens as well as all ws-security configurations
covered by WS-
<a href="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/v1.3/ws-securitypolicy.html">SecurityPolicy</a>
specification.</p>
</div>
<div class="paragraph">
<p>As well as for other WS-* features , the core of
WS-Security functionalities is provided through the Apache CXF engine.
On top of that the JBossWS integration adds few configuration
enhancements to simplify the setup of WS-Security enabled endpoints.</p>
</div>
<div class="sect4">
<h5 id="apache-cxf-ws-security-implementation">Apache CXF WS-Security implementation</h5>
<div class="paragraph">
<p>Apache CXF features a top class WS-Security module supporting multiple
configurations and easily extendable.</p>
</div>
<div class="paragraph">
<p>The system is based on <em>interceptors</em> that delegate to
<a href="http://ws.apache.org/wss4j">Apache WSS4J</a> for the low level security
operations. Interceptors can be configured in different ways, either
through Spring configuration files or directly using Apache CXF client
API. Please refer to the
<a href="https://cxf.apache.org/docs/ws-security.html">Apache CXF documentation</a> if
you&#8217;re looking for more details.</p>
</div>
<div class="paragraph">
<p>Recent versions of Apache CXF, however, introduced support for
WS-Security Policy, which aims at moving most of the security
configuration into the service contract (through policies), so that
clients can easily be configured almost completely automatically from
that. This way users do not need to manually deal with configuring /
installing the required interceptors; the Apache CXF WS-Policy engine
internally takes care of that instead.</p>
</div>
<div class="sect5">
<h6 id="ws-security-policy-support">WS-Security Policy support</h6>
<div class="paragraph">
<p>WS-SecurityPolicy describes the actions that are required to securely
communicate with a service advertised in a given WSDL contract. The WSDL
bindings / operations reference WS-Policy fragments with the security
requirements to interact with the service. The
<a href="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/v1.3/ws-securitypolicy.html">WS-SecurityPolicy
specification</a> allows for specifying things like asymmetric/symmetric
keys, using transports (https) for encryption, which parts/headers to
encrypt or sign, whether to sign then encrypt or encrypt then sign,
whether to include timestamps, whether to use derived keys, etc.</p>
</div>
<div class="paragraph">
<p>Some mandatory configuration elements are not covered by
WS-SecurityPolicy, because they&#8217;re not meant to be a public /
part of the published endpoint contract; those include things such as
keystore locations, usernames and passwords, etc. Apache CXF allows
configuring these elements either through Spring xml descriptors or
using the client API / annotations. Below is the list of supported
configuration properties:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ws-security.username</th>
<th class="tableblock halign-left valign-top">The username used for UsernameToken policy
assertions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws-security.password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The password used for UsernameToken policy
assertions. If not specified, the callback handler will be called.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws-security.callback-handler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The WSS4J security CallbackHandler that
will be used to retrieve passwords for keystores and UsernameTokens.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws-security.signature.properties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The properties file/object that
contains the WSS4J properties for configuring the signature keystore and
crypto objects</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws-security.encryption.properties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The properties file/object that
contains the WSS4J properties for configuring the encryption keystore
and crypto objects</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws-security.signature.username</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The username or alias for the key in
the signature keystore that will be used. If not specified, it uses the
the default alias set in the properties file. If that&#8217;s also not set,
and the keystore only contains a single key, that key will be used.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws-security.encryption.username</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The username or alias for the key in
the encryption keystore that will be used. If not specified, it uses the
the default alias set in the properties file. If that&#8217;s also not set,
and the keystore only contains a single key, that key will be used. For
the web service provider, the useReqSigCert keyword can be used to
accept (encrypt to) any client whose public key is in the service&#8217;s
truststore (defined in ws-security.encryption.properties.)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws-security.signature.crypto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instead of specifying the signature
properties, this can point to the full
<a href="http://ws.apache.org/wss4j/apidocs/org/apache/ws/security/components/crypto/Crypto.html">WSS4J
Crypto</a> object. This can allow easier "programmatic" configuration of
the Crypto information."</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws-security.encryption.crypto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instead of specifying the encryption
properties, this can point to the full
<a href="http://ws.apache.org/wss4j/apidocs/org/apache/ws/security/components/crypto/Crypto.html">WSS4J
Crypto</a> object. This can allow easier "programmatic" configuration of
the Crypto information."</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws-security.enable.streaming</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enable
<a href="http://ws.apache.org/wss4j/streaming.html">streaming</a> (StAX based)
processing of WS-Security messages</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Here is an example of configuration using the client API:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Map&lt;String, Object&gt; ctx = ((BindingProvider)port).getRequestContext();
ctx.put("ws-security.encryption.properties", properties);
port.echoString("hello");</pre>
</div>
</div>
<div class="paragraph">
<p>Please refer to the
<a href="https://cxf.apache.org/docs/ws-securitypolicy.html">Apache CXF
documentation</a> for additional configuration details.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jbossws-configuration-additions">JBossWS configuration additions</h5>
<div class="paragraph">
<p>In order for removing the need of Spring on server side for setting up
WS-Security configuration properties not covered by policies, the
JBossWS integration allows for getting those pieces of information from
a defined <em>endpoint configuration</em> . <a href="#predefined-client-and-endpoint-configurations">Predefined client and endpoint configurations</a>
can include property declarations and endpoint
implementations can be associated with a given endpoint configuration
using the <code>@EndpointConfig</code> annotation.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:5.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:jakartaee="https://jakarta.ee/xml/ns/jakartaee" xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:5.0 schema/jbossws-jaxws-config_5_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom WS-Security Endpoint&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.username&lt;/property-name&gt;
      &lt;property-value&gt;bob&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.username&lt;/property-name&gt;
      &lt;property-value&gt;alice&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.callback-handler&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.KeystorePasswordCallback&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>import jakarta.jws.WebService;
import org.jboss.ws.api.annotation.EndpointConfig;

@WebService
(
   portName = "SecurityServicePort",
   serviceName = "SecurityService",
   wsdlLocation = "WEB-INF/wsdl/SecurityService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.basic.ServiceIface"
)
@EndpointConfig(configFile = "WEB-INF/jaxws-endpoint-config.xml", configName = "Custom WS-Security Endpoint")
public class ServiceImpl implements ServiceIface
{
   public String sayHello()
   {
      return "Secure Hello World!";
   }
}</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="apache-cxf-annotations">Apache CXF annotations</h5>
<div class="paragraph">
<p>The JBossWS configuration additions allow for a descriptor approach to
the WS-Security Policy engine configuration. If you prefer to provide
the same information through an annotation approach, you can leverage
the Apache CXF <code>@org.apache.cxf.annotations.EndpointProperties</code>
annotation:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebService(
   ...
)
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.properties", value = "bob.properties"),
      @EndpointProperty(key = "ws-security.encryption.properties", value = "bob.properties"),
      @EndpointProperty(key = "ws-security.signature.username", value = "bob"),
      @EndpointProperty(key = "ws-security.encryption.username", value = "alice"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.basic.KeystorePasswordCallback")
      }
)
public class ServiceImpl implements ServiceIface {
   ...
}</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="examples-7">5.12.3. Examples</h4>
<div class="paragraph">
<p>In this section a sample of WS-Security service endpoints and clients
are provided. Please note they&#8217;re only meant as tutorials; you should
careful isolate the ws-security policies / assertion that best
suite your security needs before going to a production environment.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>The following sections provide directions and examples on understanding
some of the configuration options for WS-Security engine. Please note
the implementor remains responsible for assessing the application
requirements and choosing the most suitable security policy for them.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="signature-and-encryption">Signature and encryption</h5>
<div class="sect5">
<h6 id="endpoint-2">Endpoint</h6>
<div class="paragraph">
<p>First, you need to create the web service endpoint using JAX-WS.
While this can generally be achieved in different ways, it&#8217;s required to
use a contract-first approach when using WS-Security, as the policies
declared in the wsdl are parsed by the Apache CXF engine on both server
and client sides. Here is an example of WSDL contract enforcing
signature and encryption using X 509 certificates (the referenced schema
is omitted):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" name="SecurityService"
        xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
        xmlns="http://schemas.xmlsoap.org/wsdl/"
        xmlns:wsp="http://www.w3.org/ns/ws-policy"
        xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
        xmlns:wsaws="http://www.w3.org/2005/08/addressing"
        xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" schemaLocation="SecurityService_schema1.xsd"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="sayHello"&gt;
    &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;
  &lt;message name="sayHelloResponse"&gt;
    &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;
  &lt;portType name="ServiceIface"&gt;
    &lt;operation name="sayHello"&gt;
      &lt;input message="tns:sayHello"/&gt;
      &lt;output message="tns:sayHelloResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
  &lt;binding name="SecurityServicePortBinding" type="tns:ServiceIface"&gt;
    &lt;wsp:PolicyReference URI="#SecurityServiceSignThenEncryptPolicy"/&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="sayHello"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;
  &lt;service name="SecurityService"&gt;
    &lt;port name="SecurityServicePort" binding="tns:SecurityServicePortBinding"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-samples-wssePolicy-sign-encrypt"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;

  &lt;wsp:Policy wsu:Id="SecurityServiceSignThenEncryptPolicy" xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;sp:AsymmetricBinding xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:InitiatorToken&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:X509Token sp:IncludeToken="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy/IncludeToken/AlwaysToRecipient"&gt;
                  &lt;wsp:Policy&gt;
                    &lt;sp:WssX509V1Token11/&gt;
                  &lt;/wsp:Policy&gt;
                  &lt;/sp:X509Token&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:InitiatorToken&gt;
            &lt;sp:RecipientToken&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:X509Token sp:IncludeToken="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy/IncludeToken/Never"&gt;
                  &lt;wsp:Policy&gt;
                    &lt;sp:WssX509V1Token11/&gt;
                  &lt;/wsp:Policy&gt;
                &lt;/sp:X509Token&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:RecipientToken&gt;
            &lt;sp:AlgorithmSuite&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:TripleDesRsa15/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:AlgorithmSuite&gt;
            &lt;sp:Layout&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Lax/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:Layout&gt;
            &lt;sp:IncludeTimestamp/&gt;
            &lt;sp:EncryptSignature/&gt;
            &lt;sp:OnlySignEntireHeadersAndBody/&gt;
            &lt;sp:SignBeforeEncrypting/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:AsymmetricBinding&gt;
        &lt;sp:SignedParts xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
          &lt;sp:Body/&gt;
        &lt;/sp:SignedParts&gt;
        &lt;sp:EncryptedParts xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
          &lt;sp:Body/&gt;
        &lt;/sp:EncryptedParts&gt;
        &lt;sp:Wss10 xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportRefIssuerSerial/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Wss10&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;
&lt;/definitions&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The service endpoint can be generated using the <code>wsconsume</code> tool and
then enriched with a <code>@EndpointConfig</code> annotation:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.basic;

import jakarta.jws.WebService;
import org.jboss.ws.api.annotation.EndpointConfig;

@WebService
(
   portName = "SecurityServicePort",
   serviceName = "SecurityService",
   wsdlLocation = "WEB-INF/wsdl/SecurityService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.basic.ServiceIface"
)
@EndpointConfig(configFile = "WEB-INF/jaxws-endpoint-config.xml", configName = "Custom WS-Security Endpoint")
public class ServiceImpl implements ServiceIface
{
   public String sayHello()
   {
      return "Secure Hello World!";
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The referenced <em>jaxws-endpoint-config.xml</em> descriptor is used to provide
a custom endpoint configuration with the required server side
configuration properties; this tells the engine which certificate / key
to use for signature / signature verification and for encryption /
decryption:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:5.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:jakartaee="https://jakarta.ee/xml/ns/jakartaee" xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:5.0 schema/jbossws-jaxws-config_5_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom WS-Security Endpoint&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.username&lt;/property-name&gt;
      &lt;property-value&gt;bob&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.username&lt;/property-name&gt;
      &lt;property-value&gt;alice&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.callback-handler&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.KeystorePasswordCallback&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>the <em>bob.properties</em> configuration file is also referenced above; it
includes the WSS4J Crypto properties which in turn link to the keystore
file, type and the alias/password to use for accessing it:</p>
</li>
</ol>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=password
org.apache.ws.security.crypto.merlin.keystore.alias=bob
org.apache.ws.security.crypto.merlin.keystore.file=bob.jks</pre>
</div>
</div>
<div class="paragraph">
<p>A callback handler for the letting Apache CXF access the keystore is
also provided:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.basic;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.ws.security.WSPasswordCallback;

public class KeystorePasswordCallback implements CallbackHandler {
   private Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();

   public KeystorePasswordCallback() {
      passwords.put("alice", "password");
      passwords.put("bob", "password");
   }

   /**
    * It attempts to get the password from the private
    * alias/passwords map.
    */
   public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      for (int i = 0; i &lt; callbacks.length; i++) {
         WSPasswordCallback pc = (WSPasswordCallback)callbacks[i];

         String pass = passwords.get(pc.getIdentifier());
         if (pass != null) {
            pc.setPassword(pass);
            return;
         }
      }
   }

   /**
    * Add an alias/password pair to the callback mechanism.
    */
   public void setAliasPassword(String alias, String password) {
      passwords.put(alias, password);
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Assuming the <em>bob.jks</em> keystore has been properly generated and contains
Bob&#8217;s (server) full key (private/certificate + public key) as well as
Alice&#8217;s (client) public key, we can proceed to packaging the endpoint.
Here is the expected content (the endpoint is a <em>POJO</em> one in a <em>war</em>
archive, but <em>EJB3</em> endpoints in <em>jar</em> archives are of course also
supported):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>alessio@inuyasha /dati/jbossws/stack/cxf/trunk $ jar -tvf ./modules/testsuite/cxf-tests/target/test-libs/jaxws-samples-wsse-policy-sign-encrypt.war
     0 Thu Jun 16 18:50:48 CEST 2011 META-INF/
   140 Thu Jun 16 18:50:46 CEST 2011 META-INF/MANIFEST.MF
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/
   586 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/web.xml
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/basic/
  1687 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/basic/KeystorePasswordCallback.class
   383 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/basic/ServiceIface.class
  1070 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/basic/ServiceImpl.class
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/
   705 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/SayHello.class
  1069 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/SayHelloResponse.class
  1225 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/jaxws-endpoint-config.xml
     0 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/
  4086 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/SecurityService.wsdl
   653 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/SecurityService_schema1.xsd
  1820 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/classes/bob.jks
   311 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/classes/bob.properties</pre>
</div>
</div>
<div class="paragraph">
<p>The jaxws classes generated by the tools are included, as well as a basic <em>web.xml</em> referencing the endpoint
bean:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app
   version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.ServiceImpl&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>If you&#8217;re deploying the endpoint archive to WildFly, remember to add a
dependency to <em>org.apache.ws.security</em> module in the MANIFEST.MF file.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version: 1.0
Ant-Version: Apache Ant 1.7.1
Created-By: 17.0-b16 (Sun Microsystems Inc.)
Dependencies: org.apache.ws.security</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="client-2">Client</h6>
<div class="paragraph">
<p>Start by consuming the published WSDL contract using the <em>wsconsume</em>
tool on client side, then simply invoke the endpoint as a
standard JAX-WS one:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy", "SecurityService");
URL wsdlURL = new URL(serviceURL + "?wsdl");
Service service = Service.create(wsdlURL, serviceName);
ServiceIface proxy = (ServiceIface)service.getPort(ServiceIface.class);

((BindingProvider)proxy).getRequestContext().put(SecurityConstants.CALLBACK_HANDLER, new KeystorePasswordCallback());
((BindingProvider)proxy).getRequestContext().put(SecurityConstants.SIGNATURE_PROPERTIES,
     Thread.currentThread().getContextClassLoader().getResource("META-INF/alice.properties"));
((BindingProvider)proxy).getRequestContext().put(SecurityConstants.ENCRYPT_PROPERTIES,
     Thread.currentThread().getContextClassLoader().getResource("META-INF/alice.properties"));
((BindingProvider)proxy).getRequestContext().put(SecurityConstants.SIGNATURE_USERNAME, "alice");
((BindingProvider)proxy).getRequestContext().put(SecurityConstants.ENCRYPT_USERNAME, "bob");

proxy.sayHello();</pre>
</div>
</div>
<div class="paragraph">
<p>The WS-Security properties are set in the request
context. Here the <code>KeystorePasswordCallback</code> is the same as on the server
side above, you might want/need different implementation in real world
scenarios. The <em>alice.properties</em> file is the client side
equivalent of the server side <em>bob.properties</em> and references the
<em>alice.jks</em> keystore file, which has been populated with Alice&#8217;s
(client) full key (private/certificate + public key) as well as Bob&#8217;s
(server) public key.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=password
org.apache.ws.security.crypto.merlin.keystore.alias=alice
org.apache.ws.security.crypto.merlin.keystore.file=META-INF/alice.jks</pre>
</div>
</div>
<div class="paragraph">
<p>The Apache CXF WS-Policy engine will digest the security requirements in
the contract and ensure a valid secure communication is in place for
interacting with the server endpoint.</p>
</div>
</div>
<div class="sect5">
<h6 id="endpoint-serving-multiple-clients">Endpoint serving multiple clients</h6>
<div class="paragraph">
<p>The server side configuration described above implies the endpoint is
configured for serving a given client which a service agreement has been
established for. In some real world scenarios, the same server
might be expected to be able to deal with (including decrypting and
encrypting) messages coming from and being sent to multiple clients.
Apache CXF supports that through the <code>useReqSigCert</code> value for the
<code>ws-security.encryption.username</code> configuration parameter.</p>
</div>
<div class="paragraph">
<p>Of course the referenced server side keystore needs to contain the
public key of all the clients that are expected to be served.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="authentication-and-authorization">Authentication and authorization</h5>
<div class="paragraph">
<p>The Username Token Profile can be used to provide client&#8217;s credentials
to a WS-Security enabled target endpoint.</p>
</div>
<div class="paragraph">
<p>Apache CXF provides a means for setting basic <em>password callback handlers</em>
on both client and server sides to set/check passwords; the
<em>ws-security.username</em> and <em>ws-security.callback-handler</em> properties can
be used similarly as shown in the signature and encryption example.
Things become more interesting when requiring a given user to be
authenticated (and authorized) against a security domain on the target
WildFly server.</p>
</div>
<div class="paragraph">
<p>On the server side, you need to install two additional interceptors that act
as bridges for the application server authentication layer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an interceptor for performing authentication and populating a valid
SecurityContext; the provided interceptor should extend
org.apache.cxf.ws.interceptor.security.AbstractUsernameTokenInInterceptor,
in particular JBossWS integration comes with
<em>org.jboss.wsf.stack.cxf.security.authentication.SubjectCreatingInterceptor</em>
for this;</p>
</li>
<li>
<p>an interceptor for performing authorization; CXF requires that to
extend
org.apache.cxf.interceptor.security.AbstractAuthorizingInInterceptor,
for instance the <em>SimpleAuthorizingInterceptor</em> can be used for simply
mapping endpoint operations to allowed roles.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here follows an example of WS-SecurityPolicy endpoint using Username
Token Profile for authenticating through the WildFly security domain
system.</p>
</div>
<div class="sect5">
<h6 id="endpoint-3">Endpoint</h6>
<div class="paragraph">
<p>As in the other example, we start with a wsdl contract containing the
proper WS-Security Policy:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" name="SecurityService"
        xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
        xmlns="http://schemas.xmlsoap.org/wsdl/"
        xmlns:wsp="http://schemas.xmlsoap.org/ws/2004/09/policy"
        xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
        xmlns:wsaws="http://www.w3.org/2005/08/addressing"&gt;
  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" schemaLocation="SecurityService_schema1.xsd"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="sayHello"&gt;
    &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;
  &lt;message name="sayHelloResponse"&gt;
    &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;
  &lt;message name="greetMe"&gt;
    &lt;part name="parameters" element="tns:greetMe"/&gt;
  &lt;/message&gt;
  &lt;message name="greetMeResponse"&gt;
    &lt;part name="parameters" element="tns:greetMeResponse"/&gt;
  &lt;/message&gt;
  &lt;portType name="ServiceIface"&gt;
    &lt;operation name="sayHello"&gt;
      &lt;input message="tns:sayHello"/&gt;
      &lt;output message="tns:sayHelloResponse"/&gt;
    &lt;/operation&gt;
    &lt;operation name="greetMe"&gt;
      &lt;input message="tns:greetMe"/&gt;
      &lt;output message="tns:greetMeResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
  &lt;binding name="SecurityServicePortBinding" type="tns:ServiceIface"&gt;
    &lt;wsp:PolicyReference URI="#SecurityServiceUsernameUnsecureTransportPolicy"/&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="sayHello"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
    &lt;operation name="greetMe"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;
  &lt;service name="SecurityService"&gt;
    &lt;port name="SecurityServicePort" binding="tns:SecurityServicePortBinding"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-samples-wsse-username-jaas"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;

  &lt;wsp:Policy wsu:Id="SecurityServiceUsernameUnsecureTransportPolicy"&gt;
        &lt;wsp:ExactlyOne&gt;
            &lt;wsp:All&gt;
                &lt;sp:SupportingTokens xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
                    &lt;wsp:Policy&gt;
                        &lt;sp:UsernameToken sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
                            &lt;wsp:Policy&gt;
                                &lt;sp:WssUsernameToken10/&gt;
                            &lt;/wsp:Policy&gt;
                        &lt;/sp:UsernameToken&gt;
                    &lt;/wsp:Policy&gt;
                &lt;/sp:SupportingTokens&gt;
            &lt;/wsp:All&gt;
        &lt;/wsp:ExactlyOne&gt;
    &lt;/wsp:Policy&gt;

&lt;/definitions&gt;</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>If you want to send hash / digest passwords, you can use a policy such
as what follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;wsp:Policy wsu:Id="SecurityServiceUsernameHashPasswordPolicy"&gt;
    &lt;wsp:ExactlyOne&gt;
        &lt;wsp:All&gt;
            &lt;sp:SupportingTokens xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
                &lt;wsp:Policy&gt;
                    &lt;sp:UsernameToken sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
                        &lt;wsp:Policy&gt;
                            &lt;sp:HashPassword/&gt;
                        &lt;/wsp:Policy&gt;
                    &lt;/sp:UsernameToken&gt;
                &lt;/wsp:Policy&gt;
            &lt;/sp:SupportingTokens&gt;
        &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
&lt;/wsp:Policy&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Please note the specified JBoss security domain needs to be properly
configured for computing digests.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The service endpoint can be generated using the <code>wsconsume</code> tool and
then enriched with a <code>@EndpointConfig</code> annotation and <code>@InInterceptors</code>
annotation to add the two interceptors mentioned above for JAAS
integration:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.jaas;

import jakarta.jws.WebService;
import org.apache.cxf.interceptor.InInterceptors;
import org.jboss.ws.api.annotation.EndpointConfig;

@WebService
(
   portName = "SecurityServicePort",
   serviceName = "SecurityService",
   wsdlLocation = "WEB-INF/wsdl/SecurityService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.jaas.ServiceIface"
)
@EndpointConfig(configFile = "WEB-INF/jaxws-endpoint-config.xml", configName = "Custom WS-Security Endpoint")
@InInterceptors(interceptors = {
      "org.jboss.wsf.stack.cxf.security.authentication.SubjectCreatingPolicyInterceptor",
      "org.jboss.test.ws.jaxws.samples.wsse.policy.jaas.POJOEndpointAuthorizationInterceptor"}
)
public class ServiceImpl implements ServiceIface
{
   public String sayHello()
   {
      return "Secure Hello World!";
   }

   public String greetMe()
   {
      return "Greetings!";
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>POJOEndpointAuthorizationInterceptor</code> is included into the
deployment and deals with the roles cheks:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.jaas;

import java.util.HashMap;
import java.util.Map;
import org.apache.cxf.interceptor.security.SimpleAuthorizingInterceptor;

public class POJOEndpointAuthorizationInterceptor extends SimpleAuthorizingInterceptor
{

   public POJOEndpointAuthorizationInterceptor()
   {
      super();
      readRoles();
   }

   private void readRoles()
   {
      //just an example, this might read from a configuration file or such
      Map&lt;String, String&gt; roles = new HashMap&lt;String, String&gt;();
      roles.put("sayHello", "friend");
      roles.put("greetMe", "snoopies");
      setMethodRolesMap(roles);
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The <em>jaxws-endpoint-config.xml</em> descriptor is used to provide a custom
endpoint configuration with the required server side configuration
properties; in particular for this Username Token case that&#8217;s just a CXF
configuration option for leaving the username token validation to the
configured interceptors:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:5.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:jakartaee="https://jakarta.ee/xml/ns/jakartaee" xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:5.0 schema/jbossws-jaxws-config_5_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom WS-Security Endpoint&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.validate.token&lt;/property-name&gt;
      &lt;property-value&gt;false&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>In order for requiring a given JBoss security domain to be used to
protect access to the endpoint (a POJO one in this case), we declare
that in a <em>jboss-web.xml</em> descriptor (the <em>JBossWS</em> security domain is
used):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE jboss-web PUBLIC "-//JBoss//DTD Web Application 2.4//EN" "http://www.jboss.org/j2ee/dtd/jboss-web_4_0.dtd"&gt;
&lt;jboss-web&gt;
   &lt;security-domain&gt;java:/jaas/JBossWS&lt;/security-domain&gt;
&lt;/jboss-web</pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the <em>web.xml</em> is as simple as usual:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app
   version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.jaas.ServiceImpl&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The endpoint is packaged into a war archive, including the JAXWS classes
generated by wsconsume:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>alessio@inuyasha /dati/jbossws/stack/cxf/trunk $ jar -tvf ./modules/testsuite/cxf-tests/target/test-libs/jaxws-samples-wsse-policy-username-jaas.war
     0 Thu Jun 16 18:50:48 CEST 2011 META-INF/
   155 Thu Jun 16 18:50:46 CEST 2011 META-INF/MANIFEST.MF
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/
   585 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/web.xml
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaas/
   982 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaas/POJOEndpointAuthorizationInterceptor.class
   412 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaas/ServiceIface.class
  1398 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaas/ServiceImpl.class
     0 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/
   701 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/GreetMe.class
  1065 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/GreetMeResponse.class
   705 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/SayHello.class
  1069 Thu Jun 16 18:50:48 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/samples/wsse/policy/jaxws/SayHelloResponse.class
   556 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/jaxws-endpoint-config.xml
   241 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/jboss-web.xml
     0 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/
  3183 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/SecurityService.wsdl
  1012 Thu Jun 16 18:50:44 CEST 2011 WEB-INF/wsdl/SecurityService_schema1.xsd</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>If you&#8217;re deploying the endpoint archive to WildFly, remember to add a
dependency to <em>org.apache.ws.security</em> and <em>org.apache.cxf</em> module (due
to the <code>@InInterceptor</code> annotation) in the MANIFEST.MF file.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version: 1.0
Ant-Version: Apache Ant 1.7.1
Created-By: 17.0-b16 (Sun Microsystems Inc.)
Dependencies: org.apache.ws.security,org.apache.cxf</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="client-3">Client</h6>
<div class="paragraph">
<p>Start by consuming the published WSDL contract using the
<em>wsconsume</em> tool, then invoke the the endpoint as a standard
JAX-WS one:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy", "SecurityService");
URL wsdlURL = new URL(serviceURL + "?wsdl");
Service service = Service.create(wsdlURL, serviceName);
ServiceIface proxy = (ServiceIface)service.getPort(ServiceIface.class);

((BindingProvider)proxy).getRequestContext().put(SecurityConstants.USERNAME, "kermit");
((BindingProvider)proxy).getRequestContext().put(SecurityConstants.CALLBACK_HANDLER,
      "org.jboss.test.ws.jaxws.samples.wsse.policy.jaas.UsernamePasswordCallback");

proxy.sayHello();</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>UsernamePasswordCallback</code> class is shown below and is responsible
for setting the passwords on client side just before performing the
invocations:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.jaas;

import java.io.IOException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.ws.security.WSPasswordCallback;

public class UsernamePasswordCallback implements CallbackHandler
{
   public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException
   {
      WSPasswordCallback pc = (WSPasswordCallback)callbacks[0];
      if ("kermit".equals(pc.getIdentifier()))
         pc.setPassword("thefrog");
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>If everything has been done properly, you should expect calls to
<code>sayHello()</code> to fail when done with user "snoopy" and pass with user
"kermit" (and credential "thefrog"); moreover, you should get an
authorization error when trying to call <code>greetMe()</code> with user "kermit",
as that does not have the "snoopies" role.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="secure-transport">Secure transport</h5>
<div class="paragraph">
<p>Another quite common use case is using WS-Security Username Token
Profile over a secure transport (HTTPS). A scenario like this is
implemented similarly to what&#8217;s described in the previous example,
except for few differences explained below.</p>
</div>
<div class="paragraph">
<p>Here is an excerpt of a wsdl with a sample security policy
for Username Token over HTTPS:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>...

&lt;binding name="SecurityServicePortBinding" type="tns:ServiceIface"&gt;
  &lt;wsp:PolicyReference URI="#SecurityServiceBindingPolicy"/&gt;
  &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
  &lt;operation name="sayHello"&gt;
    &lt;soap:operation soapAction=""/&gt;
    &lt;input&gt;
      &lt;soap:body use="literal"/&gt;
    &lt;/input&gt;
    &lt;output&gt;
      &lt;soap:body use="literal"/&gt;
    &lt;/output&gt;
  &lt;/operation&gt;
&lt;/binding&gt;
&lt;service name="SecurityService"&gt;
   &lt;port name="SecurityServicePort" binding="tns:SecurityServicePortBinding"&gt;
      &lt;soap:address location="https://localhost:8443/jaxws-samples-wsse-policy-username"/&gt;
   &lt;/port&gt;
&lt;/service&gt;

&lt;wsp:Policy wsu:Id="SecurityServiceBindingPolicy"&gt;
   &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
         &lt;foo:unknownPolicy xmlns:foo="http://cxf.apache.org/not/a/policy"/&gt;
      &lt;/wsp:All&gt;
      &lt;wsp:All&gt;
         &lt;wsaws:UsingAddressing xmlns:wsaws="http://www.w3.org/2006/05/addressing/wsdl"/&gt;
         &lt;sp:TransportBinding&gt;
            &lt;wsp:Policy&gt;
               &lt;sp:TransportToken&gt;
                  &lt;wsp:Policy&gt;
                     &lt;sp:HttpsToken RequireClientCertificate="false"/&gt;
                  &lt;/wsp:Policy&gt;
               &lt;/sp:TransportToken&gt;
               &lt;sp:Layout&gt;
                  &lt;wsp:Policy&gt;
                     &lt;sp:Lax/&gt;
                  &lt;/wsp:Policy&gt;
               &lt;/sp:Layout&gt;
               &lt;sp:IncludeTimestamp/&gt;
               &lt;sp:AlgorithmSuite&gt;
                  &lt;wsp:Policy&gt;
                     &lt;sp:Basic128/&gt;
                  &lt;/wsp:Policy&gt;
               &lt;/sp:AlgorithmSuite&gt;
            &lt;/wsp:Policy&gt;
         &lt;/sp:TransportBinding&gt;
         &lt;sp:Wss10&gt;
            &lt;wsp:Policy&gt;
               &lt;sp:MustSupportRefKeyIdentifier/&gt;
            &lt;/wsp:Policy&gt;
         &lt;/sp:Wss10&gt;
         &lt;sp:SignedSupportingTokens&gt;
            &lt;wsp:Policy&gt;
               &lt;sp:UsernameToken sp:IncludeToken="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy/IncludeToken/AlwaysToRecipient"&gt;
                  &lt;wsp:Policy&gt;
                     &lt;sp:WssUsernameToken10/&gt;
                  &lt;/wsp:Policy&gt;
               &lt;/sp:UsernameToken&gt;
            &lt;/wsp:Policy&gt;
         &lt;/sp:SignedSupportingTokens&gt;
      &lt;/wsp:All&gt;
   &lt;/wsp:ExactlyOne&gt;
&lt;/wsp:Policy&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The endpoint needs to be available on HTTPS
only, so we have a <em>web.xml</em> setting the <em>transport-guarantee</em> such as
below:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app
   version="5.0" xmlns="https://jakarta.ee/xml/ns/jakartaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee http://java.sun.com/xml/ns/javaee/web-app_5_0.xsd"&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.ServiceImpl&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;

   &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;TestService&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;user-data-constraint&gt;
      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
  &lt;/security-constraint&gt;
&lt;/web-app&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="secure-conversation">Secure conversation</h5>
<div class="paragraph">
<p>Apache CXF supports
<a href="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/ws-secureconversation-1.3-os.html">WS-SecureConversation</a>
specification, which is about improving performance by allowing client
and server to negotiate initial security keys to be used for later
communication encryption/signature. This is done by having two policies
in the wsdl contract, an outer one setting the security requirements to
communicate with the endpoint and a bootstrap one, related to
the communication for establishing the secure conversation keys. The
client will be automatically sending an initial message to the server
for negotiating the keys, then the communication to the endpoint
takes place. As a consequence, Apache CXF needs a way to specify which
WS-Security configuration properties are intended for the bootstrap
policy and which are intended for the actual service policy. To
accomplish this, properties intended for the bootstrap policy are
appended with <code>.sct</code> .</p>
</div>
<div class="literalblock">
<div class="content">
<pre>...
((BindingProvider)proxy).getRequestContext().put("ws-security.signature.username.sct", "alice");
((BindingProvider)proxy).getRequestContext().put("ws-security.encryption.username.sct", "bob");
...</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@WebService(
   ...
)
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.encryption.properties.sct", value = "bob.properties"),
      @EndpointProperty(key = "ws-security.signature.properties.sct", value = "bob.properties"),
      ...
      }
)
public class ServiceImpl implements ServiceIface {
   ...
}</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ws-trust-and-sts">5.13. WS-Trust and STS</h3>
<div class="sect3">
<h4 id="ws-trust-overview">5.13.1. WS-Trust overview</h4>
<div class="paragraph">
<p><a href="http://docs.oasis-open.org/ws-sx/ws-trust/v1.4/ws-trust.html">WS-Trust</a> is a Web
service specification that defines extensions to WS-Security. It is a
general framework for implementing security in a distributed system. The
standard is based on a centralized Security Token Service, STS, which is
capable of authenticating clients and issuing tokens containing various
kinds of authentication and authorization data. The specification
describes a protocol used for issuance, exchange, and validation of
security tokens, however the following specifications play an important
role in the WS-Trust architecture:
<a href="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/ws-securitypolicy-1.2-spec-os.html">WS-SecurityPolicy
1.2</a> ,
<a href="http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">SAML
2.0</a> ,
<a href="http://docs.oasis-open.org/wss/v1.1/wss-v1.1-spec-os-UsernameTokenProfile.pdf">Username
Token Profile</a> ,
<a href="http://docs.oasis-open.org/wss-m/wss/v1.1.1/wss-x509TokenProfile-v1.1.1.html">X.509
Token Profile</a> ,
<a href="https://www.oasis-open.org/committees/download.php/16768/wss-v1.1-spec-os-SAMLTokenProfile.pdf">SAML
Token Profile</a> , and
<a href="http://docs.oasis-open.org/wss/v1.1/wss-v1.1-spec-os-KerberosTokenProfile.pdf">Kerberos
Token Profile</a> .</p>
</div>
<div class="paragraph">
<p>The WS-Trust extensions address the needs of applications that span
multiple domains and requires the sharing of security keys by providing
a standards based trusted third party web service (STS) to broker trust
relationships between a Web service requester and a Web service
provider. This architecture also alleviates the pain of service updates
that require credential changes by providing a common location for this
information. The STS is the common access point from which both the
requester and provider retrieves and verifies security tokens.</p>
</div>
<div class="paragraph">
<p>There are three main components of the WS-Trust specification.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Security Token Service (STS), a web service that issues, renews,
and validates security tokens.</p>
</li>
<li>
<p>The message formats for security token requests and responses.</p>
</li>
<li>
<p>The mechanisms for key exchange</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="security-token-service">5.13.2. Security Token Service</h4>
<div class="paragraph">
<p>The Security Token Service, STS, is the core of the WS-Trust
specification. It is a standards based mechanism for authentication and
authorization. The STS is an implementation of the WS-Trust
specification&#8217;s protocol for issuing, exchanging, and validating
security tokens, based on token format, namespace, or trust boundaries.
The STS is a web service that acts as a trusted third party to broker
trust relationships between a Web service requester and a Web service
provider. It is a common access point trusted by both requester and
provider to provide interoperable security tokens. It removes the need
for a direct relationship between the two. Because the STS is a
standards based mechanism for authentication, it helps ensure
interoperability across realms and between different platforms.</p>
</div>
<div class="paragraph">
<p>The STS&#8217;s WSDL contract defines how other applications and processes
interact with it. In particular the WSDL defines the WS-Trust and
WS-Security policies that a requester must fulfill in order to
successfully communicate with the STS&#8217;s endpoints. A web service
requester consumes the STS&#8217;s WSDL and with the aid of an STSClient
utility, generates a message request compliant with the stated security
policies and submits it to the STS endpoint. The STS validates the
request and returns an appropriate response.</p>
</div>
</div>
<div class="sect3">
<h4 id="apache-cxf-support">5.13.3. Apache CXF support</h4>
<div class="paragraph">
<p>Apache CXF is an open-source, fully featured Web services framework. The
JBossWS open source project integrates the JBoss Web Services (JBossWS)
stack with the Apache CXF project modules thus providing WS-Trust and
other JAX-WS functionality in WildFly. This integration makes it easy to
deploy CXF STS implementations, however WildFly can run any WS-Trust
compliant STS. In addition the Apache CXF API provides a STSClient
utility to facilitate web service requester communication with its STS.</p>
</div>
<div class="paragraph">
<p>Detailed information about the Apache CXF&#8217;s WS-Trust implementation can
be found
<a href="http://coheigea.blogspot.it/2011/10/apache-cxf-sts-documentation-part-i.html">here</a>
.</p>
</div>
</div>
<div class="sect3">
<h4 id="a-basic-ws-trust-scenario">5.13.4. A Basic WS-Trust Scenario</h4>
<div class="paragraph">
<p>Here is an example of a basic WS-Trust scenario. It is comprised of a
Web service requester (ws-requester), a Web service provider
(ws-provider), and a Security Token Service (STS). The ws-provider
requires a SAML 2.0 token issued from a designed STS to be presented by
the ws-requester using asymmetric binding. These communication
requirements are declared in the ws-provider&#8217;s WSDL. The STS requires
ws-requester credentials be provided in a WSS UsernameToken format
request using symmetric binding. The STS&#8217;s response is provided
containing a SAML 2.0 token. These communication requirements are
declared in the STS&#8217;s WSDL.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A ws-requester contacts the ws-provider and consumes its WSDL. Upon
finding the security token issuer requirement, it creates and configures
a STSClient with the information it requires to generate a proper
request.</p>
</li>
<li>
<p>The STSClient contacts the STS and consumes its WSDL. The security
policies are discovered. The STSClient creates and sends an
authentication request, with appropriate credentials.</p>
</li>
<li>
<p>The STS verifies the credentials.</p>
</li>
<li>
<p>In response, the STS issues a security token that provides proof that
the ws-requester has authenticated with the STS.</p>
</li>
<li>
<p>The STClient presents a message with the security token to the
ws-provider.</p>
</li>
<li>
<p>The ws-provider verifies the token was issued by the STS, thus proving
the ws-requester has successfully authenticated with the STS.</p>
</li>
<li>
<p>The ws-provider executes the requested service and returns the results
to the the ws-requester.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="web-service-provider">Web service provider</h5>
<div class="paragraph">
<p>This section examines the crucial elements in providing endpoint
security in the web service provider described in the basic WS-Trust
scenario. The components that will be discussed are.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>web service provider&#8217;s WSDL</p>
</li>
<li>
<p>web service provider&#8217;s Interface and Implementation classes.</p>
</li>
<li>
<p>ServerCallbackHandler class</p>
</li>
<li>
<p>Crypto properties and keystore files</p>
</li>
<li>
<p>MANIFEST.MF</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="web-service-provider-wsdl">Web service provider WSDL</h6>
<div class="paragraph">
<p>The web service provider is a contract-first endpoint. All the WS-trust
and security policies for it are declared in the WSDL,
SecurityService.wsdl. For this scenario a ws-requester is required to
present a SAML 2.0 token issued from a designed STS. The address of the
STS is provided in the WSDL. An asymmetric binding policy is used to
encrypt and sign the SOAP body of messages that pass back and forth
between ws-requester and ws-provider. X.509 certificates are use for the
asymmetric binding. The rules for sharing the public and private keys in
the SOAP request and response messages are declared. A detailed
explanation of the security settings are provided in the comments in the
listing below.</p>
</div>
<div class="literalblock">
<div class="content">
<pre> &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" name="SecurityService"
        xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
        xmlns="http://schemas.xmlsoap.org/wsdl/"
        xmlns:wsp="http://www.w3.org/ns/ws-policy"
        xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"
        xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
        xmlns:wsaws="http://www.w3.org/2005/08/addressing"
        xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"
        xmlns:t="http://docs.oasis-open.org/ws-sx/ws-trust/200512"&gt;
  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy" schemaLocation="SecurityService_schema1.xsd"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="sayHello"&gt;
    &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;
  &lt;message name="sayHelloResponse"&gt;
    &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;
  &lt;portType name="ServiceIface"&gt;
    &lt;operation name="sayHello"&gt;
      &lt;input message="tns:sayHello"/&gt;
      &lt;output message="tns:sayHelloResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
  &lt;!--
        The wsp:PolicyReference binds the security requirments on all the STS endpoints.
        The wsp:Policy wsu:Id="#AsymmetricSAML2Policy" element is defined later in this file.
  --&gt;
  &lt;binding name="SecurityServicePortBinding" type="tns:ServiceIface"&gt;
    &lt;wsp:PolicyReference URI="#AsymmetricSAML2Policy" /&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="sayHello"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
        &lt;wsp:PolicyReference URI="#Input_Policy" /&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
        &lt;wsp:PolicyReference URI="#Output_Policy" /&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;
  &lt;service name="SecurityService"&gt;
    &lt;port name="SecurityServicePort" binding="tns:SecurityServicePortBinding"&gt;
      &lt;soap:address location="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust/SecurityService"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;
 
  &lt;wsp:Policy wsu:Id="AsymmetricSAML2Policy"&gt;
        &lt;wsp:ExactlyOne&gt;
            &lt;wsp:All&gt;
  &lt;!--
        The wsam:Addressing element, indicates that the endpoints of this
        web service MUST conform to the WS-Addressing specification.  The
        attribute wsp:Optional="false" enforces this assertion.
  --&gt;               
                &lt;wsam:Addressing wsp:Optional="false"&gt;
                    &lt;wsp:Policy /&gt;
                &lt;/wsam:Addressing&gt;
  &lt;!--
        The sp:AsymmetricBinding element indicates that security is provided
        at the SOAP layer. A public/private key combinations is required to
        protect the message.  The initiator will use it’s private key to sign
        the message and the recipient’s public key is used to encrypt the message.
        The recipient of the message will use it’s private key to decrypt it and
        initiator’s public key to verify the signature.
  --&gt;              
                &lt;sp:AsymmetricBinding&gt;
                    &lt;wsp:Policy&gt;
  &lt;!--
        The sp:InitiatorToken element specifies the elements required in
        generating the initiator request to the ws-provider's service.
  --&gt;                              
                        &lt;sp:InitiatorToken&gt;
                            &lt;wsp:Policy&gt;
  &lt;!--
        The sp:IssuedToken element asserts that a SAML 2.0 security token is
        expected from the STS using a public key type.  The
        sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
        attribute instructs the runtime to include the initiator's public key
        with every message sent to the recipient.
        
        The sp:RequestSecurityTokenTemplate element directs that all of the
        children of this element will be copied directly into the body of the
        RequestSecurityToken (RST) message that is sent to the STS when the
        initiator asks the STS to issue a token.
  --&gt;
                                &lt;sp:IssuedToken
                                    sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
                                    &lt;sp:RequestSecurityTokenTemplate&gt;
                                        &lt;t:TokenType&gt;http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0&lt;/t:TokenType&gt;
                                        &lt;t:KeyType&gt;http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey&lt;/t:KeyType&gt;
                                    &lt;/sp:RequestSecurityTokenTemplate&gt;
                                    &lt;wsp:Policy&gt;
                                        &lt;sp:RequireInternalReference /&gt;
                                    &lt;/wsp:Policy&gt;
  &lt;!--
        The sp:Issuer element defines the STS's address and endpoint information
        This information is used by the STSClient.
  --&gt;                                   
                                    &lt;sp:Issuer&gt;
                                        &lt;wsaws:Address&gt;http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts/SecurityTokenService&lt;/wsaws:Address&gt;
                                        &lt;wsaws:Metadata xmlns:wsdli="http://www.w3.org/2006/01/wsdl-instance"
                                                        wsdli:wsdlLocation="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts/SecurityTokenService?wsdl"&gt;
                                            &lt;wsaw:ServiceName xmlns:wsaw="http://www.w3.org/2006/05/addressing/wsdl"
                                                            xmlns:stsns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
                                                            EndpointName="UT_Port"&gt;stsns:SecurityTokenService&lt;/wsaw:ServiceName&gt;
                                        &lt;/wsaws:Metadata&gt;
                                    &lt;/sp:Issuer&gt;
                                &lt;/sp:IssuedToken&gt;
                            &lt;/wsp:Policy&gt;
                        &lt;/sp:InitiatorToken&gt;
  &lt;!--
        The sp:RecipientToken element asserts the type of public/private key-pair
        expected from the recipient.  The
        sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
        attribute indicates that the initiator's public key will never be included
        in the reply messages.  

        The sp:WssX509V3Token10 element indicates that an X509 Version 3 token
        should be used in the message.
  --&gt;                       
                        &lt;sp:RecipientToken&gt;
                            &lt;wsp:Policy&gt;
                                &lt;sp:X509Token
                                    sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
                                    &lt;wsp:Policy&gt;
                                        &lt;sp:WssX509V3Token10 /&gt;
                                        &lt;sp:RequireIssuerSerialReference /&gt;
                                    &lt;/wsp:Policy&gt;
                                &lt;/sp:X509Token&gt;
                            &lt;/wsp:Policy&gt;
                        &lt;/sp:RecipientToken&gt;
&lt;!--
     The sp:Layout element,  indicates the layout rules to apply when adding
     items to the security header.  The sp:Lax sub-element indicates items
     are added to the security header in any order that conforms to
     WSS: SOAP Message Security.
--&gt;                       
                        &lt;sp:Layout&gt;
                            &lt;wsp:Policy&gt;
                                &lt;sp:Lax /&gt;
                            &lt;/wsp:Policy&gt;
                        &lt;/sp:Layout&gt;
                        &lt;sp:IncludeTimestamp /&gt;
                        &lt;sp:OnlySignEntireHeadersAndBody /&gt;
 &lt;!--
     The sp:AlgorithmSuite element, requires the Basic256 algorithm suite
     be used in performing cryptographic operations.
--&gt;                      
                        &lt;sp:AlgorithmSuite&gt;
                            &lt;wsp:Policy&gt;
                                &lt;sp:Basic256 /&gt;
                            &lt;/wsp:Policy&gt;
                        &lt;/sp:AlgorithmSuite&gt;
                    &lt;/wsp:Policy&gt;
                &lt;/sp:AsymmetricBinding&gt;
&lt;!--
    The sp:Wss11 element declares WSS: SOAP Message Security 1.1 options
    to be supported by the STS.  These particular elements generally refer
    to how keys are referenced within the SOAP envelope.  These are normally
    handled by CXF.
--&gt;               
                &lt;sp:Wss11&gt;
                    &lt;wsp:Policy&gt;
                        &lt;sp:MustSupportRefIssuerSerial /&gt;
                        &lt;sp:MustSupportRefThumbprint /&gt;
                        &lt;sp:MustSupportRefEncryptedKey /&gt;
                    &lt;/wsp:Policy&gt;
                &lt;/sp:Wss11&gt;
&lt;!--
    The sp:Trust13 element declares controls for WS-Trust 1.3 options.  
    They are policy assertions related to exchanges specifically with
    client and server challenges and entropy behaviors.  Again these are
    normally handled by CXF.
--&gt;               
                &lt;sp:Trust13&gt;
                    &lt;wsp:Policy&gt;
                        &lt;sp:MustSupportIssuedTokens /&gt;
                        &lt;sp:RequireClientEntropy /&gt;
                        &lt;sp:RequireServerEntropy /&gt;
                    &lt;/wsp:Policy&gt;
                &lt;/sp:Trust13&gt;
            &lt;/wsp:All&gt;
        &lt;/wsp:ExactlyOne&gt;
    &lt;/wsp:Policy&gt;
    
    &lt;wsp:Policy wsu:Id="Input_Policy"&gt;
        &lt;wsp:ExactlyOne&gt;
            &lt;wsp:All&gt;
                &lt;sp:EncryptedParts&gt;
                    &lt;sp:Body /&gt;
                &lt;/sp:EncryptedParts&gt;
                &lt;sp:SignedParts&gt;
                    &lt;sp:Body /&gt;
                    &lt;sp:Header Name="To" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="From" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="FaultTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="ReplyTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="MessageID" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="RelatesTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="Action" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                &lt;/sp:SignedParts&gt;
            &lt;/wsp:All&gt;
        &lt;/wsp:ExactlyOne&gt;
    &lt;/wsp:Policy&gt;
    
    &lt;wsp:Policy wsu:Id="Output_Policy"&gt;
        &lt;wsp:ExactlyOne&gt;
            &lt;wsp:All&gt;
                &lt;sp:EncryptedParts&gt;
                    &lt;sp:Body /&gt;
                &lt;/sp:EncryptedParts&gt;
                &lt;sp:SignedParts&gt;
                    &lt;sp:Body /&gt;
                    &lt;sp:Header Name="To" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="From" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="FaultTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="ReplyTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="MessageID" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="RelatesTo" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                    &lt;sp:Header Name="Action" Namespace="http://www.w3.org/2005/08/addressing" /&gt;
                &lt;/sp:SignedParts&gt;
            &lt;/wsp:All&gt;
        &lt;/wsp:ExactlyOne&gt;
    &lt;/wsp:Policy&gt;
&lt;/definitions&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="web-service-provider-interface">Web service provider Interface</h6>
<div class="paragraph">
<p>The web service provider interface class, ServiceIface, is a
straight forward web service definition.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service;

import jakarta.jws.WebMethod;
import jakarta.jws.WebService;

@WebService
(
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy"
)
public interface ServiceIface
{
   @WebMethod
   String sayHello();
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="web-service-provider-implementation">Web service provider Implementation</h6>
<div class="paragraph">
<p>The web service provider implementation class, ServiceImpl, is a simple
POJO. It uses the standard WebService annotation to define the service
endpoint. There are two Apache CXF annotations,
EndpointProperties and EndpointProperty used for configuring the
endpoint for the CXF runtime. These annotations come from the
<a href="https://ws.apache.org/wss4j/">Apache WSS4J project</a> , which provides a
Java implementation of the primary WS-Security standards for Web
Services. These annotations are programmatically adding properties to
the endpoint. With plain Apache CXF, these properties are often set via
the &lt;jaxws:properties&gt; element on the &lt;jaxws:endpoint&gt; element in the
Spring config; these annotations allow the properties to be configured
in the code.</p>
</div>
<div class="paragraph">
<p>WSS4J uses the Crypto interface to get keys and certificates for
encryption/decryption and for signature creation/verification. As is
asserted by the WSDL, X509 keys and certificates are required for this
service. The WSS4J configuration information being provided by
ServiceImpl is for Crypto&#8217;s Merlin implementation. More information will
be provided about this in the keystore section.</p>
</div>
<div class="paragraph">
<p>The first EndpointProperty statement in the listing is declaring the
user&#8217;s name to use for the message signature. It is used as the alias
name in the keystore to get the user&#8217;s cert and private key for
signature. The next two EndpointProperty statements declares the Java
properties file that contains the (Merlin) crypto configuration
information. In this case both for signing and encrypting the messages.
WSS4J reads this file and extra required information for message
handling. The last EndpointProperty statement declares the
ServerCallbackHandler implementation class. It is used to obtain the
user&#8217;s password for the certificates in the keystore file.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service;

import jakarta.jws.WebService;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;

@WebService
(
   portName = "SecurityServicePort",
   serviceName = "SecurityService",
   wsdlLocation = "WEB-INF/wsdl/SecurityService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service.ServiceIface"
)
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "myservicekey"),
      @EndpointProperty(key = "ws-security.signature.properties", value = "serviceKeystore.properties"),
      @EndpointProperty(key = "ws-security.encryption.properties", value = "serviceKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service.ServerCallbackHandler")
})
public class ServiceImpl implements ServiceIface
{
   public String sayHello()
   {
      return "WS-Trust Hello World!";
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="servercallbackhandler">ServerCallbackHandler</h6>
<div class="paragraph">
<p>ServerCallbackHandler is a callback handler for the WSS4J Crypto API. It
is used to obtain the password for the private key in the keystore. This
class enables CXF to retrieve the password of the user name to use for
the message signature. A certificates' password is not discoverable. The
creator of the certificate must record the password he assigns and
provide it when requested through the CallbackHandler. In this scenario
skpass is the password for user myservicekey.</p>
</div>
<div class="literalblock">
<div class="content">
<pre> package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service;

import java.util.HashMap;
import java.util.Map;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;

public class ServerCallbackHandler extends PasswordCallbackHandler
{

   public ServerCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("myservicekey", "skpass");
      return passwords;
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="crypto-properties-and-keystore-files">Crypto properties and keystore files</h6>
<div class="paragraph">
<p>WSS4J&#8217;s Crypto implementation is loaded and configured via a Java
properties file that contains Crypto configuration data. The file
contains implementation-specific properties such as a keystore location,
password, default alias and the like. This application is using the
Merlin implementation. File serviceKeystore.properties contains this
information.</p>
</div>
<div class="paragraph">
<p>File servicestore.jks, is a Java KeyStore (JKS) repository. It contains
self signed certificates for myservicekey and mystskey. <em>Self signed
certificates are not appropriate for production use.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=sspass
org.apache.ws.security.crypto.merlin.keystore.alias=myservicekey
org.apache.ws.security.crypto.merlin.keystore.file=servicestore.jks</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="manifest-mf">MANIFEST.MF</h6>
<div class="paragraph">
<p>When deployed on WildFly this application requires access to the JBossWS
and Apache CXF APIs provided in module
org.jboss.ws.cxf.jbossws-cxf-client. The dependency statement directs
the server to provide them at deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version: 1.0  
Ant-Version: Apache Ant 1.8.2  
Created-By: 1.7.0_25-b15 (Oracle Corporation)  
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="security-token-service-sts">Security Token Service (STS)</h5>
<div class="paragraph">
<p>This section examines the crucial elements in providing the Security
Token Service functionality described in the basic WS-Trust scenario.
The components that will be discussed are.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>STS&#8217;s WSDL</p>
</li>
<li>
<p>STS&#8217;s implementation class.</p>
</li>
<li>
<p>STSCallbackHandler class</p>
</li>
<li>
<p>Crypto properties and keystore files</p>
</li>
<li>
<p>MANIFEST.MF</p>
</li>
<li>
<p>Server configuration files</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="sts-wsdl">STS WSDL</h6>
<div class="paragraph">
<p>The STS is a contract-first endpoint. All the WS-trust and security
policies for it are declared in the WSDL, ws-trust-1.4-service.wsdl. A
symmetric binding policy is used to encrypt and sign the SOAP body of
messages that pass back and forth between ws-requester and the STS. The
ws-requester is required to authenticate itself by providing WSS
UsernameToken credentials. The rules for sharing the public and private
keys in the SOAP request and response messages are declared. A detailed
explanation of the security settings is provided in the comments in the
listing below.</p>
</div>
<div class="literalblock">
<div class="content">
<pre> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;wsdl:definitions
        targetNamespace="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
        xmlns:tns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
        xmlns:wstrust="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
        xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
        xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
        xmlns:wsap10="http://www.w3.org/2006/05/addressing/wsdl"
        xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
        xmlns:wsp="http://www.w3.org/ns/ws-policy"
    xmlns:wst="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"&gt;

  &lt;wsdl:types&gt;
    &lt;xs:schema elementFormDefault="qualified" targetNamespace='http://docs.oasis-open.org/ws-sx/ws-trust/200512'&gt;

      &lt;xs:element name='RequestSecurityToken' type='wst:AbstractRequestSecurityTokenType' /&gt;
      &lt;xs:element name='RequestSecurityTokenResponse' type='wst:AbstractRequestSecurityTokenType' /&gt;

      &lt;xs:complexType name='AbstractRequestSecurityTokenType' &gt;
        &lt;xs:sequence&gt;
          &lt;xs:any namespace='##any' processContents='lax' minOccurs='0' maxOccurs='unbounded' /&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name='Context' type='xs:anyURI' use='optional' /&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax' /&gt;
      &lt;/xs:complexType&gt;
      &lt;xs:element name='RequestSecurityTokenCollection' type='wst:RequestSecurityTokenCollectionType' /&gt;
      &lt;xs:complexType name='RequestSecurityTokenCollectionType' &gt;
        &lt;xs:sequence&gt;
          &lt;xs:element name='RequestSecurityToken' type='wst:AbstractRequestSecurityTokenType' minOccurs='2' maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name='RequestSecurityTokenResponseCollection' type='wst:RequestSecurityTokenResponseCollectionType' /&gt;
      &lt;xs:complexType name='RequestSecurityTokenResponseCollectionType' &gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref='wst:RequestSecurityTokenResponse' minOccurs='1' maxOccurs='unbounded' /&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax' /&gt;
      &lt;/xs:complexType&gt;

    &lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;

  &lt;!-- WS-Trust defines the following GEDs --&gt;
  &lt;wsdl:message name="RequestSecurityTokenMsg"&gt;
    &lt;wsdl:part name="request" element="wst:RequestSecurityToken" /&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseMsg"&gt;
    &lt;wsdl:part name="response"
            element="wst:RequestSecurityTokenResponse" /&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenCollectionMsg"&gt;
    &lt;wsdl:part name="requestCollection"
            element="wst:RequestSecurityTokenCollection"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseCollectionMsg"&gt;
    &lt;wsdl:part name="responseCollection"
            element="wst:RequestSecurityTokenResponseCollection"/&gt;
  &lt;/wsdl:message&gt;

  &lt;!-- This portType an example of a Requestor (or other) endpoint that
         Accepts SOAP-based challenges from a Security Token Service --&gt;
  &lt;wsdl:portType name="WSSecurityRequestor"&gt;
    &lt;wsdl:operation name="Challenge"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;


  &lt;!-- This portType is an example of an STS supporting full protocol --&gt;
&lt;!--
    The wsdl:portType and data types are XML elements defined by the
    WS_Trust specification.  The wsdl:portType defines the endpoints
    supported in the STS implementation.  This WSDL defines all operations
    that an STS implementation can support.
--&gt;      
  &lt;wsdl:portType name="STS"&gt;
    &lt;wsdl:operation name="Cancel"&gt;
      &lt;wsdl:input wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/CancelFinal" message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Issue"&gt;
      &lt;wsdl:input wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTRC/IssueFinal" message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Renew"&gt;
      &lt;wsdl:input wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/RenewFinal" message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Validate"&gt;
      &lt;wsdl:input wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/ValidateFinal" message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="KeyExchangeToken"&gt;
      &lt;wsdl:input wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KET" message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/KETFinal" message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="RequestCollection"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenCollectionMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!-- This portType is an example of an endpoint that accepts
         Unsolicited RequestSecurityTokenResponse messages --&gt;
  &lt;wsdl:portType name="SecurityTokenResponseService"&gt;
    &lt;wsdl:operation name="RequestSecurityTokenResponse"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

&lt;!--
    The wsp:PolicyReference binds the security requirments on all the STS endpoints.
    The wsp:Policy wsu:Id="UT_policy" element is later in this file.
--&gt;
  &lt;wsdl:binding name="UT_Binding" type="wstrust:STS"&gt;
    &lt;wsp:PolicyReference URI="#UT_policy" /&gt;
      &lt;soap:binding style="document"
          transport="http://schemas.xmlsoap.org/soap/http" /&gt;
      &lt;wsdl:operation name="Issue"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue" /&gt;
          &lt;wsdl:input&gt;
              &lt;wsp:PolicyReference
               URI="#Input_policy" /&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;wsp:PolicyReference
               URI="#Output_policy" /&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
      &lt;wsdl:operation name="Validate"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate" /&gt;
          &lt;wsdl:input&gt;
              &lt;wsp:PolicyReference
               URI="#Input_policy" /&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;wsp:PolicyReference
               URI="#Output_policy" /&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
      &lt;wsdl:operation name="Cancel"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel" /&gt;
          &lt;wsdl:input&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
      &lt;wsdl:operation name="Renew"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew" /&gt;
          &lt;wsdl:input&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
      &lt;wsdl:operation name="KeyExchangeToken"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KeyExchangeToken" /&gt;
          &lt;wsdl:input&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
      &lt;wsdl:operation name="RequestCollection"&gt;
          &lt;soap:operation
              soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/RequestCollection" /&gt;
          &lt;wsdl:input&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:input&gt;
          &lt;wsdl:output&gt;
              &lt;soap:body use="literal" /&gt;
          &lt;/wsdl:output&gt;
      &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
 
  &lt;wsdl:service name="SecurityTokenService"&gt;
      &lt;wsdl:port name="UT_Port" binding="tns:UT_Binding"&gt;
         &lt;soap:address location="http://localhost:8080/SecurityTokenService/UT" /&gt;
      &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
 
  &lt;wsp:Policy wsu:Id="UT_policy"&gt;
      &lt;wsp:ExactlyOne&gt;
         &lt;wsp:All&gt;
&lt;!--
    The sp:UsingAddressing element, indicates that the endpoints of this
    web service conforms to the WS-Addressing specification.  More detail
    can be found here: [http://www.w3.org/TR/2006/CR-ws-addr-wsdl-20060529]
--&gt;  
            &lt;wsap10:UsingAddressing/&gt;
&lt;!--
    The sp:SymmetricBinding element indicates that security is provided
    at the SOAP layer and any initiator must authenticate itself by providing
    WSS UsernameToken credentials.
--&gt;            
            &lt;sp:SymmetricBinding
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
&lt;!--
    In a symmetric binding, the keys used for encrypting and signing in both
    directions are derived from a single key, the one specified by the
    sp:ProtectionToken element.  The sp:X509Token sub-element declares this
    key to be a X.509 certificate and the
    IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"
    attribute adds the requirement that the token MUST NOT be included in
    any messages sent between the initiator and the recipient; rather, an
    external reference to the token should be used.  Lastly the WssX509V3Token10
    sub-element declares that the Username token presented by the initiator
    should be compliant with Web Services Security UsernameToken Profile
    1.0 specification. [ http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0.pdf ]
--&gt;                      
                  &lt;sp:ProtectionToken&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:X509Token
                           sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
                           &lt;wsp:Policy&gt;
                              &lt;sp:RequireDerivedKeys /&gt;
                              &lt;sp:RequireThumbprintReference /&gt;
                              &lt;sp:WssX509V3Token10 /&gt;
                           &lt;/wsp:Policy&gt;
                        &lt;/sp:X509Token&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:ProtectionToken&gt;
&lt;!--
    The sp:AlgorithmSuite element, requires the Basic256 algorithm suite
    be used in performing cryptographic operations.
--&gt;                  
                  &lt;sp:AlgorithmSuite&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:Basic256 /&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:AlgorithmSuite&gt;
&lt;!--
    The sp:Layout element,  indicates the layout rules to apply when adding
    items to the security header.  The sp:Lax sub-element indicates items
    are added to the security header in any order that conforms to
    WSS: SOAP Message Security.
--&gt;                 
                  &lt;sp:Layout&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:Lax /&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:Layout&gt;
                  &lt;sp:IncludeTimestamp /&gt;
                  &lt;sp:EncryptSignature /&gt;
                  &lt;sp:OnlySignEntireHeadersAndBody /&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:SymmetricBinding&gt;
&lt;!--
    The sp:SignedSupportingTokens element declares that the security header
    of messages must contain a sp:UsernameToken and the token must be signed.  
    The attribute IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"
    on sp:UsernameToken indicates that the token MUST be included in all
    messages sent from initiator to the recipient and that the token MUST
    NOT be included in messages sent from the recipient to the initiator.  
    And finally the element sp:WssUsernameToken10 is a policy assertion
    indicating the Username token should be as defined in  Web Services
    Security UsernameToken Profile 1.0
--&gt;            
            &lt;sp:SignedSupportingTokens
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
                  &lt;sp:UsernameToken
                     sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
                     &lt;wsp:Policy&gt;
                        &lt;sp:WssUsernameToken10 /&gt;
                     &lt;/wsp:Policy&gt;
                  &lt;/sp:UsernameToken&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:SignedSupportingTokens&gt;
&lt;!--
    The sp:Wss11 element declares WSS: SOAP Message Security 1.1 options
    to be supported by the STS.  These particular elements generally refer
    to how keys are referenced within the SOAP envelope.  These are normally
    handled by CXF.
--&gt;            
            &lt;sp:Wss11
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
                  &lt;sp:MustSupportRefKeyIdentifier /&gt;
                  &lt;sp:MustSupportRefIssuerSerial /&gt;
                  &lt;sp:MustSupportRefThumbprint /&gt;
                  &lt;sp:MustSupportRefEncryptedKey /&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:Wss11&gt;
&lt;!--
    The sp:Trust13 element declares controls for WS-Trust 1.3 options.  
    They are policy assertions related to exchanges specifically with
    client and server challenges and entropy behaviors.  Again these are
    normally handled by CXF.
--&gt;            
            &lt;sp:Trust13
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;wsp:Policy&gt;
                  &lt;sp:MustSupportIssuedTokens /&gt;
                  &lt;sp:RequireClientEntropy /&gt;
                  &lt;sp:RequireServerEntropy /&gt;
               &lt;/wsp:Policy&gt;
            &lt;/sp:Trust13&gt;
         &lt;/wsp:All&gt;
      &lt;/wsp:ExactlyOne&gt;
   &lt;/wsp:Policy&gt;
   
   &lt;wsp:Policy wsu:Id="Input_policy"&gt;
      &lt;wsp:ExactlyOne&gt;
         &lt;wsp:All&gt;
            &lt;sp:SignedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
               &lt;sp:Header Name="To"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="From"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="FaultTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="ReplyTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="MessageID"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="RelatesTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="Action"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
            &lt;/sp:SignedParts&gt;
            &lt;sp:EncryptedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
            &lt;/sp:EncryptedParts&gt;
         &lt;/wsp:All&gt;
      &lt;/wsp:ExactlyOne&gt;
   &lt;/wsp:Policy&gt;
   
   &lt;wsp:Policy wsu:Id="Output_policy"&gt;
      &lt;wsp:ExactlyOne&gt;
         &lt;wsp:All&gt;
            &lt;sp:SignedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
               &lt;sp:Header Name="To"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="From"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="FaultTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="ReplyTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="MessageID"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="RelatesTo"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
               &lt;sp:Header Name="Action"
                  Namespace="http://www.w3.org/2005/08/addressing" /&gt;
            &lt;/sp:SignedParts&gt;
            &lt;sp:EncryptedParts
               xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
               &lt;sp:Body /&gt;
            &lt;/sp:EncryptedParts&gt;
         &lt;/wsp:All&gt;
      &lt;/wsp:ExactlyOne&gt;
   &lt;/wsp:Policy&gt;

&lt;/wsdl:definitions&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sts-implementation">STS Implementation</h6>
<div class="paragraph">
<p>The Apache CXF&#8217;s STS, SecurityTokenServiceProvider, is a web service
provider that is compliant with the protocols and functionality defined
by the WS-Trust specification. It has a modular architecture. Many of
its components are configurable or replaceable and there are many
optional features that are enabled by implementing and configuring
plug-ins. Users can customize their own STS by extending from
SecurityTokenServiceProvider and overriding the default settings.
Extensive information about the CXF&#8217;s STS configurable and pluggable
components can be found
<a href="http://coheigea.blogspot.com/2011/11/apache-cxf-sts-documentation-part-viii_10.html">here</a>
.</p>
</div>
<div class="paragraph">
<p>This STS implementation class, SimpleSTS, is a POJO that extends from
SecurityTokenServiceProvider. Note that the class is defined with a
WebServiceProvider annotation and not a WebService annotation. This
annotation defines the service as a Provider-based endpoint, meaning it
supports a more messaging-oriented approach to Web services. In
particular, it signals that the exchanged messages will be XML documents
of some type. SecurityTokenServiceProvider is an implementation of the
jakarta.xml.ws.Provider interface. In comparison the WebService annotation
defines a (service endpoint interface) SEI-based endpoint which supports
message exchange via SOAP envelopes.</p>
</div>
<div class="paragraph">
<p>As was done in the ServiceImpl class, the WSS4J annotations
EndpointProperties and EndpointProperty are providing endpoint
configuration for the CXF runtime. This was previous described
<a href="#web-service-provider-implementation">Web service provider Implementation</a>
.</p>
</div>
<div class="paragraph">
<p>The InInterceptors annotation is used to specify a JBossWS integration
interceptor to be used for authenticating incoming requests; JAAS
integration is used here for authentication, the username/passoword
coming from the UsernameToken in the ws-requester message are used for
authenticating the requester against a security domain on the
application server hosting the STS deployment.</p>
</div>
<div class="paragraph">
<p>In this implementation we are customizing the operations of token
issuance, token validation and their static properties.</p>
</div>
<div class="paragraph">
<p>StaticSTSProperties is used to set select properties for configuring
resources in the STS. You may think this is a duplication of the
settings made with the WSS4J annotations. The values are the same but
the underlaying structures being set are different, thus this
information must be declared in both places.</p>
</div>
<div class="paragraph">
<p>The setIssuer setting is important because it uniquely identifies the
issuing STS. The issuer string is embedded in issued tokens and, when
validating tokens, the STS checks the issuer string value. Consequently,
it is important to use the issuer string in a consistent way, so that
the STS can recognize the tokens that it has issued.</p>
</div>
<div class="paragraph">
<p>The setEndpoints call allows the declaration of a set of allowed token
recipients by address. The addresses are specified as reg-ex patterns.</p>
</div>
<div class="paragraph">
<p>TokenIssueOperation and TokenValidateOperation have a modular structure.
This allows custom behaviors to be injected into the processing of
messages. In this case we are overriding the
SecurityTokenServiceProvider&#8217;s default behavior and performing SAML
token processing and validation. CXF provides an implementation of a
SAMLTokenProvider and SAMLTokenValidator which we are using rather than
writing our own.</p>
</div>
<div class="paragraph">
<p>Learn more about the SAMLTokenProvider
<a href="http://coheigea.blogspot.it/2011/10/apache-cxf-sts-documentation-part-iv.html">here</a>
.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust;
 
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
 
import jakarta.xml.ws.WebServiceProvider;
 
import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.interceptor.InInterceptors;
import org.apache.cxf.sts.StaticSTSProperties;
import org.apache.cxf.sts.operation.TokenIssueOperation;
import org.apache.cxf.sts.operation.TokenValidateOperation;
import org.apache.cxf.sts.service.ServiceMBean;
import org.apache.cxf.sts.service.StaticService;
import org.apache.cxf.sts.token.provider.SAMLTokenProvider;
import org.apache.cxf.sts.token.validator.SAMLTokenValidator;
import org.apache.cxf.ws.security.sts.provider.SecurityTokenServiceProvider;
 
@WebServiceProvider(serviceName = "SecurityTokenService",
      portName = "UT_Port",
      targetNamespace = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/",
      wsdlLocation = "WEB-INF/wsdl/ws-trust-1.4-service.wsdl")
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "mystskey"),
      @EndpointProperty(key = "ws-security.signature.properties", value = "stsKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.STSCallbackHandler"),
      //to let the JAAS integration deal with validation through the interceptor below
      @EndpointProperty(key = "ws-security.validate.token", value = "false")
        
})
@InInterceptors(interceptors = {"org.jboss.wsf.stack.cxf.security.authentication.SubjectCreatingPolicyInterceptor"})
public class SampleSTS extends SecurityTokenServiceProvider
{
   public SampleSTS() throws Exception
   {
      super();
 
      StaticSTSProperties props = new StaticSTSProperties();
      props.setSignaturePropertiesFile("stsKeystore.properties");
      props.setSignatureUsername("mystskey");
      props.setCallbackHandlerClass(STSCallbackHandler.class.getName());
      props.setIssuer("DoubleItSTSIssuer");
 
      List&lt;ServiceMBean&gt; services = new LinkedList&lt;ServiceMBean&gt;();
      StaticService service = new StaticService();
      service.setEndpoints(Arrays.asList(
              "http://localhost:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService",
              "http://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService",
              "http://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService"
              ));
      services.add(service);
 
      TokenIssueOperation issueOperation = new TokenIssueOperation();
      issueOperation.setServices(services);
      issueOperation.getTokenProviders().add(new SAMLTokenProvider());
      issueOperation.setStsProperties(props);
 
      TokenValidateOperation validateOperation = new TokenValidateOperation();
      validateOperation.getTokenValidators().add(new SAMLTokenValidator());
      validateOperation.setStsProperties(props);
 
      this.setIssueOperation(issueOperation);
      this.setValidateOperation(validateOperation);
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="stscallbackhandler">STSCallbackHandler</h6>
<div class="paragraph">
<p>STSCallbackHandler is a callback handler for the WSS4J Crypto API. It is
used to obtain the password for the private key in the keystore. This
class enables CXF to retrieve the password of the user name to use for
the message signature.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.sts;

import java.util.HashMap;
import java.util.Map;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;

public class STSCallbackHandler extends PasswordCallbackHandler
{
   public STSCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("mystskey", "stskpass");
      return passwords;
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="crypto-properties-and-keystore-files-2">Crypto properties and keystore files</h6>
<div class="paragraph">
<p>WSS4J&#8217;s Crypto implementation is loaded and configured via a Java
properties file that contains Crypto configuration data. The file
contains implementation-specific properties such as a keystore location,
password, default alias and the like. This application is using the
Merlin implementation. File stsKeystore.properties contains this
information.</p>
</div>
<div class="paragraph">
<p>File servicestore.jks, is a Java KeyStore (JKS) repository. It contains
self signed certificates for myservicekey and mystskey. <em>Self signed
certificates are not appropriate for production use.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin  
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=stsspass
org.apache.ws.security.crypto.merlin.keystore.file=stsstore.jks</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="manifest-mf-2">MANIFEST.MF</h6>
<div class="paragraph">
<p>When deployed on WildFly, this application requires access to the
JBossWS and Apache CXF APIs provided in module
org.jboss.ws.cxf.jbossws-cxf-client. The org.jboss.ws.cxf.sts module is
also needed to build the STS configuration in the <code>SampleSTS</code>
constructor. The dependency statement directs the server to provide them
at deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version: 1.0  
Ant-Version: Apache Ant 1.8.2  
Created-By: 1.7.0_25-b15 (Oracle Corporation)  
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client,org.jboss.ws.cxf.sts</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="security-domain">Security Domain</h6>
<div class="paragraph">
<p>The STS requires a JBoss security domain be configured. The
jboss-web.xml descriptor declares a named security
domain,"JBossWS-trust-sts" to be used by this service for
authentication. This security domain requires two properties files and
the addition of a security-domain declaration in the JBoss server
configuration file.</p>
</div>
<div class="paragraph">
<p>For this scenario the domain needs to contain user <em>alice</em> , password
<em>clarinet</em> , and role <em>friend</em> . See the listings below for
jbossws-users.properties and jbossws-roles.properties. The
following XML must be added to the JBoss security subsystem in the
server configuration file. Replace " <strong>SOME_PATH</strong> " with appropriate
information.</p>
</div>
<div class="literalblock">
<div class="content">
<pre> &lt;security-domain name="JBossWS-trust-sts"&gt;
  &lt;authentication&gt;
    &lt;login-module code="UsersRoles" flag="required"&gt;
      &lt;module-option name="usersProperties" value="/SOME_PATH/jbossws-users.properties"/&gt;
      &lt;module-option name="unauthenticatedIdentity" value="anonymous"/&gt;
      &lt;module-option name="rolesProperties" value="/SOME_PATH/jbossws-roles.properties"/&gt;
    &lt;/login-module&gt;
  &lt;/authentication&gt;
&lt;/security-domain&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>jboss-web.xml</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;  
&lt;!DOCTYPE jboss-web PUBLIC "-//JBoss//DTD Web Application 2.4//EN" "&gt;  
&lt;jboss-web&gt;  
  &lt;security-domain&gt;java:/jaas/JBossWS-trust-sts&lt;/security-domain&gt;  
&lt;/jboss-web&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>jbossws-users.properties</p>
</div>
<div class="literalblock">
<div class="content">
<pre># A sample users.properties file for use with the UsersRolesLoginModule  
alice=clarinet</pre>
</div>
</div>
<div class="paragraph">
<p>jbossws-roles.properties</p>
</div>
<div class="literalblock">
<div class="content">
<pre># A sample roles.properties file for use with the UsersRolesLoginModule  
alice=friend</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">WS-MetadataExchange and interoperability</div>
<div class="paragraph">
<p>To achieve better interoperability, you might consider allowing the STS
endpoint to reply to WS-MetadataExchange messages directed to the <code>/mex</code>
URL sub-path (e.g.
<a href="http://localhost:8080/jaxws-samples-wsse-policy-trust-sts/SecurityTokenService/mex" class="bare">http://localhost:8080/jaxws-samples-wsse-policy-trust-sts/SecurityTokenService/mex</a>
). This can be done by tweaking the <em>url-pattern</em> for the underlying
endpoint servlet, for instance by adding a <em>web.xml</em> descriptor as
follows to the deployment:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="5.0" xmlns="https://jakarta.ee/xml/ns/jakartaee""
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"&gt; &lt;servlet&gt;
&lt;servlet-name&gt;TestSecurityTokenService&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.trust.SampleSTS&lt;/servlet-class&gt;
&lt;/servlet&gt; &lt;servlet-mapping&gt;
&lt;servlet-name&gt;TestSecurityTokenService&lt;/servlet-name&gt;
&lt;url-pattern&gt;/SecurityTokenService/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>At the time of writing some webservices
implementations (including <em>Metro</em> ) assume the <code>/mex</code> URL as the
default choice for directing WS-MetadataExchange requests to and use
that to retrieve STS wsdl contracts.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="web-service-requester">Web service requester</h5>
<div class="paragraph">
<p>This section examines the crucial elements in calling a web service that
implements endpoint security as described in the basic WS-Trust
scenario. The components that will be discussed are.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>web service requestor&#8217;s implementation</p>
</li>
<li>
<p>ClientCallbackHandler</p>
</li>
<li>
<p>Crypto properties and keystore files</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="web-service-requester-implementation">Web service requester Implementation</h6>
<div class="paragraph">
<p>The ws-requester, the client, uses standard procedures for creating a
reference to the web service in the first four line. To address the
endpoint security requirements, the web service&#8217;s "Request Context" is
configured with the information needed in message generation.
The STSClient that communicates with the STS is configured
with similar values. Note the key strings ending with a ".it" suffix.
This suffix flags these settings as belonging to the STSClient. The
internal CXF code assigns this information to the STSClient that is
auto-generated for this service call.</p>
</div>
<div class="paragraph">
<p>There is an alternate method of setting up the STSCLient. The user may
provide their own instance of the STSClient. The CXF code will use this
object and not auto-generate one. This is used in the ActAs and
OnBehalfOf examples. When providing the STSClient in this way, the user
must provide a org.apache.cxf.Bus for it and the configuration keys must
not have the ".it" suffix.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy", "SecurityService");  
URL wsdlURL = new URL(serviceURL + "?wsdl");  
Service service = Service.create(wsdlURL, serviceName);  
ServiceIface proxy = (ServiceIface) service.getPort(ServiceIface.class);  
 
// set the security related configuration information for the service "request"  
Map&lt;String, Object&gt; ctx = ((BindingProvider) proxy).getRequestContext();  
ctx.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());  
ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
   Thread.currentThread().getContextClassLoader().getResource(
   "META-INF/clientKeystore.properties"));  
ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
   Thread.currentThread().getContextClassLoader().getResource(
   "META-INF/clientKeystore.properties"));  
ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myclientkey");  
ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myservicekey");  
 
 
//-- Configuration settings that will be transfered to the STSClient  
// "alice" is the name provided for the WSS Username. Her password will  
// be retreived from the ClientCallbackHander by the STSClient.  
ctx.put(SecurityConstants.USERNAME + ".it", "alice");  
ctx.put(SecurityConstants.CALLBACK_HANDLER + ".it", new ClientCallbackHandler());  
ctx.put(SecurityConstants.ENCRYPT_PROPERTIES + ".it",
   Thread.currentThread().getContextClassLoader().getResource(
   "META-INF/clientKeystore.properties"));  
ctx.put(SecurityConstants.ENCRYPT_USERNAME + ".it", "mystskey");  
// alias name in the keystore to get the user's public key to send to the STS  
ctx.put(SecurityConstants.STS_TOKEN_USERNAME + ".it", "myclientkey");  
// Crypto property configuration to use for the STS  
ctx.put(SecurityConstants.STS_TOKEN_PROPERTIES + ".it",
   Thread.currentThread().getContextClassLoader().getResource(
   "META-INF/clientKeystore.properties"));  
// write out an X509Certificate structure in UseKey/KeyInfo  
ctx.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO + ".it", "true");  
// Setting indicates the  STSclient should not try using the WS-MetadataExchange  
// call using STS EPR WSA address when the endpoint contract does not contain  
// WS-MetadataExchange info.  
ctx.put("ws-security.sts.disable-wsmex-call-using-epr-address", "true");  
   
proxy.sayHello();</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="clientcallbackhandler">ClientCallbackHandler</h6>
<div class="paragraph">
<p>ClientCallbackHandler is a callback handler for the WSS4J Crypto API. It
is used to obtain the password for the private key in the keystore. This
class enables CXF to retrieve the password of the user name to use for
the message signature. Note that "alice" and her password have been
provided here. This information is not in the (JKS) keystore but
provided in the WildFly security domain. It was declared in file
jbossws-users.properties.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared;  
 
import java.io.IOException;  
import javax.security.auth.callback.Callback;  
import javax.security.auth.callback.CallbackHandler;  
import javax.security.auth.callback.UnsupportedCallbackException;  
import org.apache.ws.security.WSPasswordCallback;  
 
public class ClientCallbackHandler implements CallbackHandler {  
 
    public void handle(Callback[] callbacks) throws IOException,  
            UnsupportedCallbackException {  
        for (int i = 0; i &lt; callbacks.length; i++) {  
            if (callbacks[i] instanceof WSPasswordCallback) {  
                WSPasswordCallback pc = (WSPasswordCallback) callbacks[i];  
                if ("myclientkey".equals(pc.getIdentifier())) {  
                    pc.setPassword("ckpass");  
                    break;  
                } else if ("alice".equals(pc.getIdentifier())) {  
                    pc.setPassword("clarinet");  
                    break;  
                }  
            }  
        }  
    }  
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="requester-crypto-properties-and-keystore-files">Requester Crypto properties and keystore files</h6>
<div class="paragraph">
<p>WSS4J&#8217;s Crypto implementation is loaded and configured via a Java
properties file that contains Crypto configuration data. The file
contains implementation-specific properties such as a keystore location,
password, default alias and the like. This application is using the
Merlin implementation. File clientKeystore.properties contains this
information.</p>
</div>
<div class="paragraph">
<p>File clientstore.jks, is a Java KeyStore (JKS) repository. It contains
self signed certificates for myservicekey and mystskey. <em>Self signed
certificates are not appropriate for production use.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=cspass
org.apache.ws.security.crypto.merlin.keystore.alias=myclientkey
org.apache.ws.security.crypto.merlin.keystore.file=META-INF/clientstore.jks</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="actas-ws-trust-scenario">5.13.5. ActAs WS-Trust Scenario</h4>
<div class="paragraph">
<p>The ActAs feature is used in scenarios that require composite
delegation. It is commonly used in multi-tiered systems where an
application calls a service on behalf of a logged in user or a service
calls another service on behalf of the original caller.</p>
</div>
<div class="paragraph">
<p>ActAs is nothing more than a new sub-element in the RequestSecurityToken
(RST). It provides additional information about the original caller when
a token is negotiated with the STS. The ActAs element usually takes the
form of a token with identity claims such as name, role, and
authorization code, for the client to access the service.</p>
</div>
<div class="paragraph">
<p>The ActAs scenario is an extension of <a href="#a-basic-ws-trust-scenario">A Basic WS-Trust Scenario</a>. In this example the ActAs service calls the
ws-service on behalf of a user. There are only a couple of additions to
the basic scenario&#8217;s code. An ActAs web service provider and callback
handler have been added. The ActAs web services' WSDL imposes the same
security policies as the ws-provider. UsernameTokenCallbackHandler is
new. It is a utility that generates the content for the ActAs element.
And lastly there are a couple of code additions in the STS to support
the ActAs request.</p>
</div>
<div class="sect4">
<h5 id="web-service-provider-2">Web service provider</h5>
<div class="paragraph">
<p>This section examines the web service elements from the basic WS-Trust
scenario that have been changed to address the needs of the ActAs
example. The components are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ActAs web service provider&#8217;s WSDL</p>
</li>
<li>
<p>ActAs web service provider&#8217;s Interface and Implementation classes.</p>
</li>
<li>
<p>ActAsCallbackHandler class</p>
</li>
<li>
<p>UsernameTokenCallbackHandler</p>
</li>
<li>
<p>Crypto properties and keystore files</p>
</li>
<li>
<p>MANIFEST.MF</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="web-service-provider-wsdl-2">Web service provider WSDL</h6>
<div class="paragraph">
<p>The ActAs web service provider&#8217;s WSDL is a clone of the ws-provider&#8217;s
WSDL. The wsp:Policy section is the same. There are changes to the
service endpoint, targetNamespace, portType, binding name, and service.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy" name="ActAsService"
             xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
             xmlns:wsp="http://www.w3.org/ns/ws-policy"
             xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"
             xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
             xmlns:wsaws="http://www.w3.org/2005/08/addressing"
             xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"
             xmlns:t="http://docs.oasis-open.org/ws-sx/ws-trust/200512"&gt;
    &lt;types&gt;
        &lt;xsd:schema&gt;
            &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy"
                    schemaLocation="ActAsService_schema1.xsd"/&gt;
        &lt;/xsd:schema&gt;
    &lt;/types&gt;
    &lt;message name="sayHello"&gt;
        &lt;part name="parameters" element="tns:sayHello"/&gt;
    &lt;/message&gt;
    &lt;message name="sayHelloResponse"&gt;
        &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
    &lt;/message&gt;
    &lt;portType name="ActAsServiceIface"&gt;
        &lt;operation name="sayHello"&gt;
            &lt;input message="tns:sayHello"/&gt;
            &lt;output message="tns:sayHelloResponse"/&gt;
        &lt;/operation&gt;
    &lt;/portType&gt;
    &lt;binding name="ActAsServicePortBinding" type="tns:ActAsServiceIface"&gt;
        &lt;wsp:PolicyReference URI="#AsymmetricSAML2Policy" /&gt;
        &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
        &lt;operation name="sayHello"&gt;
            &lt;soap:operation soapAction=""/&gt;
            &lt;input&gt;
                &lt;soap:body use="literal"/&gt;
                &lt;wsp:PolicyReference URI="#Input_Policy" /&gt;
            &lt;/input&gt;
            &lt;output&gt;
                &lt;soap:body use="literal"/&gt;
                &lt;wsp:PolicyReference URI="#Output_Policy" /&gt;
            &lt;/output&gt;
        &lt;/operation&gt;
    &lt;/binding&gt;
    &lt;service name="ActAsService"&gt;
        &lt;port name="ActAsServicePort" binding="tns:ActAsServicePortBinding"&gt;
            &lt;soap:address location="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-actas/ActAsService"/&gt;
        &lt;/port&gt;
    &lt;/service&gt;

&lt;/definitions&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="web-service-interface">Web Service Interface</h6>
<div class="paragraph">
<p>The web service provider interface class, ActAsServiceIface, is a simple
web service definition.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.actas;

import jakarta.jws.WebMethod;
import jakarta.jws.WebService;

@WebService
(
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy"
)
public interface ActAsServiceIface
{
   @WebMethod
   String sayHello();
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="web-service-implementation">Web Service Implementation</h6>
<div class="paragraph">
<p>The web service provider implementation class, ActAsServiceImpl, is a
POJO. It uses the standard WebService annotation to define the
service endpoint and two Apache WSS4J annotations, EndpointProperties
and EndpointProperty used for configuring the endpoint for the CXF
runtime. The WSS4J configuration information provided is for WSS4J&#8217;s
Crypto Merlin implementation.</p>
</div>
<div class="paragraph">
<p>ActAsServiceImpl is calling ServiceImpl acting on behalf of the user.
Method setupService performs the requisite configuration setup.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.actas;

import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.ws.security.SecurityConstants;
import org.apache.cxf.ws.security.trust.STSClient;
import org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service.ServiceIface;
import org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared.WSTrustAppUtils;

import jakarta.jws.WebService;
import javax.xml.namespace.QName;
import jakarta.xml.ws.BindingProvider;
import jakarta.xml.ws.Service;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Map;

@WebService
(
   portName = "ActAsServicePort",
   serviceName = "ActAsService",
   wsdlLocation = "WEB-INF/wsdl/ActAsService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.actas.ActAsServiceIface"
)

@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "myactaskey"),
      @EndpointProperty(key = "ws-security.signature.properties", value =  "actasKeystore.properties"),
      @EndpointProperty(key = "ws-security.encryption.properties", value = "actasKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.actas.ActAsCallbackHandler")
})

public class ActAsServiceImpl implements ActAsServiceIface
{
   public String sayHello() {
      try {
         ServiceIface proxy = setupService();
         return "ActAs " + proxy.sayHello();
      } catch (MalformedURLException e) {
         e.printStackTrace();
      }
      return null;
   }

   private  ServiceIface setupService()throws MalformedURLException {
      ServiceIface proxy = null;
      Bus bus = BusFactory.newInstance().createBus();

      try {
         BusFactory.setThreadDefaultBus(bus);

         final String serviceURL = "http://" + WSTrustAppUtils.getServerHost() + ":8080/jaxws-samples-wsse-policy-trust/SecurityService";
         final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy", "SecurityService");
         final URL wsdlURL = new URL(serviceURL + "?wsdl");
         Service service = Service.create(wsdlURL, serviceName);
         proxy = (ServiceIface) service.getPort(ServiceIface.class);

         Map&lt;String, Object&gt; ctx = ((BindingProvider) proxy).getRequestContext();
         ctx.put(SecurityConstants.CALLBACK_HANDLER, new ActAsCallbackHandler());

         ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource("actasKeystore.properties" ));
         ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myactaskey" );
         ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource("../../META-INF/clientKeystore.properties" ));
         ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myservicekey");

         STSClient stsClient = new STSClient(bus);
         Map&lt;String, Object&gt; props = stsClient.getProperties();
         props.put(SecurityConstants.USERNAME, "alice");
         props.put(SecurityConstants.ENCRYPT_USERNAME, "mystskey");
         props.put(SecurityConstants.STS_TOKEN_USERNAME, "myactaskey" );
         props.put(SecurityConstants.STS_TOKEN_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource("actasKeystore.properties" ));
         props.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO, "true");

         ctx.put(SecurityConstants.STS_CLIENT, stsClient);

      } finally {
         bus.shutdown(true);
      }

      return proxy;
   }

}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="actascallbackhandler">ActAsCallbackHandler</h6>
<div class="paragraph">
<p>ActAsCallbackHandler is a callback handler for the WSS4J Crypto API. It
is used to obtain the password for the private key in the keystore. This
class enables CXF to retrieve the password of the user name to use for
the message signature. This class has been revised to return the
passwords for this service, myactaskey and the "actas" user, alice.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.actas;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;
import java.util.HashMap;
import java.util.Map;

public class ActAsCallbackHandler extends PasswordCallbackHandler {

   public ActAsCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("myactaskey", "aspass");
      passwords.put("alice", "clarinet");
      return passwords;
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="usernametokencallbackhandler">UsernameTokenCallbackHandler</h6>
<div class="paragraph">
<p><em>The ActAs and OnBeholdOf sub-elements of the RequestSecurityToken are
required to be defined as WSSE Username Tokens. This utility generates
the properly formated element.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared;

import org.apache.cxf.helpers.DOMUtils;
import org.apache.cxf.message.Message;
import org.apache.cxf.ws.security.SecurityConstants;
import org.apache.cxf.ws.security.trust.delegation.DelegationCallback;
import org.apache.ws.security.WSConstants;
import org.apache.ws.security.message.token.UsernameToken;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.Element;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSSerializer;

import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import java.io.IOException;
import java.util.Map;

/**
* A utility to provide the 3 different input parameter types for jaxws property
* "ws-security.sts.token.act-as" and "ws-security.sts.token.on-behalf-of".
* This implementation obtains a username and password via the jaxws property
* "ws-security.username" and "ws-security.password" respectively, as defined
* in SecurityConstants.  It creates a wss UsernameToken to be used as the
* delegation token.
*/

public class UsernameTokenCallbackHandler implements CallbackHandler {

   public void handle(Callback[] callbacks)
      throws IOException, UnsupportedCallbackException {
      for (int i = 0; i &lt; callbacks.length; i++) {
         if (callbacks[i] instanceof DelegationCallback) {
            DelegationCallback callback = (DelegationCallback) callbacks[i];
            Message message = callback.getCurrentMessage();

            String username =
               (String)message.getContextualProperty(SecurityConstants.USERNAME);
            String password =
               (String)message.getContextualProperty(SecurityConstants.PASSWORD);
            if (username != null) {
               Node contentNode = message.getContent(Node.class);
               Document doc = null;
               if (contentNode != null) {
                  doc = contentNode.getOwnerDocument();
               } else {
                  doc = DOMUtils.createDocument();
               }
               UsernameToken usernameToken = createWSSEUsernameToken(username,password, doc);
               callback.setToken(usernameToken.getElement());
            }
         } else {
            throw new UnsupportedCallbackException(callbacks[i], "Unrecognized Callback");
         }
      }
   }

   /**
    * Provide UsernameToken as a string.
    * @param ctx
    * @return
    */
   public String getUsernameTokenString(Map&lt;String, Object&gt; ctx){
      Document doc = DOMUtils.createDocument();
      String result = null;
      String username = (String)ctx.get(SecurityConstants.USERNAME);
      String password = (String)ctx.get(SecurityConstants.PASSWORD);
      if (username != null) {
         UsernameToken usernameToken = createWSSEUsernameToken(username,password, doc);
         result = toString(usernameToken.getElement().getFirstChild().getParentNode());
      }
      return result;
   }

   /**
    *
    * @param username
    * @param password
    * @return
    */
   public String getUsernameTokenString(String username, String password){
      Document doc = DOMUtils.createDocument();
      String result = null;
      if (username != null) {
         UsernameToken usernameToken = createWSSEUsernameToken(username,password, doc);
         result = toString(usernameToken.getElement().getFirstChild().getParentNode());
      }
      return result;
   }

   /**
    * Provide UsernameToken as a DOM Element.
    * @param ctx
    * @return
    */
   public Element getUsernameTokenElement(Map&lt;String, Object&gt; ctx){
      Document doc = DOMUtils.createDocument();
      Element result = null;
      UsernameToken usernameToken = null;
         String username = (String)ctx.get(SecurityConstants.USERNAME);
      String password = (String)ctx.get(SecurityConstants.PASSWORD);
      if (username != null) {
         usernameToken = createWSSEUsernameToken(username,password, doc);
         result = usernameToken.getElement();
      }
      return result;
   }

   /**
    *
    * @param username
    * @param password
    * @return
    */
   public Element getUsernameTokenElement(String username, String password){
      Document doc = DOMUtils.createDocument();
      Element result = null;
      UsernameToken usernameToken = null;
      if (username != null) {
         usernameToken = createWSSEUsernameToken(username,password, doc);
         result = usernameToken.getElement();
      }
      return result;
   }

   private UsernameToken createWSSEUsernameToken(String username, String password, Document doc) {

      UsernameToken usernameToken = new UsernameToken(true, doc,
         (password == null)? null: WSConstants.PASSWORD_TEXT);
      usernameToken.setName(username);
      usernameToken.addWSUNamespace();
      usernameToken.addWSSENamespace();
      usernameToken.setID("id-" + username);

      if (password != null){
         usernameToken.setPassword(password);
      }

      return usernameToken;
   }


   private String toString(Node node) {
      String str = null;

      if (node != null) {
         DOMImplementationLS lsImpl = (DOMImplementationLS)
            node.getOwnerDocument().getImplementation().getFeature("LS", "3.0");
         LSSerializer serializer = lsImpl.createLSSerializer();
         serializer.getDomConfig().setParameter("xml-declaration", false); //by default its true, so set it to false to get String without xml-declaration
         str = serializer.writeToString(node);
      }
      return str;
   }

}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="crypto-properties-and-keystore-files-3">Crypto properties and keystore files</h6>
<div class="paragraph">
<p><em>The ActAs service must provide its own credentials. The requisite
properties file, actasKeystore.properties, and keystore, actasstore.jks,
were created.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=aapass
org.apache.ws.security.crypto.merlin.keystore.alias=myactaskey
org.apache.ws.security.crypto.merlin.keystore.file=actasstore.jks</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="manifest-mf-3">MANIFEST.MF</h6>
<div class="paragraph">
<p><em>When deployed on WildFly this application requires access to the
JBossWS and Apache CXF APIs provided in modules
org.jboss.ws.cxf.jbossws-cxf-client. The org.jboss.ws.cxf.sts module is
also needed in handling the ActAs and OnBehalfOf extensions. The
dependency statement directs the server to provide them at deployment.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version: 1.0
Ant-Version: Apache Ant 1.8.2
Created-By: 1.7.0_25-b15 (Oracle Corporation)
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client, org.jboss.ws.cxf.sts</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="security-token-service-2">Security Token Service</h5>
<div class="paragraph">
<p>This section examines the STS elements from the basic WS-Trust scenario
that have been changed to address the needs of the ActAs example. The
components are.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>STS&#8217;s implementation class.</p>
</li>
<li>
<p>STSCallbackHandler class</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="sts-implementation-class">STS Implementation class</h6>
<div class="paragraph">
<p>The initial description of SampleSTS can be found
<a href="#_actas_ws_trust_scenario">[_actas_ws_trust_scenario]</a></p>
</div>
<div class="paragraph">
<p>The declaration of the set of allowed token recipients by address has
been extended to accept ActAs addresses and OnBehalfOf addresses. The
addresses are specified as reg-ex patterns.</p>
</div>
<div class="paragraph">
<p>The TokenIssueOperation requires class, UsernameTokenValidator be
provided in order to validate the contents of the OnBehalfOf claims and
class, UsernameTokenDelegationHandler to be provided in order to process
the token delegation request of the ActAs on OnBehalfOf user.</p>
</div>
<div class="literalblock">
<div class="content">
<pre> package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.sts;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

import jakarta.xml.ws.WebServiceProvider;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.interceptor.InInterceptors;
import org.apache.cxf.sts.StaticSTSProperties;
import org.apache.cxf.sts.operation.TokenIssueOperation;
import org.apache.cxf.sts.operation.TokenValidateOperation;
import org.apache.cxf.sts.service.ServiceMBean;
import org.apache.cxf.sts.service.StaticService;
import org.apache.cxf.sts.token.delegation.UsernameTokenDelegationHandler;
import org.apache.cxf.sts.token.provider.SAMLTokenProvider;
import org.apache.cxf.sts.token.validator.SAMLTokenValidator;
import org.apache.cxf.sts.token.validator.UsernameTokenValidator;
import org.apache.cxf.ws.security.sts.provider.SecurityTokenServiceProvider;

@WebServiceProvider(serviceName = "SecurityTokenService",
      portName = "UT_Port",
      targetNamespace = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/",
      wsdlLocation = "WEB-INF/wsdl/ws-trust-1.4-service.wsdl")
//be sure to have dependency on org.apache.cxf module when on AS7, otherwise Apache CXF annotations are ignored
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "mystskey"),
      @EndpointProperty(key = "ws-security.signature.properties", value = "stsKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.sts.STSCallbackHandler"),
      @EndpointProperty(key = "ws-security.validate.token", value = "false") //to let the JAAS integration deal with validation through the interceptor below
})
@InInterceptors(interceptors = {"org.jboss.wsf.stack.cxf.security.authentication.SubjectCreatingPolicyInterceptor"})
public class SampleSTS extends SecurityTokenServiceProvider
{
   public SampleSTS() throws Exception
   {
      super();

      StaticSTSProperties props = new StaticSTSProperties();
      props.setSignatureCryptoProperties("stsKeystore.properties");
      props.setSignatureUsername("mystskey");
      props.setCallbackHandlerClass(STSCallbackHandler.class.getName());
      props.setIssuer("DoubleItSTSIssuer");

      List&lt;ServiceMBean&gt; services = new LinkedList&lt;ServiceMBean&gt;();
      StaticService service = new StaticService();
      service.setEndpoints(Arrays.asList(
         "http://localhost:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService",
         "http://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService",
         "http://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust/SecurityService",

         "http://localhost:(\\d)*/jaxws-samples-wsse-policy-trust-actas/ActAsService",
         "http://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-actas/ActAsService",
         "http://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-actas/ActAsService",

         "http://localhost:(\\d)*/jaxws-samples-wsse-policy-trust-onbehalfof/OnBehalfOfService",
         "http://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-onbehalfof/OnBehalfOfService",
         "http://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-onbehalfof/OnBehalfOfService"
      ));
      services.add(service);

      TokenIssueOperation issueOperation = new TokenIssueOperation();
      issueOperation.setServices(services);
      issueOperation.getTokenProviders().add(new SAMLTokenProvider());
      // required for OnBehalfOf
      issueOperation.getTokenValidators().add(new UsernameTokenValidator());
      // added for OnBehalfOf and ActAs
      issueOperation.getDelegationHandlers().add(new UsernameTokenDelegationHandler());
      issueOperation.setStsProperties(props);

      TokenValidateOperation validateOperation = new TokenValidateOperation();
      validateOperation.getTokenValidators().add(new SAMLTokenValidator());
      validateOperation.setStsProperties(props);

      this.setIssueOperation(issueOperation);
      this.setValidateOperation(validateOperation);
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="stscallbackhandler-2">STSCallbackHandler</h6>
<div class="paragraph">
<p>The user, alice, and corresponding password was required to be added for
the ActAs example.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.sts;

import java.util.HashMap;
import java.util.Map;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;

public class STSCallbackHandler extends PasswordCallbackHandler
{
   public STSCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("mystskey", "stskpass");
      passwords.put("alice", "clarinet");
      return passwords;
   }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="web-service-requester-2">Web service requester</h5>
<div class="paragraph">
<p>This section examines the ws-requester elements from the basic WS-Trust
scenario that have been changed to address the needs of the ActAs
example. The component is</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ActAs web service requester implementation class</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="web-service-requester-implementation-2">Web service requester Implementation</h6>
<div class="paragraph">
<p>The ActAs ws-requester, the client, uses standard procedures for
creating a reference to the web service in the first four lines. To
address the endpoint security requirements, the web service&#8217;s "Request
Context" is configured via the BindingProvider. Information needed in
the message generation is provided through it. The ActAs user,
myactaskey, is declared in this section and UsernameTokenCallbackHandler
is used to provide the contents of the ActAs element to the STSClient.
In this example a STSClient object is created and provided to the
proxy&#8217;s request context. The alternative is to provide keys tagged with
the ".it" suffix as was done in
<a href="https://docs.jboss.org/author/display/JBWS/WS-Trust+and+STS#WS-TrustandSTS-WebservicerequesterImplementation">the
Basic Scenario client</a> . The use of ActAs is configured through the
props map using the SecurityConstants.STS_TOKEN_ACT_AS key. The
alternative is to use the STSClient.setActAs method.</p>
</div>
<div class="literalblock">
<div class="content">
<pre> final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/actaswssecuritypolicy", "ActAsService");
final URL wsdlURL = new URL(serviceURL + "?wsdl");
Service service = Service.create(wsdlURL, serviceName);
ActAsServiceIface proxy = (ActAsServiceIface) service.getPort(ActAsServiceIface.class);

Bus bus = BusFactory.newInstance().createBus();
try {
    BusFactory.setThreadDefaultBus(bus);

    Map&lt;String, Object&gt; ctx = proxy.getRequestContext();

    ctx.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
    ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myactaskey");
    ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myclientkey");

    // Generate the ActAs element contents and pass to the STSClient as a string
    UsernameTokenCallbackHandler ch = new UsernameTokenCallbackHandler();
    String str = ch.getUsernameTokenString("alice","clarinet");
    ctx.put(SecurityConstants.STS_TOKEN_ACT_AS, str);

    STSClient stsClient = new STSClient(bus);
    Map&lt;String, Object&gt; props = stsClient.getProperties();
    props.put(SecurityConstants.USERNAME, "bob");
    props.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
    props.put(SecurityConstants.ENCRYPT_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    props.put(SecurityConstants.ENCRYPT_USERNAME, "mystskey");
    props.put(SecurityConstants.STS_TOKEN_USERNAME, "myclientkey");
    props.put(SecurityConstants.STS_TOKEN_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    props.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO, "true");

    ctx.put(SecurityConstants.STS_CLIENT, stsClient);
} finally {
    bus.shutdown(true);
}
proxy.sayHello();</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="onbehalfof-ws-trust-scenario">5.13.6. OnBehalfOf WS-Trust Scenario</h4>
<div class="paragraph">
<p>The OnBehalfOf feature is used in scenarios that use the proxy pattern.
In such scenarios, the client cannot access the STS directly, instead it
communicates through a proxy gateway. The proxy gateway authenticates
the caller and puts information about the caller into the OnBehalfOf
element of the RequestSecurityToken (RST) sent to the real STS for
processing. The resulting token contains only claims related to the
client of the proxy, making the proxy completely transparent to the
receiver of the issued token.</p>
</div>
<div class="paragraph">
<p>OnBehalfOf is nothing more than a new sub-element in the RST. It
provides additional information about the original caller when a token
is negotiated with the STS. The OnBehalfOf element usually takes the
form of a token with identity claims such as name, role, and
authorization code, for the client to access the service.</p>
</div>
<div class="paragraph">
<p>The OnBehalfOf scenario is an extension of <a href="#a-basic-ws-trust-scenario">A Basic WS-Trust Scenario</a> . In this example the OnBehalfOf service calls the
ws-service on behalf of a user. There are only a couple of additions to
the basic scenario&#8217;s code. An OnBehalfOf web service provider and
callback handler have been added. The OnBehalfOf web services' WSDL
imposes the same security policies as the ws-provider.
UsernameTokenCallbackHandler is a utility shared with ActAs. It
generates the content for the OnBehalfOf element. Lastly there are
code additions in the STS that both OnBehalfOf and ActAs share in
common.</p>
</div>
<div class="paragraph">
<p>Infor here [
<a href="http://coheigea.blogspot.it/2012/01/apache-cxf-251-sts-updates.html">Open
Source Security: Apache CXF 2.5.1 STS updates</a> ]</p>
</div>
<div class="sect4">
<h5 id="web-service-provider-3">Web service provider</h5>
<div class="paragraph">
<p>This section examines the web service elements from the basic WS-Trust
scenario that have been changed to address the needs of the OnBehalfOf
example. The components are.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>web service provider&#8217;s WSDL</p>
</li>
<li>
<p>web service provider&#8217;s Interface and Implementation classes.</p>
</li>
<li>
<p>OnBehalfOfCallbackHandler class</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="web-service-provider-wsdl-3">Web service provider WSDL</h6>
<div class="paragraph">
<p>The OnBehalfOf web service provider&#8217;s WSDL is a clone of the
ws-provider&#8217;s WSDL. The wsp:Policy section is the same. There are
changes to the service endpoint, targetNamespace, portType, binding
name, and service.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy" name="OnBehalfOfService"
             xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
             xmlns:wsp="http://www.w3.org/ns/ws-policy"
             xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"
             xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
             xmlns:wsaws="http://www.w3.org/2005/08/addressing"
             xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"
             xmlns:t="http://docs.oasis-open.org/ws-sx/ws-trust/200512"&gt;
    &lt;types&gt;
        &lt;xsd:schema&gt;
            &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy"
                  schemaLocation="OnBehalfOfService_schema1.xsd"/&gt;
        &lt;/xsd:schema&gt;
    &lt;/types&gt;
    &lt;message name="sayHello"&gt;
        &lt;part name="parameters" element="tns:sayHello"/&gt;
    &lt;/message&gt;
    &lt;message name="sayHelloResponse"&gt;
        &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
    &lt;/message&gt;
    &lt;portType name="OnBehalfOfServiceIface"&gt;
        &lt;operation name="sayHello"&gt;
            &lt;input message="tns:sayHello"/&gt;
            &lt;output message="tns:sayHelloResponse"/&gt;
        &lt;/operation&gt;
    &lt;/portType&gt;
    &lt;binding name="OnBehalfOfServicePortBinding" type="tns:OnBehalfOfServiceIface"&gt;
        &lt;wsp:PolicyReference URI="#AsymmetricSAML2Policy" /&gt;
        &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
        &lt;operation name="sayHello"&gt;
            &lt;soap:operation soapAction=""/&gt;
            &lt;input&gt;
                &lt;soap:body use="literal"/&gt;
                &lt;wsp:PolicyReference URI="#Input_Policy" /&gt;
            &lt;/input&gt;
            &lt;output&gt;
                &lt;soap:body use="literal"/&gt;
                &lt;wsp:PolicyReference URI="#Output_Policy" /&gt;
            &lt;/output&gt;
        &lt;/operation&gt;
    &lt;/binding&gt;
    &lt;service name="OnBehalfOfService"&gt;
        &lt;port name="OnBehalfOfServicePort" binding="tns:OnBehalfOfServicePortBinding"&gt;
            &lt;soap:address location="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-onbehalfof/OnBehalfOfService"/&gt;
        &lt;/port&gt;
    &lt;/service&gt;
&lt;/definitions&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="web-service-interface-2">Web Service Interface</h6>
<div class="paragraph">
<p>The web service provider interface class, OnBehalfOfServiceIface, is a
simple web service definition.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.onbehalfof;

import jakarta.jws.WebMethod;
import jakarta.jws.WebService;

@WebService
(
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy"
)
public interface OnBehalfOfServiceIface
{
   @WebMethod
   String sayHello();
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="web-service-implementation-2">Web Service Implementation</h6>
<div class="paragraph">
<p>The web service provider implementation class, OnBehalfOfServiceImpl, is
a POJO. It uses the standard WebService annotation to define the
service endpoint and two Apache WSS4J annotations, EndpointProperties
and EndpointProperty used for configuring the endpoint for the CXF
runtime. The WSS4J configuration information provided is for WSS4J&#8217;s
Crypto Merlin implementation.</p>
</div>
<div class="paragraph">
<p>OnBehalfOfServiceImpl is calling the ServiceImpl acting on behalf of the
user. Method setupService performs the requisite configuration setup.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.onbehalfof;

import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.ws.security.SecurityConstants;
import org.apache.cxf.ws.security.trust.STSClient;
import org.jboss.test.ws.jaxws.samples.wsse.policy.trust.service.ServiceIface;
import org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared.WSTrustAppUtils;

import jakarta.jws.WebService;
import javax.xml.namespace.QName;
import jakarta.xml.ws.BindingProvider;
import jakarta.xml.ws.Service;
import java.net.*;
import java.util.Map;

@WebService
(
   portName = "OnBehalfOfServicePort",
   serviceName = "OnBehalfOfService",
   wsdlLocation = "WEB-INF/wsdl/OnBehalfOfService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.onbehalfof.OnBehalfOfServiceIface"
)

@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "myactaskey"),
      @EndpointProperty(key = "ws-security.signature.properties", value =  "actasKeystore.properties"),
      @EndpointProperty(key = "ws-security.encryption.properties", value = "actasKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.onbehalfof.OnBehalfOfCallbackHandler")
})

public class OnBehalfOfServiceImpl implements OnBehalfOfServiceIface
{
   public String sayHello() {
      try {

         ServiceIface proxy = setupService();
         return "OnBehalfOf " + proxy.sayHello();

      } catch (MalformedURLException e) {
         e.printStackTrace();
      }
      return null;
   }

   /**
    *
    * @return
    * @throws MalformedURLException
    */
   private  ServiceIface setupService()throws MalformedURLException {
      ServiceIface proxy = null;
      Bus bus = BusFactory.newInstance().createBus();

      try {
         BusFactory.setThreadDefaultBus(bus);

         final String serviceURL = "http://" + WSTrustAppUtils.getServerHost() + ":8080/jaxws-samples-wsse-policy-trust/SecurityService";
         final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wssecuritypolicy", "SecurityService");
         final URL wsdlURL = new URL(serviceURL + "?wsdl");
         Service service = Service.create(wsdlURL, serviceName);
         proxy = (ServiceIface) service.getPort(ServiceIface.class);

         Map&lt;String, Object&gt; ctx = ((BindingProvider) proxy).getRequestContext();
         ctx.put(SecurityConstants.CALLBACK_HANDLER, new OnBehalfOfCallbackHandler());

         ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource(
            "actasKeystore.properties" ));
         ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myactaskey" );
         ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource(
            "../../META-INF/clientKeystore.properties" ));
         ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myservicekey");

         STSClient stsClient = new STSClient(bus);
         Map&lt;String, Object&gt; props = stsClient.getProperties();
         props.put(SecurityConstants.USERNAME, "bob");
         props.put(SecurityConstants.ENCRYPT_USERNAME, "mystskey");
         props.put(SecurityConstants.STS_TOKEN_USERNAME, "myactaskey" );
         props.put(SecurityConstants.STS_TOKEN_PROPERTIES,
            Thread.currentThread().getContextClassLoader().getResource(
            "actasKeystore.properties" ));
         props.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO, "true");

         ctx.put(SecurityConstants.STS_CLIENT, stsClient);

      } finally {
         bus.shutdown(true);
      }

      return proxy;
   }

}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="onbehalfofcallbackhandler">OnBehalfOfCallbackHandler</h6>
<div class="paragraph">
<p>OnBehalfOfCallbackHandler is a callback handler for the WSS4J Crypto
API. It is used to obtain the password for the private key in the
keystore. This class enables CXF to retrieve the password of the user
name to use for the message signature. This class has been revised to
return the passwords for this service, myactaskey and the "OnBehalfOf"
user, alice.</p>
</div>
<div class="literalblock">
<div class="content">
<pre> package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.onbehalfof;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;
import java.util.HashMap;
import java.util.Map;

public class OnBehalfOfCallbackHandler extends PasswordCallbackHandler {

   public OnBehalfOfCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("myactaskey", "aspass");
      passwords.put("alice", "clarinet");
      passwords.put("bob", "trombone");
      return passwords;
   }

}</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="web-service-requester-3">Web service requester</h5>
<div class="paragraph">
<p>This section examines the ws-requester elements from the basic WS-Trust
scenario that have been changed to address the needs of the OnBehalfOf
example. The component is</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OnBehalfOf web service requester implementation class</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="web-service-requester-implementation-3">Web service requester Implementation</h6>
<div class="paragraph">
<p>The OnBehalfOf ws-requester, the client, uses standard procedures for
creating a reference to the web service in the first four lines. To
address the endpoint security requirements, the web service&#8217;s "Request
Context" is configured via the BindingProvider. Information needed in
the message generation is provided through it. The OnBehalfOf user,
alice, is declared in this section and the callbackHandler,
UsernameTokenCallbackHandler is provided to the STSClient for generation
of the contents for the OnBehalfOf message element. In this example a
STSClient object is created and provided to the proxy&#8217;s request context.
The alternative is to provide keys tagged with the ".it" suffix as was
done in the Basic Scenario client. The use of OnBehalfOf is configured by the
method call stsClient.setOnBehalfOf. The alternative is to use the key
SecurityConstants.STS_TOKEN_ON_BEHALF_OF and a value in the props map.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/onbehalfofwssecuritypolicy", "OnBehalfOfService");
final URL wsdlURL = new URL(serviceURL + "?wsdl");
Service service = Service.create(wsdlURL, serviceName);
OnBehalfOfServiceI face proxy = (OnBehalfOfServiceIface) service.getPort(OnBehalfOfServiceIface.class);


Bus bus = BusFactory.newInstance().createBus();
try {

    BusFactory.setThreadDefaultBus(bus);

    Map&lt;String, Object&gt; ctx = proxy.getRequestContext();

    ctx.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
    ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myactaskey");
    ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myclientkey");

    // user and password OnBehalfOf user
    // UsernameTokenCallbackHandler will extract this information when called
    ctx.put(SecurityConstants.USERNAME,"alice");
    ctx.put(SecurityConstants.PASSWORD, "clarinet");

    STSClient stsClient = new STSClient(bus);

    // Providing the STSClient the mechanism to create the claims contents for OnBehalfOf
    stsClient.setOnBehalfOf(new UsernameTokenCallbackHandler());

    Map&lt;String, Object&gt; props = stsClient.getProperties();
    props.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
    props.put(SecurityConstants.ENCRYPT_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    props.put(SecurityConstants.ENCRYPT_USERNAME, "mystskey");
    props.put(SecurityConstants.STS_TOKEN_USERNAME, "myclientkey");
    props.put(SecurityConstants.STS_TOKEN_PROPERTIES,
        Thread.currentThread().getContextClassLoader().getResource(
        "META-INF/clientKeystore.properties"));
    props.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO, "true");

    ctx.put(SecurityConstants.STS_CLIENT, stsClient);

} finally {
    bus.shutdown(true);
}
proxy.sayHello();</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="saml-bearer-assertion-scenario">5.13.7. SAML Bearer Assertion Scenario</h4>
<div class="paragraph">
<p>WS-Trust deals with managing software security tokens. A SAML assertion
is a type of security token. In the SAML Bearer scenario, the service
provider automatically trusts that the incoming SOAP request came from
the subject defined in the SAML token after the service verifies the
tokens signature.</p>
</div>
<div class="paragraph">
<p>Implementation of this scenario has the following requirements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SAML tokens with a Bearer subject confirmation method must be
protected so the token can not be snooped. In most cases, a bearer token
combined with HTTPS is sufficient to prevent "a man in the middle"
getting possession of the token. This means a security policy that uses
a sp:TransportBinding and sp:HttpsToken.</p>
</li>
<li>
<p>A bearer token has no encryption or signing keys associated with it,
therefore a sp:IssuedToken of bearer keyType should be used with a
sp:SupportingToken or a sp:SignedSupportingTokens.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="web-service-provider-4">Web service Provider</h5>
<div class="paragraph">
<p>This section examines the web service elements for the SAML Bearer
scenario. The components are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bearer web service provider&#8217;s WSDL</p>
</li>
<li>
<p>SSL configuration</p>
</li>
<li>
<p>Bearer web service provider&#8217;s Interface and Implementation classes.</p>
</li>
<li>
<p>Crypto properties and keystore files</p>
</li>
<li>
<p>MANIFEST.MF</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="web-service-provider-wsdl-4">Web service provider WSDL</h6>
<div class="paragraph">
<p>The web service provider is a contract-first endpoint. All the WS-trust
and security policies for it are declared in WSDL, BearerService.wsdl.
For this scenario a ws-requester is required to present a SAML 2.0
Bearer token issued from a designed STS. The address of the STS is
provided in the WSDL. HTTPS, a TransportBinding and HttpsToken policy
are used to protect the SOAP body of messages that pass back and forth
between ws-requester and ws-provider. A detailed explanation of the
security settings are provided in the comments in the listing below.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy"
             name="BearerService"
             xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
             xmlns:wsp="http://www.w3.org/ns/ws-policy"
             xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"
             xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
             xmlns:wsaws="http://www.w3.org/2005/08/addressing"
             xmlns:wsx="http://schemas.xmlsoap.org/ws/2004/09/mex"
             xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"
             xmlns:t="http://docs.oasis-open.org/ws-sx/ws-trust/200512"&gt;

  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy"
                  schemaLocation="BearerService_schema1.xsd"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="sayHello"&gt;
    &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;
  &lt;message name="sayHelloResponse"&gt;
    &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;
  &lt;portType name="BearerIface"&gt;
    &lt;operation name="sayHello"&gt;
      &lt;input message="tns:sayHello"/&gt;
      &lt;output message="tns:sayHelloResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;

&lt;!--
        The wsp:PolicyReference binds the security requirments on all the endpoints.
        The wsp:Policy wsu:Id="#TransportSAML2BearerPolicy" element is defined later in this file.
--&gt;
  &lt;binding name="BearerServicePortBinding" type="tns:BearerIface"&gt;
    &lt;wsp:PolicyReference URI="#TransportSAML2BearerPolicy" /&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="sayHello"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;

&lt;!--
  The soap:address has been defined to use JBoss's https port, 8443.  This is
  set in conjunction with the sp:TransportBinding policy for https.
--&gt;
  &lt;service name="BearerService"&gt;
    &lt;port name="BearerServicePort" binding="tns:BearerServicePortBinding"&gt;
      &lt;soap:address location="https://@jboss.bind.address@:8443/jaxws-samples-wsse-policy-trust-bearer/BearerService"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;


  &lt;wsp:Policy wsu:Id="TransportSAML2BearerPolicy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
  &lt;!--
        The wsam:Addressing element, indicates that the endpoints of this
        web service MUST conform to the WS-Addressing specification.  The
        attribute wsp:Optional="false" enforces this assertion.
  --&gt;
        &lt;wsam:Addressing wsp:Optional="false"&gt;
          &lt;wsp:Policy /&gt;
        &lt;/wsam:Addressing&gt;

&lt;!--
  The sp:TransportBinding element indicates that security is provided by the
  message exchange transport medium, https.  WS-Security policy specification
  defines the sp:HttpsToken for use in exchanging messages transmitted over HTTPS.
--&gt;
        &lt;sp:TransportBinding
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:TransportToken&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:HttpsToken&gt;
                  &lt;wsp:Policy/&gt;
                &lt;/sp:HttpsToken&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:TransportToken&gt;
&lt;!--
     The sp:AlgorithmSuite element, requires the TripleDes algorithm suite
     be used in performing cryptographic operations.
--&gt;
            &lt;sp:AlgorithmSuite&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:TripleDes /&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:AlgorithmSuite&gt;
&lt;!--
     The sp:Layout element,  indicates the layout rules to apply when adding
     items to the security header.  The sp:Lax sub-element indicates items
     are added to the security header in any order that conforms to
     WSS: SOAP Message Security.
--&gt;
            &lt;sp:Layout&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Lax /&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:Layout&gt;
            &lt;sp:IncludeTimestamp /&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:TransportBinding&gt;

&lt;!--
  The sp:SignedSupportingTokens element causes the supporting tokens
  to be signed using the primary token that is used to sign the message.
--&gt;
        &lt;sp:SignedSupportingTokens
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
&lt;!--
  The sp:IssuedToken element asserts that a SAML 2.0 security token of type
  Bearer is expected from the STS.  The
  sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
  attribute instructs the runtime to include the initiator's public key
  with every message sent to the recipient.

  The sp:RequestSecurityTokenTemplate element directs that all of the
  children of this element will be copied directly into the body of the
  RequestSecurityToken (RST) message that is sent to the STS when the
  initiator asks the STS to issue a token.
--&gt;
            &lt;sp:IssuedToken
              sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
              &lt;sp:RequestSecurityTokenTemplate&gt;
                &lt;t:TokenType&gt;http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0&lt;/t:TokenType&gt;
                &lt;t:KeyType&gt;http://docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer&lt;/t:KeyType&gt;
              &lt;/sp:RequestSecurityTokenTemplate&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:RequireInternalReference /&gt;
              &lt;/wsp:Policy&gt;
&lt;!--
  The sp:Issuer element defines the STS's address and endpoint information
  This information is used by the STSClient.
--&gt;
              &lt;sp:Issuer&gt;
                &lt;wsaws:Address&gt;http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts-bearer/SecurityTokenService&lt;/wsaws:Address&gt;
                &lt;wsaws:Metadata
                  xmlns:wsdli="http://www.w3.org/2006/01/wsdl-instance"
                  wsdli:wsdlLocation="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts-bearer/SecurityTokenService?wsdl"&gt;
                  &lt;wsaw:ServiceName
                    xmlns:wsaw="http://www.w3.org/2006/05/addressing/wsdl"
                    xmlns:stsns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
                    EndpointName="UT_Port"&gt;stsns:SecurityTokenService&lt;/wsaw:ServiceName&gt;
                &lt;/wsaws:Metadata&gt;
              &lt;/sp:Issuer&gt;

            &lt;/sp:IssuedToken&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SignedSupportingTokens&gt;
&lt;!--
    The sp:Wss11 element declares WSS: SOAP Message Security 1.1 options
    to be supported by the STS.  These particular elements generally refer
    to how keys are referenced within the SOAP envelope.  These are normally
    handled by CXF.
--&gt;
        &lt;sp:Wss11&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportRefIssuerSerial /&gt;
            &lt;sp:MustSupportRefThumbprint /&gt;
            &lt;sp:MustSupportRefEncryptedKey /&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Wss11&gt;
&lt;!--
    The sp:Trust13 element declares controls for WS-Trust 1.3 options.
    They are policy assertions related to exchanges specifically with
    client and server challenges and entropy behaviors.  Again these are
    normally handled by CXF.
--&gt;
        &lt;sp:Trust13&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportIssuedTokens /&gt;
            &lt;sp:RequireClientEntropy /&gt;
            &lt;sp:RequireServerEntropy /&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Trust13&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

&lt;/definitions&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="ssl-configuration">SSL configuration</h6>
<div class="paragraph">
<p>This web service is using https, therefore the JBoss server must be
configured to provide SSL support in the Web subsystem. There are 2
components to SSL configuration.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>create a certificate keystore</p>
</li>
<li>
<p>declare an SSL connector in the Web subsystem of the JBoss server
configuration file.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Follow the directions this section in the
<a href="https://docs.wildfly.org/26.1/WildFly_Elytron_Security.html#configure-ssltls">Configure SSL/TLS</a> .</p>
</div>
<div class="paragraph">
<p>Here is an example of an SSL connector declaration.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;subsystem xmlns="urn:jboss:domain:web:1.4" default-virtual-server="default-host" native="false"&gt;
  .....
  &lt;connector name="jbws-https-connector" protocol="HTTP/1.1" scheme="https" socket-binding="https" secure="true" enabled="true"&gt;
    &lt;ssl key-alias="tomcat" password="changeit" certificate-key-file="/myJbossHome/security/test.keystore" verify-client="false"/&gt;
  &lt;/connector&gt;
  ...</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="web-service-interface-3">Web service Interface</h6>
<div class="paragraph">
<p>The web service provider interface class, BearerIface, is a simple
straight forward web service definition.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.bearer;

import jakarta.jws.WebMethod;
import jakarta.jws.WebService;

@WebService
(
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy"
)
public interface BearerIface
{
   @WebMethod
   String sayHello();
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="web-service-implementation-3">Web service Implementation</h6>
<div class="paragraph">
<p>The web service provider implementation class, BearerImpl, is a
POJO. It uses the standard WebService annotation to define the service
endpoint. There are two Apache CXF annotations,
EndpointProperties and EndpointProperty used for configuring the
endpoint for the CXF runtime. These annotations come from the
<a href="https://ws.apache.org/wss4j/">Apache WSS4J project</a> , which provides a
Java implementation of the primary WS-Security standards for Web
Services. These annotations are programmatically adding properties to
the endpoint. With plain Apache CXF, these properties are often set via
the &lt;jaxws:properties&gt; element on the &lt;jaxws:endpoint&gt; element in the
Spring config; these annotations allow the properties to be configured
in the code.</p>
</div>
<div class="paragraph">
<p>WSS4J uses the Crypto interface to get keys and certificates for
signature creation/verification, as is asserted by the WSDL for this
service. The WSS4J configuration information being provided by
BearerImpl is for Crypto&#8217;s Merlin implementation. More information will
be provided about this in the keystore section.</p>
</div>
<div class="paragraph">
<p>Because the web service provider automatically trusts that the incoming
SOAP request came from the subject defined in the SAML token there is no
need for a Crypto callbackHandler class or a signature username, unlike
in prior examples, however in order to verify the message signature, the
Java properties file that contains the (Merlin) crypto configuration
information is still required.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.bearer;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;

import jakarta.jws.WebService;

@WebService
(
   portName = "BearerServicePort",
   serviceName = "BearerService",
   wsdlLocation = "WEB-INF/wsdl/BearerService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy",
   endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.bearer.BearerIface"
)
@EndpointProperties(value = {
   @EndpointProperty(key = "ws-security.signature.properties", value = "serviceKeystore.properties")
})
public class BearerImpl implements BearerIface
{
   public String sayHello()
   {
      return "Bearer WS-Trust Hello World!";
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="crypto-properties-and-keystore-files-4">Crypto properties and keystore files</h6>
<div class="paragraph">
<p>WSS4J&#8217;s Crypto implementation is loaded and configured via a Java
properties file that contains Crypto configuration data. The file
contains implementation-specific properties such as a keystore location,
password, default alias and the like. This application is using the
Merlin implementation. File serviceKeystore.properties contains this
information.</p>
</div>
<div class="paragraph">
<p>File servicestore.jks, is a Java KeyStore (JKS) repository. It contains
self signed certificates for myservicekey and mystskey. <em>Self signed
certificates are not appropriate for production use.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=sspass
org.apache.ws.security.crypto.merlin.keystore.alias=myservicekey
org.apache.ws.security.crypto.merlin.keystore.file=servicestore.jks</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="manifest-mf-4">MANIFEST.MF</h6>
<div class="paragraph">
<p>When deployed on WildFly this application requires access to the JBossWs
and CXF APIs provided in module org.jboss.ws.cxf.jbossws-cxf-client. The
dependency statement directs the server to provide them at deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version: 1.0  
Ant-Version: Apache Ant 1.8.2  
Created-By: 1.7.0_25-b15 (Oracle Corporation)  
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="bearer-security-token-service">Bearer Security Token Service</h5>
<div class="paragraph">
<p>This section examines the crucial elements in providing the Security
Token Service functionality for providing a SAML Bearer token. The
components that will be discussed are.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Security Domain</p>
</li>
<li>
<p>STS&#8217;s WSDL</p>
</li>
<li>
<p>STS&#8217;s implementation class</p>
</li>
<li>
<p>STSBearerCallbackHandler</p>
</li>
<li>
<p>Crypto properties and keystore files</p>
</li>
<li>
<p>MANIFEST.MF</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="security-domain-2">Security Domain</h6>
<div class="paragraph">
<p>The STS requires a JBoss security domain be configured. The
jboss-web.xml descriptor declares a named security
domain,"JBossWS-trust-sts" to be used by this service for
authentication. This security domain requires two properties files and
the addition of a security-domain declaration in the JBoss server
configuration file.</p>
</div>
<div class="paragraph">
<p>For this scenario the domain needs to contain user <em>alice</em> , password
<em>clarinet</em> , and role <em>friend</em> . See the listings below for
jbossws-users.properties and jbossws-roles.properties. The
following XML must be added to the JBoss security subsystem in the
server configuration file. Replace " <strong>SOME_PATH</strong> " with appropriate
information.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;security-domain name="JBossWS-trust-sts"&gt;
  &lt;authentication&gt;
    &lt;login-module code="UsersRoles" flag="required"&gt;
      &lt;module-option name="usersProperties" value="/SOME_PATH/jbossws-users.properties"/&gt;
      &lt;module-option name="unauthenticatedIdentity" value="anonymous"/&gt;
      &lt;module-option name="rolesProperties" value="/SOME_PATH/jbossws-roles.properties"/&gt;
    &lt;/login-module&gt;
  &lt;/authentication&gt;
&lt;/security-domain&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>jboss-web.xml</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;  
&lt;!DOCTYPE jboss-web PUBLIC "-//JBoss//DTD Web Application 2.4//EN" "&gt;  
&lt;jboss-web&gt;  
  &lt;security-domain&gt;java:/jaas/JBossWS-trust-sts&lt;/security-domain&gt;  
&lt;/jboss-web&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>jbossws-users.properties</p>
</div>
<div class="literalblock">
<div class="content">
<pre># A sample users.properties file for use with the UsersRolesLoginModule  
alice=clarinet</pre>
</div>
</div>
<div class="paragraph">
<p>jbossws-roles.properties</p>
</div>
<div class="literalblock">
<div class="content">
<pre># A sample roles.properties file for use with the UsersRolesLoginModule  
alice=friend</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="stss-wsdl">STS&#8217;s WSDL</h6>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;wsdl:definitions
  targetNamespace="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:tns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:wstrust="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:wsap10="http://www.w3.org/2006/05/addressing/wsdl"
  xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
  xmlns:wsp="http://www.w3.org/ns/ws-policy"
  xmlns:wst="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"&gt;

  &lt;wsdl:types&gt;
    &lt;xs:schema elementFormDefault="qualified"
               targetNamespace='http://docs.oasis-open.org/ws-sx/ws-trust/200512'&gt;

      &lt;xs:element name='RequestSecurityToken'
                  type='wst:AbstractRequestSecurityTokenType'/&gt;
      &lt;xs:element name='RequestSecurityTokenResponse'
                  type='wst:AbstractRequestSecurityTokenType'/&gt;

      &lt;xs:complexType name='AbstractRequestSecurityTokenType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:any namespace='##any' processContents='lax' minOccurs='0'
                  maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name='Context' type='xs:anyURI' use='optional'/&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax'/&gt;
      &lt;/xs:complexType&gt;
      &lt;xs:element name='RequestSecurityTokenCollection'
                  type='wst:RequestSecurityTokenCollectionType'/&gt;
      &lt;xs:complexType name='RequestSecurityTokenCollectionType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element name='RequestSecurityToken'
                      type='wst:AbstractRequestSecurityTokenType' minOccurs='2'
                      maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name='RequestSecurityTokenResponseCollection'
                  type='wst:RequestSecurityTokenResponseCollectionType'/&gt;
      &lt;xs:complexType name='RequestSecurityTokenResponseCollectionType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref='wst:RequestSecurityTokenResponse' minOccurs='1'
                      maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax'/&gt;
      &lt;/xs:complexType&gt;

    &lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;

  &lt;!-- WS-Trust defines the following GEDs --&gt;
  &lt;wsdl:message name="RequestSecurityTokenMsg"&gt;
    &lt;wsdl:part name="request" element="wst:RequestSecurityToken"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseMsg"&gt;
    &lt;wsdl:part name="response"
               element="wst:RequestSecurityTokenResponse"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenCollectionMsg"&gt;
    &lt;wsdl:part name="requestCollection"
               element="wst:RequestSecurityTokenCollection"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseCollectionMsg"&gt;
    &lt;wsdl:part name="responseCollection"
               element="wst:RequestSecurityTokenResponseCollection"/&gt;
  &lt;/wsdl:message&gt;

  &lt;!-- This portType an example of a Requestor (or other) endpoint that
  Accepts SOAP-based challenges from a Security Token Service --&gt;
  &lt;wsdl:portType name="WSSecurityRequestor"&gt;
    &lt;wsdl:operation name="Challenge"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!-- This portType is an example of an STS supporting full protocol --&gt;
  &lt;!--
      The wsdl:portType and data types are XML elements defined by the
      WS_Trust specification.  The wsdl:portType defines the endpoints
      supported in the STS implementation.  This WSDL defines all operations
      that an STS implementation can support.
  --&gt;
  &lt;wsdl:portType name="STS"&gt;
    &lt;wsdl:operation name="Cancel"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/CancelFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Issue"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTRC/IssueFinal"
        message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Renew"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/RenewFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Validate"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/ValidateFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="KeyExchangeToken"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KET"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/KETFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="RequestCollection"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenCollectionMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!-- This portType is an example of an endpoint that accepts
  Unsolicited RequestSecurityTokenResponse messages --&gt;
  &lt;wsdl:portType name="SecurityTokenResponseService"&gt;
    &lt;wsdl:operation name="RequestSecurityTokenResponse"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!--
      The wsp:PolicyReference binds the security requirments on all the STS endpoints.
      The wsp:Policy wsu:Id="UT_policy" element is later in this file.
  --&gt;
  &lt;wsdl:binding name="UT_Binding" type="wstrust:STS"&gt;
    &lt;wsp:PolicyReference URI="#UT_policy"/&gt;
    &lt;soap:binding style="document"
                  transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="Issue"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue"/&gt;
      &lt;wsdl:input&gt;
        &lt;wsp:PolicyReference
          URI="#Input_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;wsp:PolicyReference
          URI="#Output_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Validate"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate"/&gt;
      &lt;wsdl:input&gt;
        &lt;wsp:PolicyReference
          URI="#Input_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;wsp:PolicyReference
          URI="#Output_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Cancel"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Renew"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="KeyExchangeToken"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KeyExchangeToken"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="RequestCollection"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/RequestCollection"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;

  &lt;wsdl:service name="SecurityTokenService"&gt;
    &lt;wsdl:port name="UT_Port" binding="tns:UT_Binding"&gt;
      &lt;soap:address location="http://localhost:8080/SecurityTokenService/UT"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;


  &lt;wsp:Policy wsu:Id="UT_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;!--
            The sp:UsingAddressing element, indicates that the endpoints of this
            web service conforms to the WS-Addressing specification.  More detail
            can be found here: [http://www.w3.org/TR/2006/CR-ws-addr-wsdl-20060529]
        --&gt;
        &lt;wsap10:UsingAddressing/&gt;
        &lt;!--
            The sp:SymmetricBinding element indicates that security is provided
            at the SOAP layer and any initiator must authenticate itself by providing
            WSS UsernameToken credentials.
        --&gt;
        &lt;sp:SymmetricBinding
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;!--
                In a symmetric binding, the keys used for encrypting and signing in both
                directions are derived from a single key, the one specified by the
                sp:ProtectionToken element.  The sp:X509Token sub-element declares this
                key to be a X.509 certificate and the
                IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"
                attribute adds the requirement that the token MUST NOT be included in
                any messages sent between the initiator and the recipient; rather, an
                external reference to the token should be used.  Lastly the WssX509V3Token10
                sub-element declares that the Username token presented by the initiator
                should be compliant with Web Services Security UsernameToken Profile
                1.0 specification. [ http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0.pdf ]
            --&gt;
            &lt;sp:ProtectionToken&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:X509Token
                  sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
                  &lt;wsp:Policy&gt;
                    &lt;sp:RequireDerivedKeys/&gt;
                    &lt;sp:RequireThumbprintReference/&gt;
                    &lt;sp:WssX509V3Token10/&gt;
                  &lt;/wsp:Policy&gt;
                &lt;/sp:X509Token&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:ProtectionToken&gt;
            &lt;!--
                The sp:AlgorithmSuite element, requires the Basic256 algorithm suite
                be used in performing cryptographic operations.
            --&gt;
            &lt;sp:AlgorithmSuite&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Basic256/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:AlgorithmSuite&gt;
            &lt;!--
                The sp:Layout element,  indicates the layout rules to apply when adding
                items to the security header.  The sp:Lax sub-element indicates items
                are added to the security header in any order that conforms to
                WSS: SOAP Message Security.
            --&gt;
            &lt;sp:Layout&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Lax/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:Layout&gt;
            &lt;sp:IncludeTimestamp/&gt;
            &lt;sp:EncryptSignature/&gt;
            &lt;sp:OnlySignEntireHeadersAndBody/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SymmetricBinding&gt;

        &lt;!--
            The sp:SignedSupportingTokens element declares that the security header
            of messages must contain a sp:UsernameToken and the token must be signed.
            The attribute IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"
            on sp:UsernameToken indicates that the token MUST be included in all
            messages sent from initiator to the recipient and that the token MUST
            NOT be included in messages sent from the recipient to the initiator.
            And finally the element sp:WssUsernameToken10 is a policy assertion
            indicating the Username token should be as defined in  Web Services
            Security UsernameToken Profile 1.0
        --&gt;
        &lt;sp:SignedSupportingTokens
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:UsernameToken
              sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:WssUsernameToken10/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:UsernameToken&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SignedSupportingTokens&gt;
        &lt;!--
            The sp:Wss11 element declares WSS: SOAP Message Security 1.1 options
            to be supported by the STS.  These particular elements generally refer
            to how keys are referenced within the SOAP envelope.  These are normally
            handled by CXF.
        --&gt;
        &lt;sp:Wss11
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportRefKeyIdentifier/&gt;
            &lt;sp:MustSupportRefIssuerSerial/&gt;
            &lt;sp:MustSupportRefThumbprint/&gt;
            &lt;sp:MustSupportRefEncryptedKey/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Wss11&gt;
        &lt;!--
            The sp:Trust13 element declares controls for WS-Trust 1.3 options.
            They are policy assertions related to exchanges specifically with
            client and server challenges and entropy behaviors.  Again these are
            normally handled by CXF.
        --&gt;
        &lt;sp:Trust13
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportIssuedTokens/&gt;
            &lt;sp:RequireClientEntropy/&gt;
            &lt;sp:RequireServerEntropy/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Trust13&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

  &lt;wsp:Policy wsu:Id="Input_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;sp:SignedParts
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;sp:Body/&gt;
          &lt;sp:Header Name="To"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="From"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="FaultTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="ReplyTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="MessageID"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="RelatesTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="Action"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
        &lt;/sp:SignedParts&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

  &lt;wsp:Policy wsu:Id="Output_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;sp:SignedParts
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;sp:Body/&gt;
          &lt;sp:Header Name="To"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="From"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="FaultTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="ReplyTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="MessageID"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="RelatesTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="Action"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
        &lt;/sp:SignedParts&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

&lt;/wsdl:definitions&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="stss-implementation-class">STS&#8217;s implementation class</h6>
<div class="paragraph">
<p>The Apache CXF&#8217;s STS, SecurityTokenServiceProvider, is a web service
provider that is compliant with the protocols and functionality defined
by the WS-Trust specification. It has a modular architecture. Many of
its components are configurable or replaceable and there are many
optional features that are enabled by implementing and configuring
plug-ins. Users can customize their own STS by extending from
SecurityTokenServiceProvider and overriding the default settings.
Extensive information about the CXF&#8217;s STS configurable and pluggable
components can be found
<a href="http://coheigea.blogspot.com/2011/11/apache-cxf-sts-documentation-part-viii_10.html">here</a>
.</p>
</div>
<div class="paragraph">
<p>This STS implementation class, SampleSTSBearer, is a POJO that extends
from SecurityTokenServiceProvider. Note that the class is defined with a
WebServiceProvider annotation and not a WebService annotation. This
annotation defines the service as a Provider-based endpoint, meaning it
supports a more messaging-oriented approach to Web services. In
particular, it signals that the exchanged messages will be XML documents
of some type. SecurityTokenServiceProvider is an implementation of the
jakarta.xml.ws.Provider interface. In comparison the WebService annotation
defines a (service endpoint interface) SEI-based endpoint which supports
message exchange via SOAP envelopes.</p>
</div>
<div class="paragraph">
<p>As was done in the BearerImpl class, the WSS4J annotations
EndpointProperties and EndpointProperty are providing endpoint
configuration for the CXF runtime. The first EndpointProperty statement
in the listing is declaring the user&#8217;s name to use for the message
signature. It is used as the alias name in the keystore to get the
user&#8217;s cert and private key for signature. The next two EndpointProperty
statements declares the Java properties file that contains the (Merlin)
crypto configuration information. In this case both for signing and
encrypting the messages. WSS4J reads this file and extra required
information for message handling. The last EndpointProperty statement
declares the STSBearerCallbackHandler implementation class. It is used
to obtain the user&#8217;s password for the certificates in the keystore file.</p>
</div>
<div class="paragraph">
<p>In this implementation we are customizing the operations of token
issuance, token validation and their static properties.</p>
</div>
<div class="paragraph">
<p>StaticSTSProperties is used to set select properties for configuring
resources in the STS. You may think this is a duplication of the
settings made with the WSS4J annotations. The values are the same but
the underlying structures being set are different, thus this
information must be declared in both places.</p>
</div>
<div class="paragraph">
<p>The setIssuer setting is important because it uniquely identifies the
issuing STS. The issuer string is embedded in issued tokens and, when
validating tokens, the STS checks the issuer string value. Consequently,
it is important to use the issuer string in a consistent way, so that
the STS can recognize the tokens that it has issued.</p>
</div>
<div class="paragraph">
<p>The setEndpoints call allows the declaration of a set of allowed token
recipients by address. The addresses are specified as reg-ex patterns.</p>
</div>
<div class="paragraph">
<p>TokenIssueOperation has a modular structure. This allows custom
behaviors to be injected into the processing of messages. In this case
we are overriding the SecurityTokenServiceProvider&#8217;s default behavior
and performing SAML token processing. CXF provides an implementation of
a SAMLTokenProvider which we are using rather than writing our own.</p>
</div>
<div class="paragraph">
<p>Learn more about the SAMLTokenProvider
<a href="http://coheigea.blogspot.it/2011/10/apache-cxf-sts-documentation-part-iv.html">here</a>
.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsbearer;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.sts.StaticSTSProperties;
import org.apache.cxf.sts.operation.TokenIssueOperation;
import org.apache.cxf.sts.service.ServiceMBean;
import org.apache.cxf.sts.service.StaticService;
import org.apache.cxf.sts.token.provider.SAMLTokenProvider;
import org.apache.cxf.ws.security.sts.provider.SecurityTokenServiceProvider;

import jakarta.xml.ws.WebServiceProvider;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

@WebServiceProvider(serviceName = "SecurityTokenService",
      portName = "UT_Port",
      targetNamespace = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/",
      wsdlLocation = "WEB-INF/wsdl/bearer-ws-trust-1.4-service.wsdl")
//be sure to have dependency on org.apache.cxf module when on AS7, otherwise Apache CXF annotations are ignored
@EndpointProperties(value = {
      @EndpointProperty(key = "ws-security.signature.username", value = "mystskey"),
      @EndpointProperty(key = "ws-security.signature.properties", value = "stsKeystore.properties"),
      @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsbearer.STSBearerCallbackHandler")
})
public class SampleSTSBearer extends SecurityTokenServiceProvider
{

   public SampleSTSBearer() throws Exception
   {
      super();

      StaticSTSProperties props = new StaticSTSProperties();
      props.setSignatureCryptoProperties("stsKeystore.properties");
      props.setSignatureUsername("mystskey");
      props.setCallbackHandlerClass(STSBearerCallbackHandler.class.getName());
      props.setEncryptionCryptoProperties("stsKeystore.properties");
      props.setEncryptionUsername("myservicekey");
      props.setIssuer("DoubleItSTSIssuer");

      List&lt;ServiceMBean&gt; services = new LinkedList&lt;ServiceMBean&gt;();
      StaticService service = new StaticService();
      service.setEndpoints(Arrays.asList(
         "https://localhost:(\\d)*/jaxws-samples-wsse-policy-trust-bearer/BearerService",
         "https://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-bearer/BearerService",
         "https://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-bearer/BearerService"
      ));
      services.add(service);

      TokenIssueOperation issueOperation = new TokenIssueOperation();
      issueOperation.getTokenProviders().add(new SAMLTokenProvider());
      issueOperation.setServices(services);
      issueOperation.setStsProperties(props);
      this.setIssueOperation(issueOperation);
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="stsbearercallbackhandler">STSBearerCallbackHandler</h6>
<div class="paragraph">
<p>STSBearerCallbackHandler is a callback handler for the WSS4J Crypto API.
It is used to obtain the password for the private key in the keystore.
This class enables CXF to retrieve the password of the user name to use
for the message signature.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsbearer;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;

import java.util.HashMap;
import java.util.Map;

public class STSBearerCallbackHandler extends PasswordCallbackHandler
{
   public STSBearerCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("mystskey", "stskpass");
      passwords.put("alice", "clarinet");
      return passwords;
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="crypto-properties-and-keystore-files-5">Crypto properties and keystore files</h6>
<div class="paragraph">
<p>WSS4J&#8217;s Crypto implementation is loaded and configured via a Java
properties file that contains Crypto configuration data. The file
contains implementation-specific properties such as a keystore location,
password, default alias and the like. This application is using the
Merlin implementation. File stsKeystore.properties contains this
information.</p>
</div>
<div class="paragraph">
<p>File servicestore.jks, is a Java KeyStore (JKS) repository. It contains
self signed certificates for myservicekey and mystskey. <em>Self signed
certificates are not appropriate for production use.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin  
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=stsspass
org.apache.ws.security.crypto.merlin.keystore.file=stsstore.jks</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="manifest-mf-5">MANIFEST.MF</h6>
<div class="paragraph">
<p>When deployed on WildFly, this application requires access to the
JBossWS and Apache CXF APIs provided in modules
org.jboss.ws.cxf.jbossws-cxf-client. The org.jboss.ws.cxf.sts module is
also needed to build the STS configuration in the <code>SampleSTS</code>
constructor. The dependency statement directs the server to provide them
at deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version: 1.0  
Ant-Version: Apache Ant 1.8.2  
Created-By: 1.7.0_25-b15 (Oracle Corporation)  
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client,org.jboss.ws.cxf.sts</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="web-service-requester-4">Web service requester</h5>
<div class="paragraph">
<p>This section examines the crucial elements in calling a web service that
implements endpoint security as described in the SAML Bearer scenario.
The components that will be discussed are.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Web service requester&#8217;s implementation</p>
</li>
<li>
<p>ClientCallbackHandler</p>
</li>
<li>
<p>Crypto properties and keystore files</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="web-service-requester-implementation-4">Web service requester Implementation</h6>
<div class="paragraph">
<p>The ws-requester, the client, uses standard procedures for creating a
reference to the web service. To address the endpoint security
requirements, the web service&#8217;s "Request Context" is configured with the
information needed in message generation. The STSClient
that communicates with the STS is configured with similar values. Note
the key strings ending with a ".it" suffix. This suffix flags these
settings as belonging to the STSClient. The internal CXF code assigns
this information to the STSClient that is auto-generated for this
service call.</p>
</div>
<div class="paragraph">
<p>There is an alternate method of setting up the STSCLient. The user may
provide their own instance of the STSClient. The CXF code will use this
object and not auto-generate one. When providing the STSClient in this
way, the user must provide a org.apache.cxf.Bus for it and the
configuration keys must not have the ".it" suffix. This is used in the
ActAs and OnBehalfOf examples.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  String serviceURL = "https://" + getServerHost() + ":8443/jaxws-samples-wsse-policy-trust-bearer/BearerService";

  final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/bearerwssecuritypolicy", "BearerService");
  Service service = Service.create(new URL(serviceURL + "?wsdl"), serviceName);
  BearerIface proxy = (BearerIface) service.getPort(BearerIface.class);

  Map&lt;String, Object&gt; ctx = ((BindingProvider)proxy).getRequestContext();

  // set the security related configuration information for the service "request"
  ctx.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
  ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
    Thread.currentThread().getContextClassLoader().getResource(
    "META-INF/clientKeystore.properties"));
  ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
    Thread.currentThread().getContextClassLoader().getResource(
    "META-INF/clientKeystore.properties"));
  ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myclientkey");
  ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myservicekey");

  //-- Configuration settings that will be transfered to the STSClient
  // "alice" is the name provided for the WSS Username. Her password will
  // be retreived from the ClientCallbackHander by the STSClient.
  ctx.put(SecurityConstants.USERNAME + ".it", "alice");
  ctx.put(SecurityConstants.CALLBACK_HANDLER + ".it", new ClientCallbackHandler());
  ctx.put(SecurityConstants.ENCRYPT_PROPERTIES + ".it",
    Thread.currentThread().getContextClassLoader().getResource(
    "META-INF/clientKeystore.properties"));
  ctx.put(SecurityConstants.ENCRYPT_USERNAME + ".it", "mystskey");
  ctx.put(SecurityConstants.STS_TOKEN_USERNAME + ".it", "myclientkey");
  ctx.put(SecurityConstants.STS_TOKEN_PROPERTIES + ".it",
    Thread.currentThread().getContextClassLoader().getResource(
    "META-INF/clientKeystore.properties"));
  ctx.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO + ".it", "true");

  proxy.sayHello();</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="clientcallbackhandler-2">ClientCallbackHandler</h6>
<div class="paragraph">
<p>ClientCallbackHandler is a callback handler for the WSS4J Crypto API. It
is used to obtain the password for the private key in the keystore. This
class enables CXF to retrieve the password of the username to use for
the message signature. Note that "alice" and her password have been
provided here. This information is not in the (JKS) keystore but
provided in the WildFly security domain. It was declared in file
jbossws-users.properties.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared;

import java.io.IOException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.ws.security.WSPasswordCallback;

public class ClientCallbackHandler implements CallbackHandler {

    public void handle(Callback[] callbacks) throws IOException,
            UnsupportedCallbackException {
        for (int i = 0; i &lt; callbacks.length; i++) {
            if (callbacks[i] instanceof WSPasswordCallback) {
                WSPasswordCallback pc = (WSPasswordCallback) callbacks[i];
                if ("myclientkey".equals(pc.getIdentifier())) {
                    pc.setPassword("ckpass");
                    break;
                } else if ("alice".equals(pc.getIdentifier())) {
                    pc.setPassword("clarinet");
                    break;
                } else if ("bob".equals(pc.getIdentifier())) {
                    pc.setPassword("trombone");
                    break;
                } else if ("myservicekey".equals(pc.getIdentifier())) {  // rls test  added for bearer test
                   pc.setPassword("skpass");
                   break;
                }
            }
        }
    }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="crypto-properties-and-keystore-files-6">Crypto properties and keystore files</h6>
<div class="paragraph">
<p>WSS4J&#8217;s Crypto implementation is loaded and configured via a Java
properties file that contains Crypto configuration data. The file
contains implementation-specific properties such as a keystore location,
password, default alias and the like. This application is using the
Merlin implementation. File clientKeystore.properties contains this
information.</p>
</div>
<div class="paragraph">
<p>File clientstore.jks, is a Java KeyStore (JKS) repository. It contains
self signed certificates for myservicekey and mystskey. <em>Self signed
certificates are not appropriate for production use.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=cspass
org.apache.ws.security.crypto.merlin.keystore.alias=myclientkey
org.apache.ws.security.crypto.merlin.keystore.file=META-INF/clientstore.jks</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="saml-holder-of-key-assertion-scenario">5.13.8. SAML Holder-Of-Key Assertion Scenario</h4>
<div class="paragraph">
<p>WS-Trust deals with managing software security tokens. A SAML assertion
is a type of security token. In the Holder-Of-Key method, the STS
creates a SAML token containing the client&#8217;s public key and signs the
SAML token with its private key. The client includes the SAML token and
signs the outgoing soap envelope to the web service with its private
key. The web service validates the SOAP message and the SAML token.</p>
</div>
<div class="paragraph">
<p>Implementation of this scenario has the following requirements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SAML tokens with a Holder-Of-Key subject confirmation method must be
protected so the token can not be snooped. In most cases, a
Holder-Of-Key token combined with HTTPS is sufficient to prevent "a man
in the middle" getting possession of the token. This means a security
policy that uses a sp:TransportBinding and sp:HttpsToken.</p>
</li>
<li>
<p>A Holder-Of-Key token has no encryption or signing keys associated
with it, therefore a sp:IssuedToken of SymmetricKey or PublicKey keyType
should be used with a sp:SignedEndorsingSupportingTokens.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="web-service-provider-5">Web service Provider</h5>
<div class="paragraph">
<p>This section examines the web service elements for the SAML
Holder-Of-Key scenario. The components are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Web service provider&#8217;s WSDL</p>
</li>
<li>
<p>SSL configuration</p>
</li>
<li>
<p>Web service provider&#8217;s Interface and Implementation classes.</p>
</li>
<li>
<p>Crypto properties and keystore files</p>
</li>
<li>
<p>MANIFEST.MF</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="web-service-provider-wsdl-5">Web service provider WSDL</h6>
<div class="paragraph">
<p>The web service provider is a contract-first endpoint. All the WS-trust
and security policies for it are declared in the WSDL,
HolderOfKeyService.wsdl. For this scenario a ws-requester is required to
present a SAML 2.0 token of SymmetricKey keyType, issued from a designed
STS. The address of the STS is provided in the WSDL. A transport binding
policy is used. The token is declared to be signed and endorsed,
sp:SignedEndorsingSupportingTokens. A detailed explanation of the
security settings are provided in the comments in the listing below.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;definitions targetNamespace="http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy"
             name="HolderOfKeyService"
        xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
        xmlns="http://schemas.xmlsoap.org/wsdl/"
        xmlns:wsp="http://www.w3.org/ns/ws-policy"
        xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"
    xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
    xmlns:wsaws="http://www.w3.org/2005/08/addressing"
    xmlns:wsx="http://schemas.xmlsoap.org/ws/2004/09/mex"
    xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"
    xmlns:t="http://docs.oasis-open.org/ws-sx/ws-trust/200512"&gt;

  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy"
                  schemaLocation="HolderOfKeyService_schema1.xsd"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="sayHello"&gt;
    &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;
  &lt;message name="sayHelloResponse"&gt;
    &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;
  &lt;portType name="HolderOfKeyIface"&gt;
    &lt;operation name="sayHello"&gt;
      &lt;input message="tns:sayHello"/&gt;
      &lt;output message="tns:sayHelloResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
&lt;!--
        The wsp:PolicyReference binds the security requirments on all the endpoints.
        The wsp:Policy wsu:Id="#TransportSAML2HolderOfKeyPolicy" element is defined later in this file.
--&gt;
  &lt;binding name="HolderOfKeyServicePortBinding" type="tns:HolderOfKeyIface"&gt;
    &lt;wsp:PolicyReference URI="#TransportSAML2HolderOfKeyPolicy" /&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="sayHello"&gt;
      &lt;soap:operation soapAction=""/&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;
&lt;!--
  The soap:address has been defined to use JBoss's https port, 8443.  This is
  set in conjunction with the sp:TransportBinding policy for https.
--&gt;
  &lt;service name="HolderOfKeyService"&gt;
    &lt;port name="HolderOfKeyServicePort" binding="tns:HolderOfKeyServicePortBinding"&gt;
      &lt;soap:address location="https://@jboss.bind.address@:8443/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;


  &lt;wsp:Policy wsu:Id="TransportSAML2HolderOfKeyPolicy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
  &lt;!--
        The wsam:Addressing element, indicates that the endpoints of this
        web service MUST conform to the WS-Addressing specification.  The
        attribute wsp:Optional="false" enforces this assertion.
  --&gt;
        &lt;wsam:Addressing wsp:Optional="false"&gt;
          &lt;wsp:Policy /&gt;
        &lt;/wsam:Addressing&gt;
&lt;!--
  The sp:TransportBinding element indicates that security is provided by the
  message exchange transport medium, https.  WS-Security policy specification
  defines the sp:HttpsToken for use in exchanging messages transmitted over HTTPS.
--&gt;
          &lt;sp:TransportBinding
            xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
            &lt;wsp:Policy&gt;
              &lt;sp:TransportToken&gt;
                &lt;wsp:Policy&gt;
                  &lt;sp:HttpsToken&gt;
                    &lt;wsp:Policy/&gt;
                  &lt;/sp:HttpsToken&gt;
                &lt;/wsp:Policy&gt;
              &lt;/sp:TransportToken&gt;
&lt;!--
     The sp:AlgorithmSuite element, requires the TripleDes algorithm suite
     be used in performing cryptographic operations.
--&gt;
              &lt;sp:AlgorithmSuite&gt;
                &lt;wsp:Policy&gt;
                  &lt;sp:TripleDes /&gt;
                &lt;/wsp:Policy&gt;
              &lt;/sp:AlgorithmSuite&gt;
&lt;!--
     The sp:Layout element,  indicates the layout rules to apply when adding
     items to the security header.  The sp:Lax sub-element indicates items
     are added to the security header in any order that conforms to
     WSS: SOAP Message Security.
--&gt;
              &lt;sp:Layout&gt;
                &lt;wsp:Policy&gt;
                  &lt;sp:Lax /&gt;
                &lt;/wsp:Policy&gt;
              &lt;/sp:Layout&gt;
              &lt;sp:IncludeTimestamp /&gt;
            &lt;/wsp:Policy&gt;
          &lt;/sp:TransportBinding&gt;

&lt;!--
  The sp:SignedEndorsingSupportingTokens, when transport level security level is
  used there will be no message signature and the signature generated by the
  supporting token will sign the Timestamp.
--&gt;
        &lt;sp:SignedEndorsingSupportingTokens
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
&lt;!--
  The sp:IssuedToken element asserts that a SAML 2.0 security token of type
  Bearer is expected from the STS.  The
  sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
  attribute instructs the runtime to include the initiator's public key
  with every message sent to the recipient.

  The sp:RequestSecurityTokenTemplate element directs that all of the
  children of this element will be copied directly into the body of the
  RequestSecurityToken (RST) message that is sent to the STS when the
  initiator asks the STS to issue a token.
--&gt;
            &lt;sp:IssuedToken
              sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
              &lt;sp:RequestSecurityTokenTemplate&gt;
                &lt;t:TokenType&gt;http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0&lt;/t:TokenType&gt;
 &lt;!--
   KeyType of "SymmetricKey", the client must prove to the WS service that it
   possesses a particular symmetric session key.
 --&gt;
                &lt;t:KeyType&gt;http://docs.oasis-open.org/ws-sx/ws-trust/200512/SymmetricKey&lt;/t:KeyType&gt;
              &lt;/sp:RequestSecurityTokenTemplate&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:RequireInternalReference /&gt;
              &lt;/wsp:Policy&gt;
&lt;!--
  The sp:Issuer element defines the STS's address and endpoint information
  This information is used by the STSClient.
--&gt;
              &lt;sp:Issuer&gt;
                &lt;wsaws:Address&gt;http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts-holderofkey/SecurityTokenService&lt;/wsaws:Address&gt;
                &lt;wsaws:Metadata
                  xmlns:wsdli="http://www.w3.org/2006/01/wsdl-instance"
                  wsdli:wsdlLocation="http://@jboss.bind.address@:8080/jaxws-samples-wsse-policy-trust-sts-holderofkey/SecurityTokenService?wsdl"&gt;
                  &lt;wsaw:ServiceName
                    xmlns:wsaw="http://www.w3.org/2006/05/addressing/wsdl"
                    xmlns:stsns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
                    EndpointName="UT_Port"&gt;stsns:SecurityTokenService&lt;/wsaw:ServiceName&gt;
                &lt;/wsaws:Metadata&gt;
              &lt;/sp:Issuer&gt;

            &lt;/sp:IssuedToken&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SignedEndorsingSupportingTokens&gt;
&lt;!--
    The sp:Wss11 element declares WSS: SOAP Message Security 1.1 options
    to be supported by the STS.  These particular elements generally refer
    to how keys are referenced within the SOAP envelope.  These are normally
    handled by CXF.
--&gt;
        &lt;sp:Wss11&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportRefIssuerSerial /&gt;
            &lt;sp:MustSupportRefThumbprint /&gt;
            &lt;sp:MustSupportRefEncryptedKey /&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Wss11&gt;
&lt;!--
    The sp:Trust13 element declares controls for WS-Trust 1.3 options.
    They are policy assertions related to exchanges specifically with
    client and server challenges and entropy behaviors.  Again these are
    normally handled by CXF.
--&gt;
        &lt;sp:Trust13&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportIssuedTokens /&gt;
            &lt;sp:RequireClientEntropy /&gt;
            &lt;sp:RequireServerEntropy /&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Trust13&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

&lt;/definitions&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="ssl-configuration-2">SSL configuration</h6>
<div class="paragraph">
<p>This web service is using https, therefore the JBoss server must be
configured to provide SSL support in the Web subsystem. There are 2
components to SSL configuration.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>create a certificate keystore</p>
</li>
<li>
<p>declare an SSL connector in the Web subsystem of the JBoss server
configuration file.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Follow the directions in the section
<a href="https://docs.wildfly.org/26.1/WildFly_Elytron_Security.html#configure-ssltls">Configure SSL/TLS</a> .</p>
</div>
<div class="paragraph">
<p>Here is an example of an SSL connector declaration.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;subsystem xmlns="urn:jboss:domain:web:1.4" default-virtual-server="default-host" native="false"&gt;
.....
  &lt;connector name="jbws-https-connector" protocol="HTTP/1.1" scheme="https" socket-binding="https" secure="true" enabled="true"&gt;
    &lt;ssl key-alias="tomcat" password="changeit" certificate-key-file="/myJbossHome/security/test.keystore" verify-client="false"/&gt;
  &lt;/connector&gt;
...</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="web-service-interface-4">Web service Interface</h6>
<div class="paragraph">
<p>The web service provider interface class, HolderOfKeyIface, is a simple
straight forward web service definition.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.holderofkey;

import jakarta.jws.WebMethod;
import jakarta.jws.WebService;

@WebService
(
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy"
)
public interface HolderOfKeyIface {
   @WebMethod
   String sayHello();
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="web-service-implementation-4">Web service Implementation</h6>
<div class="paragraph">
<p>The web service provider implementation class, HolderOfKeyImpl, is a
POJO. It uses the standard WebService annotation to define the
service endpoint. There are two Apache CXF annotations,
EndpointProperties and EndpointProperty used for configuring the
endpoint for the CXF runtime. These annotations come from the
<a href="https://ws.apache.org/wss4j/">Apache WSS4J project</a> , which provides a
Java implementation of the primary WS-Security standards for Web
Services. These annotations are programmatically adding properties to
the endpoint. With plain Apache CXF, these properties are often set via
the &lt;jaxws:properties&gt; element on the &lt;jaxws:endpoint&gt; element in the
Spring config; these annotations allow the properties to be configured
in the code.</p>
</div>
<div class="paragraph">
<p>WSS4J uses the Crypto interface to get keys and certificates for
signature creation/verification, as is asserted by the WSDL for this
service. The WSS4J configuration information being provided by
HolderOfKeyImpl is for Crypto&#8217;s Merlin implementation. More information
will be provided about this in the keystore section.</p>
</div>
<div class="paragraph">
<p>The first EndpointProperty statement in the listing disables ensurance
of compliance with the Basic Security Profile 1.1. The next
EndpointProperty statements declares the Java properties file that
contains the (Merlin) crypto configuration information. The last
EndpointProperty statement declares the STSHolderOfKeyCallbackHandler
implementation class. It is used to obtain the user&#8217;s password for the
certificates in the keystore file.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.holderofkey;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;

import jakarta.jws.WebService;

@WebService
   (
      portName = "HolderOfKeyServicePort",
      serviceName = "HolderOfKeyService",
      wsdlLocation = "WEB-INF/wsdl/HolderOfKeyService.wsdl",
      targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy",
      endpointInterface = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.holderofkey.HolderOfKeyIface"
   )
@EndpointProperties(value = {
   @EndpointProperty(key = "ws-security.is-bsp-compliant", value = "false"),
   @EndpointProperty(key = "ws-security.signature.properties", value = "serviceKeystore.properties"),
   @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.holderofkey.HolderOfKeyCallbackHandler")
})
public class HolderOfKeyImpl implements HolderOfKeyIface
{
   public String sayHello()
   {
      return "Holder-Of-Key WS-Trust Hello World!";
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="crypto-properties-and-keystore-files-7">Crypto properties and keystore files</h6>
<div class="paragraph">
<p>WSS4J&#8217;s Crypto implementation is loaded and configured via a Java
properties file that contains Crypto configuration data. The file
contains implementation-specific properties such as a keystore location,
password, default alias and the like. This application is using the
Merlin implementation. File serviceKeystore.properties contains this
information.</p>
</div>
<div class="paragraph">
<p>File servicestore.jks, is a Java KeyStore (JKS) repository. It contains
self signed certificates for myservicekey and mystskey. <em>Self signed
certificates are not appropriate for production use.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=sspass
org.apache.ws.security.crypto.merlin.keystore.alias=myservicekey
org.apache.ws.security.crypto.merlin.keystore.file=servicestore.jks</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="manifest-mf-6">MANIFEST.MF</h6>
<div class="paragraph">
<p>When deployed on WildFly this application requires access to the JBossWs
and CXF APIs provided in module org.jboss.ws.cxf.jbossws-cxf-client. The
dependency statement directs the server to provide them at deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version:1.0
Ant-Version: Apache Ant1.8.2
Created-By:1.7.0_25-b15 (Oracle Corporation)
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="security-token-service-3">Security Token Service</h5>
<div class="paragraph">
<p>This section examines the crucial elements in providing the Security
Token Service functionality for providing a SAML Holder-Of-Key token.
The components that will be discussed are.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Security Domain</p>
</li>
<li>
<p>STS&#8217;s WSDL</p>
</li>
<li>
<p>STS&#8217;s implementation class</p>
</li>
<li>
<p>STSBearerCallbackHandler</p>
</li>
<li>
<p>Crypto properties and keystore files</p>
</li>
<li>
<p>MANIFEST.MF</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="security-domain-3">Security Domain</h6>
<div class="paragraph">
<p>The STS requires a JBoss security domain be configured. The
jboss-web.xml descriptor declares a named security
domain,"JBossWS-trust-sts" to be used by this service for
authentication. This security domain requires two properties files and
the addition of a security-domain declaration in the JBoss server
configuration file.</p>
</div>
<div class="paragraph">
<p>For this scenario the domain needs to contain user <em>alice</em> , password
<em>clarinet</em> , and role <em>friend</em> . See the listings below for
jbossws-users.properties and jbossws-roles.properties. In addition the
following XML must be added to the JBoss security subsystem in the
server configuration file. Replace " <strong>SOME_PATH</strong> " with appropriate
information.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;security-domain name="JBossWS-trust-sts"&gt;
  &lt;authentication&gt;
   &lt;login-module code="UsersRoles" flag="required"&gt;
     &lt;module-option name="usersProperties" value="/SOME_PATH/jbossws-users.properties"/&gt;
     &lt;module-option name="unauthenticatedIdentity" value="anonymous"/&gt;
     &lt;module-option name="rolesProperties" value="/SOME_PATH/jbossws-roles.properties"/&gt;
   &lt;/login-module&gt;
  &lt;/authentication&gt;
&lt;/security-domain&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>jboss-web.xml</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE jboss-web PUBLIC"-//JBoss//DTD Web Application 2.4//EN" "&gt;
&lt;jboss-web&gt;
  &lt;security-domain&gt;java:/jaas/JBossWS-trust-sts&lt;/security-domain&gt;
&lt;/jboss-web&gt;</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>jbossws-users.properties</p>
</div>
<div class="literalblock">
<div class="content">
<pre># A sample users.properties filefor use with the UsersRolesLoginModule
alice=clarinet</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"> </p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>jbossws-roles.properties</p>
</div>
<div class="literalblock">
<div class="content">
<pre># A sample roles.properties filefor use with the UsersRolesLoginModule
alice=friend</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="stss-wsdl-2">STS&#8217;s WSDL</h6>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;wsdl:definitions
  targetNamespace="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:tns="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:wstrust="http://docs.oasis-open.org/ws-sx/ws-trust/200512/"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:wsap10="http://www.w3.org/2006/05/addressing/wsdl"
  xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
  xmlns:wsp="http://www.w3.org/ns/ws-policy"
  xmlns:wst="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata"&gt;

  &lt;wsdl:types&gt;
    &lt;xs:schema elementFormDefault="qualified"
               targetNamespace='http://docs.oasis-open.org/ws-sx/ws-trust/200512'&gt;

      &lt;xs:element name='RequestSecurityToken'
                  type='wst:AbstractRequestSecurityTokenType'/&gt;
      &lt;xs:element name='RequestSecurityTokenResponse'
                  type='wst:AbstractRequestSecurityTokenType'/&gt;

      &lt;xs:complexType name='AbstractRequestSecurityTokenType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:any namespace='##any' processContents='lax' minOccurs='0'
                  maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name='Context' type='xs:anyURI' use='optional'/&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax'/&gt;
      &lt;/xs:complexType&gt;
      &lt;xs:element name='RequestSecurityTokenCollection'
                  type='wst:RequestSecurityTokenCollectionType'/&gt;
      &lt;xs:complexType name='RequestSecurityTokenCollectionType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element name='RequestSecurityToken'
                      type='wst:AbstractRequestSecurityTokenType' minOccurs='2'
                      maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name='RequestSecurityTokenResponseCollection'
                  type='wst:RequestSecurityTokenResponseCollectionType'/&gt;
      &lt;xs:complexType name='RequestSecurityTokenResponseCollectionType'&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref='wst:RequestSecurityTokenResponse' minOccurs='1'
                      maxOccurs='unbounded'/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute namespace='##other' processContents='lax'/&gt;
      &lt;/xs:complexType&gt;

    &lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;

  &lt;!-- WS-Trust defines the following GEDs --&gt;
  &lt;wsdl:message name="RequestSecurityTokenMsg"&gt;
    &lt;wsdl:part name="request" element="wst:RequestSecurityToken"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseMsg"&gt;
    &lt;wsdl:part name="response"
               element="wst:RequestSecurityTokenResponse"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenCollectionMsg"&gt;
    &lt;wsdl:part name="requestCollection"
               element="wst:RequestSecurityTokenCollection"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponseCollectionMsg"&gt;
    &lt;wsdl:part name="responseCollection"
               element="wst:RequestSecurityTokenResponseCollection"/&gt;
  &lt;/wsdl:message&gt;

  &lt;!-- This portType an example of a Requestor (or other) endpoint that
         Accepts SOAP-based challenges from a Security Token Service --&gt;
  &lt;wsdl:portType name="WSSecurityRequestor"&gt;
    &lt;wsdl:operation name="Challenge"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!-- This portType is an example of an STS supporting full protocol --&gt;
  &lt;wsdl:portType name="STS"&gt;
    &lt;wsdl:operation name="Cancel"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/CancelFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Issue"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTRC/IssueFinal"
        message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Renew"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/RenewFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Validate"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/ValidateFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="KeyExchangeToken"&gt;
      &lt;wsdl:input
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KET"
        message="tns:RequestSecurityTokenMsg"/&gt;
      &lt;wsdl:output
        wsam:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/KETFinal"
        message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="RequestCollection"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenCollectionMsg"/&gt;
      &lt;wsdl:output message="tns:RequestSecurityTokenResponseCollectionMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;!-- This portType is an example of an endpoint that accepts
         Unsolicited RequestSecurityTokenResponse messages --&gt;
  &lt;wsdl:portType name="SecurityTokenResponseService"&gt;
    &lt;wsdl:operation name="RequestSecurityTokenResponse"&gt;
      &lt;wsdl:input message="tns:RequestSecurityTokenResponseMsg"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;

  &lt;wsdl:binding name="UT_Binding" type="wstrust:STS"&gt;
    &lt;wsp:PolicyReference URI="#UT_policy"/&gt;
    &lt;soap:binding style="document"
                  transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="Issue"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue"/&gt;
      &lt;wsdl:input&gt;
        &lt;wsp:PolicyReference
          URI="#Input_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;wsp:PolicyReference
          URI="#Output_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Validate"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Validate"/&gt;
      &lt;wsdl:input&gt;
        &lt;wsp:PolicyReference
          URI="#Input_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;wsp:PolicyReference
          URI="#Output_policy"/&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Cancel"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="Renew"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="KeyExchangeToken"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/KeyExchangeToken"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="RequestCollection"&gt;
      &lt;soap:operation
        soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/RequestCollection"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;

  &lt;wsdl:service name="SecurityTokenService"&gt;
    &lt;wsdl:port name="UT_Port" binding="tns:UT_Binding"&gt;
      &lt;soap:address location="http://localhost:8080/SecurityTokenService/UT"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;

  &lt;wsp:Policy wsu:Id="UT_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;wsap10:UsingAddressing/&gt;
        &lt;sp:SymmetricBinding
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:ProtectionToken&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:X509Token
                  sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never"&gt;
                  &lt;wsp:Policy&gt;
                    &lt;sp:RequireDerivedKeys/&gt;
                    &lt;sp:RequireThumbprintReference/&gt;
                    &lt;sp:WssX509V3Token10/&gt;
                  &lt;/wsp:Policy&gt;
                &lt;/sp:X509Token&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:ProtectionToken&gt;
            &lt;sp:AlgorithmSuite&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Basic256/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:AlgorithmSuite&gt;
            &lt;sp:Layout&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:Lax/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:Layout&gt;
            &lt;sp:IncludeTimestamp/&gt;
            &lt;sp:EncryptSignature/&gt;
            &lt;sp:OnlySignEntireHeadersAndBody/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SymmetricBinding&gt;
        &lt;sp:SignedSupportingTokens
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:UsernameToken
              sp:IncludeToken="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient"&gt;
              &lt;wsp:Policy&gt;
                &lt;sp:WssUsernameToken10/&gt;
              &lt;/wsp:Policy&gt;
            &lt;/sp:UsernameToken&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:SignedSupportingTokens&gt;
        &lt;sp:Wss11
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportRefKeyIdentifier/&gt;
            &lt;sp:MustSupportRefIssuerSerial/&gt;
            &lt;sp:MustSupportRefThumbprint/&gt;
            &lt;sp:MustSupportRefEncryptedKey/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Wss11&gt;
        &lt;sp:Trust13
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;wsp:Policy&gt;
            &lt;sp:MustSupportIssuedTokens/&gt;
            &lt;sp:RequireClientEntropy/&gt;
            &lt;sp:RequireServerEntropy/&gt;
          &lt;/wsp:Policy&gt;
        &lt;/sp:Trust13&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

  &lt;wsp:Policy wsu:Id="Input_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;sp:SignedParts
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;sp:Body/&gt;
          &lt;sp:Header Name="To"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="From"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="FaultTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="ReplyTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="MessageID"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="RelatesTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="Action"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
        &lt;/sp:SignedParts&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

  &lt;wsp:Policy wsu:Id="Output_policy"&gt;
    &lt;wsp:ExactlyOne&gt;
      &lt;wsp:All&gt;
        &lt;sp:SignedParts
          xmlns:sp="http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702"&gt;
          &lt;sp:Body/&gt;
          &lt;sp:Header Name="To"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="From"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="FaultTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="ReplyTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="MessageID"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="RelatesTo"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
          &lt;sp:Header Name="Action"
                     Namespace="http://www.w3.org/2005/08/addressing"/&gt;
        &lt;/sp:SignedParts&gt;
      &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
  &lt;/wsp:Policy&gt;

&lt;/wsdl:definitions&gt;</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="stss-implementation-class-2">STS&#8217;s implementation class</h6>
<div class="paragraph">
<p>The Apache CXF&#8217;s STS, SecurityTokenServiceProvider, is a web service
provider that is compliant with the protocols and functionality defined
by the WS-Trust specification. It has a modular architecture. Many of
its components are configurable or replaceable and there are many
optional features that are enabled by implementing and configuring
plug-ins. Users can customize their own STS by extending from
SecurityTokenServiceProvider and overriding the default settings.
Extensive information about the CXF&#8217;s STS configurable and pluggable
components can be found
<a href="http://coheigea.blogspot.com/2011/11/apache-cxf-sts-documentation-part-viii_10.html">here</a>
.</p>
</div>
<div class="paragraph">
<p>This STS implementation class, SampleSTSHolderOfKey, is a POJO that
extends from SecurityTokenServiceProvider. Note that the class is
defined with a WebServiceProvider annotation and not a WebService
annotation. This annotation defines the service as a Provider-based
endpoint, meaning it supports a more messaging-oriented approach to Web
services. In particular, it signals that the exchanged messages will be
XML documents of some type. SecurityTokenServiceProvider is an
implementation of the jakarta.xml.ws.Provider interface. In comparison the
WebService annotation defines a (service endpoint interface) SEI-based
endpoint which supports message exchange via SOAP envelopes.</p>
</div>
<div class="paragraph">
<p>As was done in the HolderOfKeyImpl class, the WSS4J annotations
EndpointProperties and EndpointProperty are providing endpoint
configuration for the CXF runtime. The first EndpointProperty statements
declares the Java properties file that contains the (Merlin) crypto
configuration information. WSS4J reads this file and extra required
information for message handling. The last EndpointProperty statement
declares the STSHolderOfKeyCallbackHandler implementation class. It is
used to obtain the user&#8217;s password for the certificates in the keystore
file.</p>
</div>
<div class="paragraph">
<p>In this implementation we are customizing the operations of token
issuance and their static properties.</p>
</div>
<div class="paragraph">
<p>StaticSTSProperties is used to set select properties for configuring
resources in the STS. You may think this is a duplication of the
settings made with the WSS4J annotations. The values are the same but
the underlying structures being set are different, thus this
information must be declared in both places.</p>
</div>
<div class="paragraph">
<p>The setIssuer setting is important because it uniquely identifies the
issuing STS. The issuer string is embedded in issued tokens and, when
validating tokens, the STS checks the issuer string value. Consequently,
it is important to use the issuer string in a consistent way, so that
the STS can recognize the tokens that it has issued.</p>
</div>
<div class="paragraph">
<p>The setEndpoints call allows the declaration of a set of allowed token
recipients by address. The addresses are specified as reg-ex patterns.</p>
</div>
<div class="paragraph">
<p>TokenIssueOperation has a modular structure. This allows custom
behaviors to be injected into the processing of messages. In this case
we are overriding the SecurityTokenServiceProvider&#8217;s default behavior
and performing SAML token processing. CXF provides an implementation of
a SAMLTokenProvider which we are using rather than writing our own.</p>
</div>
<div class="paragraph">
<p>Learn more about the SAMLTokenProvider
<a href="http://coheigea.blogspot.it/2011/10/apache-cxf-sts-documentation-part-iv.html">here</a>
.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsholderofkey;

import org.apache.cxf.annotations.EndpointProperties;
import org.apache.cxf.annotations.EndpointProperty;
import org.apache.cxf.sts.StaticSTSProperties;
import org.apache.cxf.sts.operation.TokenIssueOperation;
import org.apache.cxf.sts.service.ServiceMBean;
import org.apache.cxf.sts.service.StaticService;
import org.apache.cxf.sts.token.provider.SAMLTokenProvider;
import org.apache.cxf.ws.security.sts.provider.SecurityTokenServiceProvider;

import jakarta.xml.ws.WebServiceProvider;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

/**
 * User: rsearls
 * Date: 3/14/14
 */
@WebServiceProvider(serviceName = "SecurityTokenService",
   portName = "UT_Port",
   targetNamespace = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/",
   wsdlLocation = "WEB-INF/wsdl/holderofkey-ws-trust-1.4-service.wsdl")
//be sure to have dependency on org.apache.cxf module when on AS7, otherwise Apache CXF annotations are ignored
@EndpointProperties(value = {
   @EndpointProperty(key = "ws-security.signature.properties", value = "stsKeystore.properties"),
   @EndpointProperty(key = "ws-security.callback-handler", value = "org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsholderofkey.STSHolderOfKeyCallbackHandler")
})
public class SampleSTSHolderOfKey extends SecurityTokenServiceProvider
{

   public SampleSTSHolderOfKey() throws Exception
   {
      super();

      StaticSTSProperties props = new StaticSTSProperties();
      props.setSignatureCryptoProperties("stsKeystore.properties");
      props.setSignatureUsername("mystskey");
      props.setCallbackHandlerClass(STSHolderOfKeyCallbackHandler.class.getName());
      props.setEncryptionCryptoProperties("stsKeystore.properties");
      props.setEncryptionUsername("myservicekey");
      props.setIssuer("DoubleItSTSIssuer");

      List&lt;ServiceMBean&gt; services = new LinkedList&lt;ServiceMBean&gt;();
      StaticService service = new StaticService();
      service.setEndpoints(Arrays.asList(
         "https://localhost:(\\d)*/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService",
         "https://\\[::1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService",
         "https://\\[0:0:0:0:0:0:0:1\\]:(\\d)*/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService"
      ));

      services.add(service);

      TokenIssueOperation issueOperation = new TokenIssueOperation();
      issueOperation.getTokenProviders().add(new SAMLTokenProvider());
      issueOperation.setServices(services);
      issueOperation.setStsProperties(props);
      this.setIssueOperation(issueOperation);

   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="holderofkeycallbackhandler">HolderOfKeyCallbackHandler</h6>
<div class="paragraph">
<p>STSHolderOfKeyCallbackHandler is a callback handler for the WSS4J Crypto
API. It is used to obtain the password for the private key in the
keystore. This class enables CXF to retrieve the password of the user
name to use for the message signature.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.stsholderofkey;

import org.jboss.wsf.stack.cxf.extensions.security.PasswordCallbackHandler;

import java.util.HashMap;
import java.util.Map;

/**
 * User: rsearls
 * Date: 3/19/14
 */
public class STSHolderOfKeyCallbackHandler extends PasswordCallbackHandler
{
   public STSHolderOfKeyCallbackHandler()
   {
      super(getInitMap());
   }

   private static Map&lt;String, String&gt; getInitMap()
   {
      Map&lt;String, String&gt; passwords = new HashMap&lt;String, String&gt;();
      passwords.put("mystskey", "stskpass");
      passwords.put("alice", "clarinet");
      return passwords;
   }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="crypto-properties-and-keystore-files-8">Crypto properties and keystore files</h6>
<div class="paragraph">
<p>WSS4J&#8217;s Crypto implementation is loaded and configured via a Java
properties file that contains Crypto configuration data. The file
contains implementation-specific properties such as a keystore location,
password, default alias and the like. This application is using the
Merlin implementation. File stsKeystore.properties contains this
information.</p>
</div>
<div class="paragraph">
<p>File servicestore.jks, is a Java KeyStore (JKS) repository. It contains
self signed certificates for myservicekey and mystskey. <em>Self signed
certificates are not appropriate for production use.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=stsspass
org.apache.ws.security.crypto.merlin.keystore.file=stsstore.jks</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="manifest-mf-7">MANIFEST.MF</h6>
<div class="paragraph">
<p>When deployed on WildFly, this application requires access to the
JBossWS and Apache CXF APIs provided in modules
org.jboss.ws.cxf.jbossws-cxf-client. The org.jboss.ws.cxf.sts module is
also needed to build the STS configuration in the SampleSTSHolderOfKey
constructor. The dependency statement directs the server to provide them
at deployment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version:1.0
Ant-Version: Apache Ant1.8.2
Created-By:1.7.0_25-b15 (Oracle Corporation)
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client,org.jboss.ws.cxf.sts</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="web-service-requester-5">Web service requester</h5>
<div class="paragraph">
<p>This section examines the crucial elements in calling a web service that
implements endpoint security as described in the SAML Holder-Of-Key
scenario. The components that will be discussed are.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>web service requester&#8217;s implementation</p>
</li>
<li>
<p>ClientCallbackHandler</p>
</li>
<li>
<p>Crypto properties and keystore files</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="web-service-requester-implementation-5">Web service requester Implementation</h6>
<div class="paragraph">
<p>The ws-requester, the client, uses standard procedures for creating a
reference to the web service. To address the endpoint security
requirements, the web service&#8217;s "Request Context" is configured with the
information needed in message generation. In addition, the STSClient
that communicates with the STS is configured with similar values. Note
the key strings ending with a ".it" suffix. This suffix flags these
settings as belonging to the STSClient. The internal CXF code assigns
this information to the STSClient that is auto-generated for this
service call.</p>
</div>
<div class="paragraph">
<p>There is an alternate method of setting up the STSCLient. The user may
provide their own instance of the STSClient. The CXF code will use this
object and not auto-generate one. When providing the STSClient in this
way, the user must provide a org.apache.cxf.Bus for it and the
configuration keys must not have the ".it" suffix. This is used in the
ActAs and OnBehalfOf examples.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>String serviceURL = "https://" + getServerHost() + ":8443/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService";

final QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy", "HolderOfKeyService");
final URL wsdlURL = new URL(serviceURL + "?wsdl");
Service service = Service.create(wsdlURL, serviceName);
HolderOfKeyIface proxy = (HolderOfKeyIface) service.getPort(HolderOfKeyIface.class);

Map&lt;String, Object&gt; ctx = ((BindingProvider)proxy).getRequestContext();

// set the security related configuration information for the service "request"
ctx.put(SecurityConstants.CALLBACK_HANDLER, new ClientCallbackHandler());
ctx.put(SecurityConstants.SIGNATURE_PROPERTIES,
  Thread.currentThread().getContextClassLoader().getResource(
  "META-INF/clientKeystore.properties"));
ctx.put(SecurityConstants.ENCRYPT_PROPERTIES,
  Thread.currentThread().getContextClassLoader().getResource(
  "META-INF/clientKeystore.properties"));
ctx.put(SecurityConstants.SIGNATURE_USERNAME, "myclientkey");
ctx.put(SecurityConstants.ENCRYPT_USERNAME, "myservicekey");

//-- Configuration settings that will be transfered to the STSClient
// "alice" is the name provided for the WSS Username. Her password will
// be retreived from the ClientCallbackHander by the STSClient.
ctx.put(SecurityConstants.USERNAME + ".it", "alice");
ctx.put(SecurityConstants.CALLBACK_HANDLER + ".it", new ClientCallbackHandler());
ctx.put(SecurityConstants.ENCRYPT_PROPERTIES + ".it",
  Thread.currentThread().getContextClassLoader().getResource(
  "META-INF/clientKeystore.properties"));
ctx.put(SecurityConstants.ENCRYPT_USERNAME + ".it", "mystskey");
ctx.put(SecurityConstants.STS_TOKEN_USERNAME + ".it", "myclientkey");
ctx.put(SecurityConstants.STS_TOKEN_PROPERTIES + ".it",
  Thread.currentThread().getContextClassLoader().getResource(
  "META-INF/clientKeystore.properties"));
ctx.put(SecurityConstants.STS_TOKEN_USE_CERT_FOR_KEYINFO + ".it", "true");

proxy.sayHello();</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="clientcallbackhandler-3">ClientCallbackHandler</h6>
<div class="paragraph">
<p>ClientCallbackHandler is a callback handler for the WSS4J Crypto API. It
is used to obtain the password for the private key in the keystore. This
class enables CXF to retrieve the password of the user name to use for
the message signature. Note that "alice" and her password have been
provided here. This information is not in the (JKS) keystore but
provided in the WildFly security domain. It was declared in file
jbossws-users.properties.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsse.policy.trust.shared;

import java.io.IOException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.ws.security.WSPasswordCallback;

public class ClientCallbackHandler implements CallbackHandler {

    public void handle(Callback[] callbacks) throws IOException,
            UnsupportedCallbackException {
        for (int i = 0; i &lt; callbacks.length; i++) {
            if (callbacks[i] instanceof WSPasswordCallback) {
                WSPasswordCallback pc = (WSPasswordCallback) callbacks[i];
                if ("myclientkey".equals(pc.getIdentifier())) {
                    pc.setPassword("ckpass");
                    break;
                } else if ("alice".equals(pc.getIdentifier())) {
                    pc.setPassword("clarinet");
                    break;
                } else if ("bob".equals(pc.getIdentifier())) {
                    pc.setPassword("trombone");
                    break;
                } else if ("myservicekey".equals(pc.getIdentifier())) {  // rls test  added for bearer test
                   pc.setPassword("skpass");
                   break;
                }
            }
        }
    }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="crypto-properties-and-keystore-files-9">Crypto properties and keystore files</h6>
<div class="paragraph">
<p>WSS4J&#8217;s Crypto implementation is loaded and configured via a Java
properties file that contains Crypto configuration data. The file
contains implementation-specific properties such as a keystore location,
password, default alias and the like. This application is using the
Merlin implementation. File clientKeystore.properties contains this
information.</p>
</div>
<div class="paragraph">
<p>File clientstore.jks, is a Java KeyStore (JKS) repository. It contains
self signed certificates for myservicekey and mystskey. <em>Self signed
certificates are not appropriate for production use.</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=cspass
org.apache.ws.security.crypto.merlin.keystore.alias=myclientkey
org.apache.ws.security.crypto.merlin.keystore.file=META-INF/clientstore.jks</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ws-reliable-messaging">5.14. WS-Reliable Messaging</h3>
<div class="paragraph">
<p>JBoss Web Services inherits full WS-Reliable Messaging capabilities from
the underlying Apache CXF implementation. At the time of writing, Apache
CXF provides support for the
<a href="http://schemas.xmlsoap.org/ws/2005/02/rm/">WS-Reliable Messaging 1.0</a>
(February 2005) version of the specification.</p>
</div>
<div class="sect3">
<h4 id="enabling-ws-reliable-messaging">5.14.1. Enabling WS-Reliable Messaging</h4>
<div class="paragraph">
<p>WS-Reliable Messaging is implemented internally in Apache CXF through a
set of interceptors that deal with the low level requirements of the
reliable messaging protocol. In order for enabling WS-Reliable
Messaging, users need to either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>consume a WSDL contract that specifies proper WS-Reliable Messaging
policies / assertions</p>
</li>
<li>
<p>manually add / configure the reliable messaging interceptors</p>
</li>
<li>
<p>specify the reliable messaging policies in an optional CXF Spring XML
descriptor</p>
</li>
<li>
<p>specify the Apache CXF reliable messaging feature in an optional CXF
Spring XML descriptor</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The former approach relies on the Apache CXF WS-Policy engine and is the
only portable one. The other approaches are Apache CXF proprietary ones,
however they allow for fine-grained configuration of protocol aspects
that are not covered by the WS-Reliable Messaging Policy. More details
are available in the
<a href="https://cxf.apache.org/docs/wsrmconfiguration.html">Apache CXF
documentation</a> .</p>
</div>
</div>
<div class="sect3">
<h4 id="example-2">5.14.2. Example</h4>
<div class="paragraph">
<p>In this example we configure WS-Reliable Messaging endpoint and client
through the WS-Policy support.</p>
</div>
<div class="sect4">
<h5 id="endpoint-4">Endpoint</h5>
<div class="paragraph">
<p>We go with a contract-first approach, so we start by creating a proper
WSDL contract, containing the WS-Reliable Messaging and WS-Addressing
policies (the latter is a requirement of the former):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;wsdl:definitions name="SimpleService" targetNamespace="http://www.jboss.org/jbossws/ws-extensions/wsrm"
  xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/wsrm" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:wsp="http://www.w3.org/2006/07/ws-policy"&gt;

  &lt;wsdl:types&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://www.jboss.org/jbossws/ws-extensions/wsrm"
  attributeFormDefault="unqualified" elementFormDefault="unqualified"
  targetNamespace="http://www.jboss.org/jbossws/ws-extensions/wsrm"&gt;
&lt;xsd:element name="ping" type="tns:ping"/&gt;
&lt;xsd:complexType name="ping"&gt;
&lt;xsd:sequence/&gt;
&lt;/xsd:complexType&gt;
&lt;xsd:element name="echo" type="tns:echo"/&gt;
&lt;xsd:complexType name="echo"&gt;
&lt;xsd:sequence&gt;
&lt;xsd:element minOccurs="0" name="arg0" type="xsd:string"/&gt;
&lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;
&lt;xsd:element name="echoResponse" type="tns:echoResponse"/&gt;
&lt;xsd:complexType name="echoResponse"&gt;
&lt;xsd:sequence&gt;
&lt;xsd:element minOccurs="0" name="return" type="xsd:string"/&gt;
&lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
  &lt;/wsdl:types&gt;
  &lt;wsdl:message name="echoResponse"&gt;
    &lt;wsdl:part name="parameters" element="tns:echoResponse"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="echo"&gt;
    &lt;wsdl:part name="parameters" element="tns:echo"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="ping"&gt;
    &lt;wsdl:part name="parameters" element="tns:ping"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:portType name="SimpleService"&gt;
    &lt;wsdl:operation name="ping"&gt;
      &lt;wsdl:input name="ping" message="tns:ping"&gt;
    &lt;/wsdl:input&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;wsdl:input name="echo" message="tns:echo"&gt;
    &lt;/wsdl:input&gt;
      &lt;wsdl:output name="echoResponse" message="tns:echoResponse"&gt;
    &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;
  &lt;wsdl:binding name="SimpleServiceSoapBinding" type="tns:SimpleService"&gt;
    &lt;wsp:Policy&gt;
      &lt;!-- WS-Addressing and basic WS-Reliable Messaging policy assertions --&gt;
      &lt;wswa:UsingAddressing xmlns:wswa="http://www.w3.org/2006/05/addressing/wsdl"/&gt;
      &lt;wsrmp:RMAssertion xmlns:wsrmp="http://schemas.xmlsoap.org/ws/2005/02/rm/policy"/&gt;
      &lt;!-- --------------------------------------------------------------- --&gt;
    &lt;/wsp:Policy&gt;
    &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="ping"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="ping"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="echo"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="echoResponse"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="SimpleService"&gt;
    &lt;wsdl:port name="SimpleServicePort" binding="tns:SimpleServiceSoapBinding"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-samples-wsrm-api"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Then we use the <em>wsconsume</em> tool to generate both standard JAX-WS client
and endpoint.</p>
</div>
<div class="paragraph">
<p>We provide a basic JAX-WS implementation for the endpoint, nothing
special in it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsrm.service;

import jakarta.jws.Oneway;
import jakarta.jws.WebMethod;
import jakarta.jws.WebService;

@WebService
(
   name = "SimpleService",
   serviceName = "SimpleService",
   wsdlLocation = "WEB-INF/wsdl/SimpleService.wsdl",
   targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wsrm"
)
public class SimpleServiceImpl
{
   @Oneway
   @WebMethod
   public void ping()
   {
      System.out.println("ping()");
   }

   @WebMethod
   public String echo(String s)
   {
      System.out.println("echo(" + s + ")");
      return s;
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Finally we package the generated POJO endpoint together with a basic
web.xml the usual way and deploy to the application server. The
webservices stack automatically detects the policies and enables
WS-Reliable Messaging.</p>
</div>
</div>
<div class="sect4">
<h5 id="client-4">Client</h5>
<div class="paragraph">
<p>The endpoint advertises his RM capabilities (and requirements) through
the published WSDL and the client is required to also enable WS-RM for
successfully exchanging messages with the server.</p>
</div>
<div class="paragraph">
<p>A regular JAX-WS client is enough if the user does not need to tune
any specific detail of the RM subsystem.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>QName serviceName = new QName("http://www.jboss.org/jbossws/ws-extensions/wsrm", "SimpleService");
URL wsdlURL = new URL("http://localhost:8080/jaxws-samples-wsrm-api?wsdl");
Service service = Service.create(wsdlURL, serviceName);
proxy = (SimpleService)service.getPort(SimpleService.class);
proxy.echo("Hello World!");</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="additional-configuration">Additional configuration</h5>
<div class="paragraph">
<p>Fine-grained tuning of WS-Reliable Messaging engine requires setting up
proper RM features and attach them for instance to the client proxy.
Here is an example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsrm.client;

//...
import jakarta.xml.ws.Service;
import org.apache.cxf.ws.rm.feature.RMFeature;
import org.apache.cxf.ws.rm.manager.AcksPolicyType;
import org.apache.cxf.ws.rm.manager.DestinationPolicyType;
import org.apache.cxf.ws.rmp.v200502.RMAssertion;
import org.apache.cxf.ws.rmp.v200502.RMAssertion.AcknowledgementInterval;
import org.jboss.test.ws.jaxws.samples.wsrm.generated.SimpleService;

//...
Service service = Service.create(wsdlURL, serviceName);

RMFeature feature = new RMFeature();
RMAssertion rma = new RMAssertion();
RMAssertion.BaseRetransmissionInterval bri = new RMAssertion.BaseRetransmissionInterval();
bri.setMilliseconds(4000L);
rma.setBaseRetransmissionInterval(bri);
AcknowledgementInterval ai = new AcknowledgementInterval();
ai.setMilliseconds(2000L);
rma.setAcknowledgementInterval(ai);
feature.setRMAssertion(rma);
DestinationPolicyType dp = new DestinationPolicyType();
AcksPolicyType ap = new AcksPolicyType();
ap.setIntraMessageThreshold(0);
dp.setAcksPolicy(ap);
feature.setDestinationPolicy(dp);

SimpleService proxy = (SimpleService)service.getPort(SimpleService.class, feature);
proxy.echo("Hello World");</pre>
</div>
</div>
<div class="paragraph">
<p>The same can of course be achieved by factoring the feature into a
custom pojo extending <code>org.apache.cxf.ws.rm.feature.RMFeature</code> and
setting the obtained property in a client configuration:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.samples.wsrm.client;

import org.apache.cxf.ws.rm.feature.RMFeature;
import org.apache.cxf.ws.rm.manager.AcksPolicyType;
import org.apache.cxf.ws.rm.manager.DestinationPolicyType;
import org.apache.cxf.ws.rmp.v200502.RMAssertion;
import org.apache.cxf.ws.rmp.v200502.RMAssertion.AcknowledgementInterval;

public class CustomRMFeature extends RMFeature
{
   public CustomRMFeature() {
      super();
      RMAssertion rma = new RMAssertion();
      RMAssertion.BaseRetransmissionInterval bri = new RMAssertion.BaseRetransmissionInterval();
      bri.setMilliseconds(4000L);
      rma.setBaseRetransmissionInterval(bri);
      AcknowledgementInterval ai = new AcknowledgementInterval();
      ai.setMilliseconds(2000L);
      rma.setAcknowledgementInterval(ai);
      super.setRMAssertion(rma);
      DestinationPolicyType dp = new DestinationPolicyType();
      AcksPolicyType ap = new AcksPolicyType();
      ap.setIntraMessageThreshold(0);
      dp.setAcksPolicy(ap);
      super.setDestinationPolicy(dp);
   }
}</pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>this is how the <code>jaxws-client-config.xml</code> descriptor would look:</p>
</li>
</ol>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:5.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jakartaee="https://jakarta.ee/xml/ns/jakartaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:5.0 schema/jbossws-jaxws-config_5_0.xsd"&gt;

  &lt;client-config&gt;
    &lt;config-name&gt;Custom Client Config&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.samples.wsrm.client.CustomRMFeature&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/client-config&gt;

&lt;/jaxws-config&gt;</pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>and this is how the client would set the configuration:</p>
</li>
</ol>
</div>
<div class="literalblock">
<div class="content">
<pre>import org.jboss.ws.api.configuration.ClientConfigUtil;
import org.jboss.ws.api.configuration.ClientConfigurer;

//...
Service service = Service.create(wsdlURL, serviceName);
SimpleService proxy = (SimpleService)service.getPort(SimpleService.class);

ClientConfigurer configurer = ClientConfigUtil.resolveClientConfigurer();
configurer.setConfigProperties(proxy, "META-INF/jaxws-client-config.xml", "Custom Client Config");
proxy.echo("Hello World!");</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="soap-over-jms">5.15. SOAP over JMS</h3>
<div class="paragraph">
<p>JBoss Web Services allows communication over the <em>JMS</em> transport. The
functionality comes from Apache CXF support for the
<a href="http://www.w3.org/TR/soapjms/">SOAP over Java Message Service 1.0</a>
specification, which is aimed at a set of standards for interoperable
transport of <em>SOAP</em> messages over <em>JMS</em> .</p>
</div>
<div class="paragraph">
<p>On top of Apache CXF functionalities, the JBossWS integration allows
users to deploy WS archives containing both <em>JMS</em> and <em>HTTP</em> endpoints
the same way as they do for basic <em>HTTP</em> WS endpoints (in <em>war</em>
archives). The webservices layer of WildFly takes care of looking for
<em>JMS</em> enpdoints in the deployed archive and starts them delegating to
the Apache CXF core similarly as with <em>HTTP</em> endpoints.</p>
</div>
<div class="sect3">
<h4 id="configuring-soap-over-jms">5.15.1. Configuring SOAP over JMS</h4>
<div class="paragraph">
<p>As per specification, the <em>SOAP over JMS</em> transport configuration is
controlled by proper elements and attributes in the <code>binding</code> and
<code>service</code> elements of the WSDL contract. A <em>JMS</em> endpoint is usually
developed using a contract-first approach.</p>
</div>
<div class="paragraph">
<p>The <a href="https://cxf.apache.org/docs/soap-over-jms-10-support.html">Apache CXF
documentation</a> covers all the details of the supported configurations.
The minimum configuration implies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>setting a proper JMS URI in the <code>soap:address</code> <code>location</code> [1]</p>
</li>
<li>
<p>providing a JNDI connection factory name to be used for connecting to
the queues [2]</p>
</li>
<li>
<p>setting the transport binding [3]</p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;wsdl:definitions name="HelloWorldService" targetNamespace="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:tns="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soapjms="http://www.w3.org/2010/soapjms/"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
...

&lt;wsdl:binding name="HelloWorldServiceSoapBinding" type="tns:HelloWorld"&gt;
  &lt;soap:binding style="document" transport="http://www.w3.org/2010/soapjms/"/&gt; &lt;!-- 3 --&gt;
  &lt;wsdl:operation name="echo"&gt;
    &lt;soap:operation soapAction="" style="document"/&gt;
    &lt;wsdl:input name="echo"&gt;
      &lt;soap:body use="literal"/&gt;
    &lt;/wsdl:input&gt;
    &lt;wsdl:output name="echoResponse"&gt;
      &lt;soap:body use="literal"/&gt;
    &lt;/wsdl:output&gt;
  &lt;/wsdl:operation&gt;
&lt;/wsdl:binding&gt;
&lt;wsdl:service name="HelloWorldService"&gt;
  &lt;soapjms:jndiConnectionFactoryName&gt;java:/ConnectionFactory&lt;/soapjms:jndiConnectionFactoryName&gt; &lt;!-- 2 --&gt;
  &lt;wsdl:port binding="tns:HelloWorldServiceSoapBinding" name="HelloWorldImplPort"&gt;
    &lt;soap:address location="jms:queue:testQueue"/&gt; &lt;!-- 1 --&gt;
  &lt;/wsdl:port&gt;
&lt;/wsdl:service&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Apache CXF takes care of setting up the JMS transport for endpoint
implementations whose <code>@WebService</code> annotation points to a port declared
for JMS transport as explained above.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>JBossWS currently supports POJO endpoints only for JMS transport use.
The endpoint classes can be deployed as part of <em>jar</em> or <em>war</em> archives.</p>
</div>
<div class="paragraph">
<p>The <em>web.xml</em> descriptor in <em>war</em> archives doesn&#8217;t need any entry for
JMS endpoints.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="examples-8">5.15.2. Examples</h4>
<div class="sect4">
<h5 id="jms-endpoint-only-deployment">JMS endpoint only deployment</h5>
<div class="paragraph">
<p>In this example we create a simple endpoint relying on <em>SOAP over JMS</em>
and deploy it as part of a jar archive.</p>
</div>
<div class="paragraph">
<p>The endpoint is created using wsconsume tool from a WSDL contract such
as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;wsdl:definitions name="HelloWorldService" targetNamespace="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:ns1="http://schemas.xmlsoap.org/soap/http"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:tns="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soapjms="http://www.w3.org/2010/soapjms/"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;wsdl:types&gt;
&lt;xs:schema elementFormDefault="unqualified" targetNamespace="http://org.jboss.ws/jaxws/cxf/jms" version="1.0" xmlns:tns="http://org.jboss.ws/jaxws/cxf/jms" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;xs:element name="echo" type="tns:echo"/&gt;
&lt;xs:element name="echoResponse" type="tns:echoResponse"/&gt;
&lt;xs:complexType name="echo"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;xs:complexType name="echoResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;
  &lt;wsdl:message name="echoResponse"&gt;
    &lt;wsdl:part element="tns:echoResponse" name="parameters"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="echo"&gt;
    &lt;wsdl:part element="tns:echo" name="parameters"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:portType name="HelloWorld"&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;wsdl:input message="tns:echo" name="echo"&gt;
    &lt;/wsdl:input&gt;
      &lt;wsdl:output message="tns:echoResponse" name="echoResponse"&gt;
    &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;
  &lt;wsdl:binding name="HelloWorldServiceSoapBinding" type="tns:HelloWorld"&gt;
    &lt;soap:binding style="document" transport="http://www.w3.org/2010/soapjms/"/&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="echo"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="echoResponse"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="HelloWorldService"&gt;
    &lt;soapjms:jndiConnectionFactoryName&gt;java:jms/RemoteConnectionFactory&lt;/soapjms:jndiConnectionFactoryName&gt;
    &lt;soapjms:jndiInitialContextFactory&gt;org.jboss.naming.remote.client.InitialContextFactory&lt;/soapjms:jndiInitialContextFactory&gt;
    &lt;soapjms:jndiURL&gt;http-remoting://myhost:8080&lt;/soapjms:jndiURL&gt;
    &lt;wsdl:port binding="tns:HelloWorldServiceSoapBinding" name="HelloWorldImplPort"&gt;
      &lt;soap:address location="jms:queue:testQueue"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
  &lt;wsdl:service name="HelloWorldServiceLocal"&gt;
    &lt;soapjms:jndiConnectionFactoryName&gt;java:/ConnectionFactory&lt;/soapjms:jndiConnectionFactoryName&gt;
    &lt;wsdl:port binding="tns:HelloWorldServiceSoapBinding" name="HelloWorldImplPort"&gt;
      &lt;soap:address location="jms:queue:testQueue"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>The <em>HelloWorldImplPort</em> here is meant for using the <em>testQueue</em> that
has to be created before deploying the endpoint.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>At the time of writing, <em>java:/ConnectionFactory</em> is the default
connection factory JNDI location.</p>
</div>
<div class="paragraph">
<p>For allowing remote JNDI lookup of the connection factory, a specific
service ( <code>HelloWorldService</code> ) for remote clients is added to the WSDL.
The <em>java:jms/RemoteConnectionFactory</em> is the JNDI location of the same
connection factory mentioned above, except it&#8217;s exposed for remote
lookup. The <code>soapjms:jndiInitialContextFactory</code> and <code>soap:jmsjndiURL</code>
complete the remote connection configuration: they depends on the actual
WildFly container the service is running on and specify the the initial
context factory class to use and the JNDI registry address.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Look at the application server domain to see the
configured connection factory JNDI locations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The endpoint implementation is a JAX-WS POJO using @WebService
annotation to refer to the consumed contract:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.cxf.jms;

import jakarta.jws.WebService;

@WebService
(
   portName = "HelloWorldImplPort",
   serviceName = "HelloWorldServiceLocal",
   wsdlLocation = "META-INF/wsdl/HelloWorldService.wsdl",
   endpointInterface = "org.jboss.test.ws.jaxws.cxf.jms.HelloWorld",
   targetNamespace = "http://org.jboss.ws/jaxws/cxf/jms"
)
public class HelloWorldImpl implements HelloWorld
{
   public String echo(String input)
   {
      return input;
   }
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The endpoint implementation references the <code>HelloWorldServiceLocal</code> wsdl
service, so that the local JNDI connection factory location is used for
starting the endpoint on server side.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The final step is to package the generated service
endpoint interface, the endpoint implementation and the WSDL file in a
<em>jar</em> archive and deploy it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>alessio@inuyasha /dati/jbossws/stack/cxf/trunk $ jar -tvf ./modules/testsuite/cxf-tests/target/test-libs/jaxws-cxf-jms-only-deployment.jar
     0 Thu Jun 23 15:18:44 CEST 2011 META-INF/
   129 Thu Jun 23 15:18:42 CEST 2011 META-INF/MANIFEST.MF
     0 Thu Jun 23 15:18:42 CEST 2011 org/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/jaxws/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/jaxws/cxf/
     0 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/jaxws/cxf/jms/
   313 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/jaxws/cxf/jms/HelloWorld.class
  1173 Thu Jun 23 15:18:42 CEST 2011 org/jboss/test/ws/jaxws/cxf/jms/HelloWorldImpl.class
     0 Thu Jun 23 15:18:40 CEST 2011 META-INF/wsdl/
  3074 Thu Jun 23 15:18:40 CEST 2011 META-INF/wsdl/HelloWorldService.wsdl</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>A dependency on <code>org.apache.activemq.artemis</code> module needs to be added
in MANIFEST.MF when deploying to WildFly.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version: 1.0

Ant-Version: Apache Ant 1.7.1

Created-By: 17.0-b16 (Sun Microsystems Inc.)

Dependencies: org.apache.activemq.artemis</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A JAX-WS client can interact with the JMS endpoint the usual way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>URL wsdlUrl = ...
//start another bus to avoid affecting the one that could already be assigned to the current thread - optional but highly suggested
Bus bus = BusFactory.newInstance().createBus();
BusFactory.setThreadDefaultBus(bus);
try
{
   QName serviceName = new QName("http://org.jboss.ws/jaxws/cxf/jms", "HelloWorldService");
   Service service = Service.create(wsdlUrl, serviceName);
   HelloWorld proxy = (HelloWorld) service.getPort(new QName("http://org.jboss.ws/jaxws/cxf/jms", "HelloWorldImplPort"), HelloWorld.class);
   setupProxy(proxy);
   proxy.echo("Hi");
}
finally
{
   bus.shutdown(true);
}</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>The WSDL location URL needs to be retrieved in a custom way, depending
on the client application. Given the endpoint is JMS only, there&#8217;s no
automatically published WSDL contract.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order for performing the remote invocation (which internally goes
through remote JNDI lookup of the connection factory), the calling user
credentials need to be set into the Apache CXF JMSConduit:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>private void setupProxy(HelloWorld proxy) {
   JMSConfiguration config = conduit.getJmsConfig();
   config.setUserName(JBossWSTestHelper.getTestUsername());
   config.setPassword(JBossWSTestHelper.getTestPassword());
   Properties props = conduit.getJmsConfig().getJndiEnvironment();
   props.put(Context.SECURITY_PRINCIPAL, JBossWSTestHelper.getTestUsername());
   props.put(Context.SECURITY_CREDENTIALS, JBossWSTestHelper.getTestPassword());
}</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Look at the WildFly domain and messaging configuration to see the security requirements. At the time of writing, a
user with <code>guest</code> role is required and that&#8217;s internally checked using
the <code>other</code> security domain.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once the endpoint is exposed over JMS transport, any plain JMS
client can also be used to send messages to the webservice endpoint.
Look at the SOAP over JMS spec details and code the client
similarly to</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Properties env = new Properties();
env.put(Context.INITIAL_CONTEXT_FACTORY, "org.jboss.naming.remote.client.InitialContextFactory");
env.put(Context.PROVIDER_URL, "http-remoting://myhost:8080");
env.put(Context.SECURITY_PRINCIPAL, "user");
env.put(Context.SECURITY_CREDENTIALS, "password");
InitialContext context = new InitialContext(env);
QueueConnectionFactory connectionFactory = (QueueConnectionFactory)context.lookup("jms/RemoteConnectionFactory");
Queue reqQueue = (Queue)context.lookup("jms/queue/test");
Queue resQueue = (Queue)context.lookup("jms/queue/test");
QueueConnection con = connectionFactory.createQueueConnection("user", "password");
QueueSession session = con.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
QueueReceiver receiver = session.createReceiver(resQueue);
ResponseListener responseListener = new ResponseListener(); //a custom response listener...
receiver.setMessageListener(responseListener);
con.start();
TextMessage message = session.createTextMessage(reqMessage);
message.setJMSReplyTo(resQueue);

//setup SOAP-over-JMS properties...
message.setStringProperty("SOAPJMS_contentType", "text/xml");
message.setStringProperty("SOAPJMS_requestURI", "jms:queue:testQueue");

QueueSender sender = session.createSender(reqQueue);
sender.send(message);
sender.close();

...</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jms-and-http-endpoints-deployment">JMS and HTTP endpoints deployment</h5>
<div class="paragraph">
<p>In this example we create a deployment containing an endpoint that
serves over both HTTP and JMS transports.</p>
</div>
<div class="paragraph">
<p>We from a WSDL contract such as below (please note we&#8217;ve two <code>binding</code> /
<code>portType</code> for the same <code>service</code> ):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;wsdl:definitions name="HelloWorldService" targetNamespace="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:ns1="http://schemas.xmlsoap.org/soap/http"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:tns="http://org.jboss.ws/jaxws/cxf/jms"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soapjms="http://www.w3.org/2010/soapjms/"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;wsdl:types&gt;
&lt;xs:schema elementFormDefault="unqualified" targetNamespace="http://org.jboss.ws/jaxws/cxf/jms" version="1.0"
  xmlns:tns="http://org.jboss.ws/jaxws/cxf/jms" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;xs:element name="echo" type="tns:echo"/&gt;
&lt;xs:element name="echoResponse" type="tns:echoResponse"/&gt;
&lt;xs:complexType name="echo"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="arg0" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;xs:complexType name="echoResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element minOccurs="0" name="return" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;
  &lt;wsdl:message name="echoResponse"&gt;
    &lt;wsdl:part element="tns:echoResponse" name="parameters"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="echo"&gt;
    &lt;wsdl:part element="tns:echo" name="parameters"&gt;
    &lt;/wsdl:part&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:portType name="HelloWorld"&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;wsdl:input message="tns:echo" name="echo"&gt;
    &lt;/wsdl:input&gt;
      &lt;wsdl:output message="tns:echoResponse" name="echoResponse"&gt;
    &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;
  &lt;wsdl:binding name="HelloWorldServiceSoapBinding" type="tns:HelloWorld"&gt;
    &lt;soap:binding style="document" transport="http://www.w3.org/2010/soapjms/"/&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="echo"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="echoResponse"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:binding name="HttpHelloWorldServiceSoapBinding" type="tns:HelloWorld"&gt;
    &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="echo"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="echo"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="echoResponse"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="HelloWorldService"&gt;
    &lt;soapjms:jndiConnectionFactoryName&gt;java:jms/RemoteConnectionFactory&lt;/soapjms:jndiConnectionFactoryName&gt;
    &lt;soapjms:jndiInitialContextFactory&gt;org.jboss.naming.remote.client.InitialContextFactory&lt;/soapjms:jndiInitialContextFactory&gt;
    &lt;soapjms:jndiURL&gt;remote://localhost:4447&lt;/soapjms:jndiURL&gt;
    &lt;wsdl:port binding="tns:HelloWorldServiceSoapBinding" name="HelloWorldImplPort"&gt;
      &lt;soap:address location="jms:queue:testQueue"/&gt;
    &lt;/wsdl:port&gt;
    &lt;wsdl:port binding="tns:HttpHelloWorldServiceSoapBinding" name="HttpHelloWorldImplPort"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-cxf-jms-http-deployment"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
  &lt;wsdl:service name="HelloWorldServiceLocal"&gt;
    &lt;soapjms:jndiConnectionFactoryName&gt;java:/ConnectionFactory&lt;/soapjms:jndiConnectionFactoryName&gt;
    &lt;wsdl:port binding="tns:HelloWorldServiceSoapBinding" name="HelloWorldImplPort"&gt;
      &lt;soap:address location="jms:queue:testQueue"/&gt;
    &lt;/wsdl:port&gt;
&lt;/wsdl:definitions&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The same considerations of the previous example regarding the JMS queue
and JNDI connection factory still apply. Here we can implement the
endpoint in multiple ways, either with a common implementation class
that&#8217;s extended by the JMS and HTTP ones, or keep the two implementation
classes independent and just have them implement the same service
endpoint interface:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.cxf.jms_http;

import jakarta.jws.WebService;

@WebService
(
   portName = "HelloWorldImplPort",
   serviceName = "HelloWorldServiceLocal",
   wsdlLocation = "WEB-INF/wsdl/HelloWorldService.wsdl",
   endpointInterface = "org.jboss.test.ws.jaxws.cxf.jms_http.HelloWorld",
   targetNamespace = "http://org.jboss.ws/jaxws/cxf/jms"
)
public class HelloWorldImpl implements HelloWorld
{
   public String echo(String input)
   {
      System.out.println("input: " + input);
      return input;
   }
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>package org.jboss.test.ws.jaxws.cxf.jms_http;

import jakarta.jws.WebService;

@WebService
(
   portName = "HttpHelloWorldImplPort",
   serviceName = "HelloWorldService",
   wsdlLocation = "WEB-INF/wsdl/HelloWorldService.wsdl",
   endpointInterface = "org.jboss.test.ws.jaxws.cxf.jms_http.HelloWorld",
   targetNamespace = "http://org.jboss.ws/jaxws/cxf/jms"
)
public class HttpHelloWorldImpl implements HelloWorld
{
   public String echo(String input)
   {
      System.out.println("input (http): " + input);
      return "(http) " + input;
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Both classes are packaged together the service endpoint interface and
the WSDL file in a <em>war</em> archive:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>alessio@inuyasha /dati/jbossws/stack/cxf/trunk $ jar -tvf ./modules/testsuite/cxf-tests/target/test-libs/jaxws-cxf-jms-http-deployment.war
     0 Thu Jun 23 15:18:44 CEST 2011 META-INF/
   129 Thu Jun 23 15:18:42 CEST 2011 META-INF/MANIFEST.MF
     0 Thu Jun 23 15:18:44 CEST 2011 WEB-INF/
   569 Thu Jun 23 15:18:40 CEST 2011 WEB-INF/web.xml
     0 Thu Jun 23 15:18:44 CEST 2011 WEB-INF/classes/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/cxf/
     0 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/cxf/jms_http/
   318 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/cxf/jms_http/HelloWorld.class
  1192 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/cxf/jms_http/HelloWorldImpl.class
  1246 Thu Jun 23 15:18:42 CEST 2011 WEB-INF/classes/org/jboss/test/ws/jaxws/cxf/jms_http/HttpHelloWorldImpl.class
     0 Thu Jun 23 15:18:40 CEST 2011 WEB-INF/wsdl/
  3068 Thu Jun 23 15:18:40 CEST 2011 WEB-INF/wsdl/HelloWorldService.wsdl</pre>
</div>
</div>
<div class="paragraph">
<p>A web.xml descriptor is included to trigger the HTTP
endpoint publish:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
  version="2.4"&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;EndpointServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.test.ws.jaxws.cxf.jms_http.HttpHelloWorldImpl&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;EndpointServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>The MANIFEST.MF needs to declare a dependency on
<em>org.apache.activemq.artemis</em> module when deploying to WildFly.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, the JAX-WS client can interact with both JMS and HTTP endpoints
as usual:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>//start another bus to avoid affecting the one that could already be assigned to current thread - optional but highly suggested
Bus bus = BusFactory.newInstance().createBus();
BusFactory.setThreadDefaultBus(bus);
try
{
   QName serviceName = new QName("http://org.jboss.ws/jaxws/cxf/jms", "HelloWorldService");
   Service service = Service.create(wsdlUrl, serviceName);

   //JMS test
   HelloWorld proxy = (HelloWorld) service.getPort(new QName("http://org.jboss.ws/jaxws/cxf/jms", "HelloWorldImplPort"), HelloWorld.class);
   setupProxy(proxy);
   proxy.echo("Hi");
   //HTTP test
   HelloWorld httpProxy = (HelloWorld) service.getPort(new QName("http://org.jboss.ws/jaxws/cxf/jms", "HttpHelloWorldImplPort"), HelloWorld.class);
   httpProxy.echo("Hi");
}
finally
{
   bus.shutdown(true);
}</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="use-of-endpoint-publish-api">Use of Endpoint.publish() API</h5>
<div class="paragraph">
<p>An alternative to deploying an archive containing JMS endpoints is
starting them directly using the JAX-WS <code>Endpoint.publish(..)</code> API.</p>
</div>
<div class="paragraph">
<p>It is as easy as doing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Object implementor = new HelloWorldImpl();
Endpoint ep = Endpoint.publish("jms:queue:testQueue", implementor);
try
{
   //use or let others use the endpoint
}
finally
{
   ep.stop();
}</pre>
</div>
</div>
<div class="paragraph">
<p>where <code>HelloWorldImpl</code> is a POJO endpoint implementation referencing a
JMS <em>port</em> in a given WSDL contract, as explained in the previous
examples.</p>
</div>
<div class="paragraph">
<p>The main difference among the deployment approach is in the direct
control and responsibility over the endpoint lifecycle ( <em>start/publish</em>
and <em>stop</em> ).</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="http-proxy">5.16. HTTP Proxy</h3>
<div class="paragraph">
<p>The HTTP Proxy related functionalities of JBoss Web Services are
provided by the Apache CXF http transport layer.</p>
</div>
<div class="paragraph">
<p>The suggested configuration mechanism when running JBoss Web Services is
explained below; for further information please refer to the
<a href="https://cxf.apache.org/docs/client-http-transport-including-ssl-support.html">Apache
CXF documentation</a> .</p>
</div>
<div class="sect3">
<h4 id="configuration">5.16.1. Configuration</h4>
<div class="paragraph">
<p>The HTTP proxy configuration for a given JAX-WS client can be set in the
following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>through the <code>http.proxyHost</code> and <code>http.proxyPort</code> system properties,
or</p>
</li>
<li>
<p>leveraging the <code>org.apache.cxf.transport.http.HTTPConduit</code> options</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The former is a JVM level configuration; for instance, assuming the http
proxy is currently running at <a href="http://localhost:9934" class="bare">http://localhost:9934</a> , here is the
setup:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>System.getProperties().setProperty("http.proxyHost", "localhost");
System.getProperties().setProperty("http.proxyPort", 9934);</pre>
</div>
</div>
<div class="paragraph">
<p>The latter is a client stub/port level configuration: the setup is
performed on the <code>HTTPConduit</code> object that&#8217;s part of the Apache CXF
<code>Client</code> abstraction.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import org.apache.cxf.configuration.security.ProxyAuthorizationPolicy;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.frontend.ClientProxy;
import org.apache.cxf.transport.http.HTTPConduit;
import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;
import org.apache.cxf.transports.http.configuration.ProxyServerType;
...

Service service = Service.create(wsdlURL, new QName("http://org.jboss.ws/jaxws/cxf/httpproxy", "HelloWorldService"));
HelloWorld port = (HelloWorld) service.getPort(new QName("http://org.jboss.ws/jaxws/cxf/httpproxy", "HelloWorldImplPort"), HelloWorld.class);

Client client = ClientProxy.getClient(port);
HTTPConduit conduit = (HTTPConduit)client.getConduit();
ProxyAuthorizationPolicy policy = new ProxyAuthorizationPolicy();
policy.setAuthorizationType("Basic");
policy.setUserName(PROXY_USER);
policy.setPassword(PROXY_PWD);
conduit.setProxyAuthorization(policy);

port.echo("Foo");</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ProxyAuthorizationPolicy</code> also allows for setting the authotization
type as well as the username / password to be used.</p>
</div>
<div class="paragraph">
<p>Speaking of authorization and authentication, please note that the JDK
already features the <code>java.net.Authenticator</code> facility, which is used
whenever opening a connection to a given URL requiring a http proxy.
Users might want to set a custom Authenticator for instance when needing
to read WSDL contracts before actually calling into the JBoss Web
Services / Apache CXF code; here is an example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import java.net.Authenticator;
import java.net.PasswordAuthentication;
...
public class ProxyAuthenticator extends Authenticator
{
   private String user, password;

   public ProxyAuthenticator(String user, String password)
   {
      this.user = user;
      this.password = password;
   }

   protected PasswordAuthentication getPasswordAuthentication()
   {
      return new PasswordAuthentication(user, password.toCharArray());
   }
}

...

Authenticator.setDefault(new ProxyAuthenticator(PROXY_USER, PROXY_PWD));</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ws-discovery">5.17. WS-Discovery</h3>
<div class="paragraph">
<p>Apache CXF includes support for <em>Web Services Dynamic Discovery</em> (
<a href="http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html">WS-Discovery</a>
), which is a protocol to enable dynamic discovery of services available
on the local network. The protocol implies using a <code>UDP</code> based multicast
transport to announce new services and probe for existing services. A
managed mode where a discovery proxy is used to reduce the amount of
required multicast traffic is also covered by the protocol.</p>
</div>
<div class="paragraph">
<p>JBossWS integrates the <em>WS-Discovery</em>
<a href="https://cxf.apache.org/docs/ws-discovery.html">functionalities</a> provided
by Apache CXF into the application server.</p>
</div>
<div class="sect3">
<h4 id="enabling-ws-discovery">5.17.1. Enabling WS-Discovery</h4>
<div class="paragraph">
<p>Apache CXF enables <em>WS-Discovery</em> depending on the availability of its
runtime component; given that&#8217;s always shipped in the application
server, JBossWS integration requires using the
<code>cxf.ws-discovery.enabled</code>
usage for enabling <em>WS-Discovery</em> for a given deployment. By default
<em>WS-Discovery</em> is disabled on the application server. Below is an
example of <em>jboss-webservices.xml</em> descriptor to be used for enabling
<em>WS-Discovery</em> :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;webservices xmlns="http://www.jboss.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="1.3" xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;

  &lt;property&gt;
    &lt;name&gt;cxf.ws-discovery.enabled&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;

&lt;/webservices&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>By default, a <em>WS-Discovery</em> service endpoint (SOAP-over-UDP bound) will
be started the first time a WS-Discovery enabled deployment is processed
on the application server. Every ws endpoint belonging to <em>WS-Discovery</em>
enabled deployments will be automatically registered into such a
<em>WS-Discovery</em> service endpoint ( <code>Hello</code> messages). The service will
reply to <code>Probe</code> and <code>Resolve</code> messages received on <code>UDP</code> port <code>3702</code>
(including multicast messages sent to <code>IPv4</code> address <code>239.255.255.250</code> ,
as per
<a href="http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html#_Toc234231816">specification</a>
). Endpoints will eventually be automatically unregistered using <code>Bye</code>
messages upon undeployment.</p>
</div>
</div>
<div class="sect3">
<h4 id="probing-services">5.17.2. Probing services</h4>
<div class="paragraph">
<p>Apache CXF comes with a <em>WS-Discovery</em> API that can be used to probe /
resolve services. When running in-container, a <a href="#jboss-modules">JBoss Modules</a> dependency to the the <code>org.apache.cxf.impl</code> module is
to be set to have access to <em>WS-Discovery</em> client functionalities.</p>
</div>
<div class="paragraph">
<p>The
<a href="http://svn.apache.org/viewvc/cxf/tags/cxf-2.7.5/services/ws-discovery/ws-discovery-api/src/main/java/org/apache/cxf/ws/discovery/WSDiscoveryClient.java?revision=1481139&amp;view=markup">org.apache.cxf.ws.discovery.WSDiscoveryClient</a>
class provides the <em>probe</em> and <em>resolve</em> methods which also accepts
filters on scopes. Users can rely on them for locating available
endpoints on the network. Please have a look at the JBossWS testsuite
which includes a
<a href="http://anonsvn.jboss.org/repos/jbossws/stack/cxf/tags/jbossws-cxf-4.2.0.Beta1/modules/testsuite/cxf-tests/src/test/java/org/jboss/test/ws/jaxws/samples/wsdd/WSDiscoveryTestCase.java">sample</a>
on CXF WS-Discovery usage.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ws-policy">5.18. WS-Policy</h3>
<div class="sect3">
<h4 id="apache-cxf-ws-policy-support">5.18.1. Apache CXF WS-Policy support</h4>
<div class="paragraph">
<p>JBossWS policy support rely on the Apache CXF WS-Policy framework, which
is compliant with the
<a href="http://www.w3.org/TR/2007/REC-ws-policy-20070904/">Web Services Policy
1.5 - Framework</a> and
<a href="http://www.w3.org/TR/2007/REC-ws-policy-attach-20070904/">Web Services
Policy 1.5 - Attachment</a> specifications. Users can work with policies in
different ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>by adding policy assertions to wsdl contracts and letting the runtime
consume them and behave accordingly;</p>
</li>
<li>
<p>by specifying endpoint policy attachments using either CXF annotations
or features.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Of course users can also make direct use of the Apache CXF policy
framework,
<a href="https://cxf.apache.org/docs/developing-assertions.html">defining custom
assertions</a> , etc.</p>
</div>
<div class="paragraph">
<p>Finally, JBossWS provides some additional annotations for simplified
policy attachment.</p>
</div>
<div class="sect4">
<h5 id="contract-first-approach">Contract-first approach</h5>
<div class="paragraph">
<p>WS-Policies can be attached and referenced in wsdl elements (the
specifications describe all possible alternatives). Apache CXF
automatically recognizes, reads and uses policies defined in the wsdl.</p>
</div>
<div class="paragraph">
<p>Users should hence develop endpoints using the <em>contract-first</em>
approach, that is explicitly providing the contract for their services.
Here is a excerpt taken from a wsdl including a WS-Addressing policy:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;wsdl:definitions name="Foo" targetNamespace="http://ws.jboss.org/foo"
...
&lt;wsdl:service name="FooService"&gt;
    &lt;wsdl:port binding="tns:FooBinding" name="FooPort"&gt;
        &lt;soap:address location="http://localhost:80800/foo"/&gt;
        &lt;wsp:Policy xmlns:wsp="http://www.w3.org/ns/ws-policy"&gt;
             &lt;wsam:Addressing xmlns:wsam="http://www.w3.org/2007/02/addressing/metadata"&gt;
                 &lt;wsp:Policy/&gt;
              &lt;/wsam:Addressing&gt;
         &lt;/wsp:Policy&gt;
    &lt;/wsdl:port&gt;
&lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Of course, CXF also acts upon policies specified in wsdl documents
consumed on client side.</p>
</div>
</div>
<div class="sect4">
<h5 id="code-first-approach">Code-first approach</h5>
<div class="paragraph">
<p>For those preferring code-first (java-first) endpoint development,
Apache CXF comes with <code>org.apache.cxf.annotations.Policy</code> and
<code>org.apache.cxf.annotations.Policies</code> annotations to be used for
attaching policy fragments to the wsdl generated at deploy time.</p>
</div>
<div class="paragraph">
<p>Here is an example of a code-first endpoint including @Policy
annotation:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import jakarta.jws.WebService;
import org.apache.cxf.annotations.Policy;

@WebService(portName = "MyServicePort",
            serviceName = "MyService",
            name = "MyServiceIface",
            targetNamespace = "http://www.jboss.org/jbossws/foo")
@Policy(placement = Policy.Placement.BINDING, uri = "JavaFirstPolicy.xml")
public class MyServiceImpl {
   public String sayHello() {
      return "Hello World!";
   }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The referenced descriptor is to be added to the deployment and will
include the policy to be attached; the attachment position in the
contracts is defined through the <code>placement</code> attribute. Here is a
descriptor example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;wsp:Policy wsu:Id="MyPolicy" xmlns:wsp="http://www.w3.org/ns/ws-policy"
    xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"&gt;
    &lt;wsp:ExactlyOne&gt;
        &lt;wsp:All&gt;
            &lt;sp:SupportingTokens xmlns:sp="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy"&gt;
                &lt;wsp:Policy&gt;
                    &lt;sp:UsernameToken sp:IncludeToken="http://schemas.xmlsoap.org/ws/2005/07/securitypolicy/IncludeToken/AlwaysToRecipient"&gt;
                        &lt;wsp:Policy&gt;
                            &lt;sp:WssUsernameToken10/&gt;
                        &lt;/wsp:Policy&gt;
                    &lt;/sp:UsernameToken&gt;
                &lt;/wsp:Policy&gt;
            &lt;/sp:SupportingTokens&gt;
        &lt;/wsp:All&gt;
    &lt;/wsp:ExactlyOne&gt;
&lt;/wsp:Policy&gt;</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jbossws-additions">5.18.2. JBossWS additions</h4>
<div class="sect4">
<h5 id="policy-sets">Policy sets</h5>
<div class="paragraph">
<p>Both approaches above require users to actually write their policies'
assertions; while this offer great flexibility and control of the actual
contract, providing the assertions might end up being quite a
challenging task for complex policies. For this reason, the JBossWS
integration provides <em>policy sets</em> , which are basically pre-defined
groups of policy assertions corresponding to well known / common needs.
Each set has a label allowing users to specify it in the
<code>@org.jboss.ws.api.annotation.PolicySets</code> annotation to have the policy
assertions for that set attached to the annotated endpoint. Multiple
labels can also be specified. Here is an example of the @PolicySets
annotation on a service endpoint interface:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>import jakarta.jws.WebService;
import org.jboss.ws.api.annotation.PolicySets;

@WebService(name = "EndpointTwo", targetNamespace = "http://org.jboss.ws.jaxws.cxf/jbws3648")
@PolicySets({"WS-RM_Policy_spec_example", "WS-SP-EX223_WSS11_Anonymous_X509_Sign_Encrypt", "WS-Addressing"})
public interface EndpointTwo
{
   String echo(String input);
}</pre>
</div>
</div>
<div class="paragraph">
<p>The three sets specified in @PolicySets will cause the wsdl generated
for the endpoint having this interface to be enriched with some policy
assertions for WS-RM, WS-Security and WS-Addressing.</p>
</div>
<div class="paragraph">
<p>The labels' list of known sets is stored in the
<code>META-INF/policies/org.jboss.wsf.stack.cxf.extensions.policy.PolicyAttachmentStore</code>
file within the <code>jbossws-cxf-client.jar</code> (
<code>org.jboss.ws.cxf:jbossws-cxf-client</code> maven artifact). Actual policy
fragments for each set are also stored in the same artifact at
<code>META-INF/policies/&lt;set-label&gt;-&lt;attachment-position&gt;.xml</code> .</p>
</div>
<div class="paragraph">
<p>Here is a list of the available policy sets:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Label</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS-Addressing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic WS-Addressing policy</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS-RM_Policy_spec_example</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The basic WS-RM policy example in the WS-RM
specification</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS-SP-EX2121_SSL_UT_Supporting_Token</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The group of policy assertions
used in the section 2.1.2.1 example of the WS-Security Policy Examples
1.0 specification</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS-SP-EX213_WSS10_UT_Mutual_Auth_X509_Sign_Encrypt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The group of policy
assertions used in the section 2.1.3 example of the WS-Security Policy
Examples 1.0 specification</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS-SP-EX214_WSS11_User_Name_Cert_Sign_Encrypt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The group of policy
assertions used in the section 2.1.4 example of the WS-Security Policy
Examples 1.0 specification</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS-SP-EX221_WSS10_Mutual_Auth_X509_Sign_Encrypt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The group of policy
assertions used in the section 2.2.1 example of the WS-Security Policy
Examples 1.0 specification</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS-SP-EX222_WSS10_Mutual_Auth_X509_Sign_Encrypt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The group of policy
assertions used in the section 2.2.2 example of the WS-Security Policy
Examples 1.0 specification</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS-SP-EX223_WSS11_Anonymous_X509_Sign_Encrypt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The group of policy
assertions used in the section 2.2.3 example of the WS-Security Policy
Examples 1.0 specification</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS-SP-EX224_WSS11_Mutual_Auth_X509_Sign_Encrypt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The group of policy
assertions used in the section 2.2.4 example of the WS-Security Policy
Examples 1.0 specification</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AsymmetricBinding_X509v1_TripleDesRsa15_EncryptBeforeSigning_ProtectTokens</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A WS-Security policy for asymmetric binding (encrypt before signing)
using X.509v1 tokens, 3DES + RSA 1.5 algorithms and with token
protections enabled</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AsymmetricBinding_X509v1_GCM256OAEP_ProtectTokens</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The same as before,
but using custom Apache CXF algorithm suite including GCM 256 + RSA OAEP
algorithms</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Always verify the contents of the generated wsdl contract, as policy
sets are potentially subject to updates between JBossWS releases. This
is especially important when dealing with security related policies; the
provided sets are to be considered as convenient configuration options
only; users remain responsible for the policies in their contracts.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>org.jboss.wsf.stack.cxf.extensions.policy.Constants</code> interface has
convenient String constants for the available policy set labels.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>If you feel a new set should be added, just propose it by writing the
user forum!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="published-wsdl-customization">5.19. Published WSDL customization</h3>
<div class="sect3">
<h4 id="endpoint-address-rewrite">5.19.1. Endpoint address rewrite</h4>
<div class="paragraph">
<p>JBossWS supports the rewrite of the <code>&lt;soap:address&gt;</code> element of
endpoints published in WSDL contracts. This feature is useful for
controlling the server address that is advertised to clients for each
endpoint. The rewrite mechanism is configured at server level through a
set of elements in the webservices subsystem of the WildFly management
model. Please refer to the container documentation for details on the
options supported in the selected container version. Below is a list of
the elements available in the latest WildFly sources:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">modify-wsdl-address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This boolean enables and disables the
address rewrite functionality. When modify-wsdl-address is set to true
and the content of &lt;soap:address&gt; is a valid URL, JBossWS will rewrite
the URL using the values of wsdl-host and wsdl-port or wsdl-secure-port.
When modify-wsdl-address is set to false and the content of
&lt;soap:address&gt; is a valid URL, JBossWS will not rewrite the URL. The
&lt;soap:address&gt; URL will be used. When the content of &lt;soap:address&gt; is
not a valid URL, JBossWS will rewrite it no matter what the setting of
modify-wsdl-address. If modify-wsdl-address is set to true and wsdl-host
is not defined or explicitly set to <em>'</em> <code>jbossws.undefined.host</code> _' _
the content of &lt;soap:address&gt; URL is use. JBossWS uses the requester&#8217;s
host when rewriting the &lt;soap:address&gt; When modify-wsdl-address is not
defined JBossWS uses a default value of true.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl-host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The hostname / IP address to be used for rewriting
<code>&lt;soap:address&gt;</code> . If <code>wsdl-host</code> is set to <code>jbossws.undefined.host</code> ,
JBossWS uses the requester&#8217;s host when rewriting the <code>&lt;soap:address&gt;</code>
When wsdl-host is not defined JBossWS uses a default value of '
<code>jbossws.undefined.host</code> '.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl-port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set this property to explicitly define the HTTP port
that will be used for rewriting the SOAP address. Otherwise the HTTP
port will be identified by querying the list of installed HTTP
connectors.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl-secure-port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set this property to explicitly define the HTTPS
port that will be used for rewriting the SOAP address. Otherwise the
HTTPS port will be identified by querying the list of installed HTTPS
connectors.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl-uri-scheme</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This property explicitly sets the URI scheme
to use for rewriting <code>&lt;soap:address&gt;</code> . Valid values are <code>http</code> and
<code>https</code> . This configuration overrides scheme computed by processing the
endpoint (even if a transport guarantee is specified). The provided
values for <code>wsdl-port</code> and <code>wsdl-secure-port</code> (or their default values)
are used depending on specified scheme.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl-path-rewrite-rule</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This string defines a SED substitution
command (e.g., 's/regexp/replacement/g') that JBossWS executes against
the path component of each &lt;soap:address&gt; URL published from the server.
When wsdl-path-rewrite-rule is not defined, JBossWS retains the original
path component of each &lt;soap:address&gt; URL. When 'modify-wsdl-address' is
set to "false" this element is ignored.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Additionally, users can override the server level configuration by
requesting a specific rewrite behavior for a given endpoint deployment.
That is achieved by setting one of the following properties within a
<em>jboss-webservices.xml</em> descriptor:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Corresponding server option</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl.soapAddress.rewrite.modify-wsdl-address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">modify-wsdl-address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl.soapAddress.rewrite.wsdl-host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl-host</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl.soapAddress.rewrite.wsdl-port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl-port</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl.soapAddress.rewrite.wsdl-secure-port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl-secure-port</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl.soapAddress.rewrite.wsdl-path-rewrite-rule</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl-path-rewrite-rule</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl.soapAddress.rewrite.wsdl-uri-scheme</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">wsdl-uri-scheme</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Here is an example of partial overriding of the default configuration
for a specific deployment:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;?xml version="1.1" encoding="UTF-8"?&gt;
&lt;webservices version="1.2"
  xmlns="http://www.jboss.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;
  &lt;property&gt;
    &lt;name&gt;wsdl.soapAddress.rewrite.wsdl-uri-scheme&lt;/name&gt;
    &lt;value&gt;https&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;wsdl.soapAddress.rewrite.wsdl-host&lt;/name&gt;
    &lt;value&gt;foo&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="system-property-references">5.19.2. System property references</h4>
<div class="paragraph">
<p>System property references wrapped within "@" characters are expanded
when found in WSDL attribute and element values. This allows for
instance including multiple WS-Policy declarations in the contract and
selecting the policy to use depending on a server wide system property;
here is an example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;wsdl:definitions ...&gt;
  ...
  &lt;wsdl:binding name="ServiceOneSoapBinding" type="tns:EndpointOne"&gt;
    ...
    &lt;wsp:PolicyReference URI="#@org.jboss.wsf.test.JBWS3628TestCase.policy@"/&gt;
    &lt;wsdl:operation name="echo"&gt;
      ...
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="ServiceOne"&gt;
    &lt;wsdl:port binding="tns:ServiceOneSoapBinding" name="EndpointOnePort"&gt;
      &lt;soap:address location="http://localhost:8080/jaxws-cxf-jbws3628/ServiceOne"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;

  &lt;wsp:Policy xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsp="http://www.w3.org/ns/ws-policy" wsu:Id="WS-RM_Policy"&gt;
    &lt;wsrmp:RMAssertion xmlns:wsrmp="http://schemas.xmlsoap.org/ws/2005/02/rm/policy"&gt;
          ...
    &lt;/wsrmp:RMAssertion&gt;
  &lt;/wsp:Policy&gt;

  &lt;wsp:Policy xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsp="http://www.w3.org/ns/ws-policy"
      xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata" wsu:Id="WS-Addressing_policy"&gt;
    &lt;wsam:Addressing&gt;
      &lt;wsp:Policy/&gt;
    &lt;/wsam:Addressing&gt;
  &lt;/wsp:Policy&gt;
&lt;/wsdl:definitions&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>If the <strong><em>org.jboss.wsf.test.JBWS3628TestCase.policy</em></strong> system property is
defined and set to " <strong><em>WS-Addressing_policy</em></strong> ", WS-Addressing will be
enabled for the endpoint defined by the contract above.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="throtlling">5.20. Throtlling</h3>
<div class="paragraph">
<p>The throttling feature allows server to limit the number of request when the server is busy or
there are a lot of faults by some requests. This can protect server from being overwhelmed and server resource is used
out.
From JBossWS 7.2.0, the `JBossWSThrottlingFeature' is provided to support Throtlling for JBossWS and WFLY
users. As each ThrotllingFeature needs a ThrolltingManager to do the actual work, the 'EndpointMetricsThrottlingManager' is created
to throttle or limit the flow based on the metrics from the webserivce endpoint. 'EndpointMetricsThrottlingManager' can use the
throshold for endpoint metric value like requestCount, faultCount etc.</p>
</div>
<div class="paragraph">
<p>The throttling configuration can be defined in the <code>jbossws-endpoint-config.xml</code> like :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;

  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.cxf.throttling.HelloWorldImpl&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.JBossWSThrottlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature.throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.EndpointMetricsThrottlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager.requestCountThreshold&lt;/property-name&gt;
      &lt;property-value&gt;5&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This configuration file set a requestCountThreshold "5" to enable the throttling and returns the http response code 419
to the client when the total request count reaches 5. This is totally for demo purpose, please don&#8217;t use in any situation
except for the test purpose.</p>
</div>
<div class="paragraph">
<p>Besides the requestPermits，there are other items can be configured with EndpointMetricsThrottlingManager:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>faultPermit: The number of faults allowed before throttling takes effect."</p>
</li>
<li>
<p>requestPermit: The number of requests allowed before throttling takes effect."</p>
</li>
<li>
<p>averageProcessingTimePermit: The average processing time in milliseconds; if it exceeds this value, throttling takes effect.</p>
</li>
<li>
<p>maxProcessingTimePermit: The maximum processing time in milliseconds; if it exceeds this value, throttling takes effect.</p>
</li>
<li>
<p>minProcessingTimePermit: The minimum processing time in milliseconds; if it exceeds this value, throttling takes effect.</p>
</li>
<li>
<p>totalProcessingTimePermit: The total processing time in milliseconds; if it exceeds this value, throttling takes effect.</p>
</li>
<li>
<p>responseStatusCode: The response code if the throttling takes effect and default is 429.</p>
</li>
<li>
<p>delayTime：When the response code is set to 503, this value in milliseconds will finally be set with Retry-After header in response when throttling takes effect.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To allow users to configure throttling more easily, there is an out-of-the-box RateLimitThrottlingManager that users can utilize to set traffic limits.
This RateLimitThrottlingManager enables users to define the permitted number of requests within a specified period.
To simplify this process, it offers the permitsPerMin configuration item, which allows users to set the number of
permitted requests per minute. This configuration internally sets the period to 60 seconds and adjusts the permitted number of
requests based on the user&#8217;s specifications in the jaxws-endpoint-config.xml. Here is the configuration example which is
using <code>permitsPerMin</code> to limit the 5 requests in one minute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.cxf.throttling.HelloImpl&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.JBossWSThrottlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature.throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.RateLimitThorttlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager.permitsPerMin&lt;/property-name&gt;
      &lt;property-value&gt;5&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Users can use the <code>period</code> and <code>permitsPerPeriod</code> settings to define the number of requests allowed within any specified time period.
Below is an example of the jaxws-endpoint-config.xml configuration to control 5 requests in 30 seconds:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.cxf.throttling.HelloImpl&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.JBossWSThrottlingFeature&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingFeature.throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;##throttlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.wsf.stack.cxf.features.throttling.RateLimitThorttlingManager&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager.period&lt;/property-name&gt;
      &lt;property-value&gt;30&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;##throttlingManager.permitsPerPeriod&lt;/property-name&gt;
      &lt;property-value&gt;5&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note that both of these ThrottlingManagers are based on the web service endpoint metrics and require the web service
subsystem&#8217;s statistics to be enabled. Before using either of these ThrottlingManagers, ensure that statistics
are enabled with the jboss-cli:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>./subsystem=webservices:write-attribute(name=statistics-enabled,value=true)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jboss-modules">6. JBoss Modules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The JBoss Web Services functionalities are provided by a given set of
modules / libraries installed on the server.</p>
</div>
<div class="paragraph">
<p>On WildFly, those are organized into JBoss Modules modules. In
particular the <em>org.jboss.as.webservices.*</em> and <em>org.jboss.ws.*</em> modules
belong to the JBossWS - WildFly integration. Users should not need to
change anything in them.</p>
</div>
<div class="paragraph">
<p>While users are allowed to provide their own modules for their
custom needs, below is a brief collection of suggestions and hints
around modules and webservices development on WildFly.</p>
</div>
<div class="sect2">
<h3 id="setting-module-dependencies">6.1. Setting module dependencies</h3>
<div class="paragraph">
<p>On WildFly the user deployment classloader does not have any visibility
over JBoss internals; so for instance you can&#8217;t <em>directly</em> use JBossWS
<em>implementation</em> classes unless you explicitly set a dependency to the
corresponding module. As a consequence, users need to declare the module
dependencies they want to be added to their deployment.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>The JBoss Web Services APIs are always available by default whenever the
webservices subsystem is available on AS7. Users just use them, no
need for explicit dependencies declaration for those modules.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-manifest-mf">6.1.1. Using MANIFEST.MF</h4>
<div class="paragraph">
<p>The convenient method for configuring deployment dependencies is adding
them into the MANIFEST.MF file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Manifest-Version: 1.0
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client services export,foo.bar</pre>
</div>
</div>
<div class="paragraph">
<p>Above <em>org.jboss.ws.cxf.jbossws-cxf-client</em> and <em>foo.bar</em> are the
modules you want to set dependencies to; <em>services</em> tells the modules
framework that you want to import <em>META-INF/services/..</em>
declarations from the dependency, while <em>export</em> exports the classes
from the module to any other module that might be depending on the
module implicitly created for your deployment.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>When using annotations on your endpoints / handlers such as the Apache
CXF ones (@InInterceptor, @GZIP, &#8230;&#8203;) remember to add the proper module
dependency in your manifest, otherwise your annotations are not picked
up and added to the annotation index by WildFly, resulting in them being
silently ignored.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="using-jaxb">Using JAXB</h5>
<div class="paragraph">
<p>In order to directly use JAXB contexts, in your
client or endpoint running in-container, you need to properly setup a
JAXB implementation; that is performed setting the following dependency:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Dependencies: com.sun.xml.bind services export</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-apache-cxf">Using Apache CXF</h5>
<div class="paragraph">
<p>In order to use Apache CXF APIs and implementation classes you need
to add a dependency to the <em>org.apache.cxf</em> (API) module and / or
<em>org.apache.cxf.impl</em> (implementation) module:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Dependencies: org.apache.cxf services</pre>
</div>
</div>
<div class="paragraph">
<p>Please note that that would not come with any JBossWS-CXF
customizations nor additional extensions. For this reason, and generally
speaking for simplifying user configuration, a client side aggregation
module is available with all the WS dependencies users might need.</p>
</div>
</div>
<div class="sect4">
<h5 id="client-side-ws-aggregation-module">Client side WS aggregation module</h5>
<div class="paragraph">
<p>Whenever you want to use all the JBoss Web Services
feature/functionalities, you can set a dependency to the convenient
client module.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Dependencies: org.jboss.ws.cxf.jbossws-cxf-client services</pre>
</div>
</div>
<div class="paragraph">
<p>Note the <em>services</em> option above: it is strictly required in
order for you to get the JBossWS-CXF version of classes that are
retrieved using the <em>Service API</em> , the <code>Bus</code> for instance.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Be careful. Issues of misconfiguration here can be quite hard
to track down, because the Apache CXF behaviour would be sensibly
different.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>The <em>services</em> option is almost always needed when declaring
dependencies on <em>org.jboss.ws.cxf.jbossws-cxf-client</em> and
<em>org.apache.cxf</em> modules. It affects the
loading of classes through the <em>Service API</em> , which is used to
wire most of the JBossWS components as well as all Apache CXF Bus
extensions.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="annotation-scanning">Annotation scanning</h5>
<div class="paragraph">
<p>The application server uses an annotation index for detecting JAX-WS
endpoints in the user deployments. When declaring WS endpoints, whose class
belongs to a different module (for instance referring that in the
<code>web.xml</code> descriptor), be sure to have an <code>annotations</code> type dependency
in place. Without that, your endpoints will be ignored as they
won&#8217;t appear as annotated classes to the webservices subsystem.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Dependencies: org.foo annotations</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-jboss-deployment-descriptor-xml">6.1.2. Using jboss-deployment-descriptor.xml</h4>
<div class="paragraph">
<p>In some circumstances, the convenient approach of setting module
dependencies in MANIFEST.MF might not work. An example is the need for
importing/exporting specific resources from a given module dependency.
Users should hence add a jboss-deployment-structure.xml descriptor to
their deployment and set module dependencies in it.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="build-and-testsuite-framework">7. Build and testsuite framework</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="introduction">7.1. Introduction</h3>
<div class="paragraph">
<p>The JBossWS project build and testsuites have been completely revisited
in version 5.0.0.Beta3. JBossWS now uses the <em>Arquillian</em>
framework to run its integration tests against WildFly containers.</p>
</div>
<div class="paragraph">
<p>There are two test modules in JBossWS' testsuite, <em>cxf-tests</em> and
<em>shared-tests</em> . Each test module requires at least one <em>WildFly</em>
container to run. Multiple containers are used for modules whose tests
can&#8217;t run at the same time on the same container. By default, containers
are managed (started / stopped) by Arquillian. The JBossWS build system
fetches a copy of the required container from the Maven repository,
unpacks it, patches it installing the current webservices stack on it
and finally hands it over to Arquillian for the testsuite runs. The test
framework also allows Arquillian to manage an already available
container instance on the local filesystem. Finally, it&#8217;s also possible
to execute single tests against a locally running container
(non-Arquillian managed) and run the tests concurrently.</p>
</div>
<div class="sect3">
<h4 id="prerequisites-and-requirements">7.1.1. Prerequisites and requirements</h4>
<div class="ulist">
<ul>
<li>
<p>Maven version 3.2.2 or higher is required to build and run the
testsuite.</p>
</li>
<li>
<p>A unique class name for each test across the testsuite&#8217;s three child
modules. Classes may have the same package name across the child modules
but the full-qualified name must be unique to avoid breaking
concurrent tests run.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="architecture-overview">7.2. Architecture overview</h3>
<div class="paragraph">
<p>When the build fetches the Wildfly container from the Maven repository, a
patched copy is placed in the target/test-server sub-directory of
each testsuite module. For instance, you could have:</p>
</div>
<div class="paragraph">
<div class="title">/modules/testsuite/shared-tests/target/test-server/jbossws-cxf-dist-5.0.0-SNAPSHOT/wildfly-8.1.0.Final</div>
<p>Each container copy is provided with specific standalone mode
configuration files ( <em>jbws-testsuite-SOME_IDENTIFIER.xml</em> ) in the
<code>standalone/configuration</code> server directory. The contents of such
descriptors depends on the tests that are to be run against such
container configurations (the most common difference when compared to
the vanilla standalone.xml is the setup of additional security domains,
system properties, web connectors etc.) Each configuration includes
logging setup to ensure logs are written to unique files (
<em>jbws-testsuite-SOME_IDENFIFIER.log</em> ) in <code>standalone/log</code> directory.</p>
</div>
<div class="sect3">
<h4 id="target-container-identification">7.2.1. Target Container Identification</h4>
<div class="paragraph">
<p>JBossWS supports the current WildFly release and several previous versions
for testing. Maven profiles are used to identify
the target container to be used for testing. The naming convention is
<em>wildflyXYZ</em> , for example <em>wildfly820</em> to mean WIldFly 8.2.0.Final.</p>
</div>
<div class="paragraph">
<p>To run tests against an existing local copy of a WildFly container, the
user must specify the absolute path to the server implementation&#8217;s home
directory using the command line option, <em>-Dserver.home=/foo/bar</em> . The
server should not be running, as the build will create various
standalone server configurations and start multiple instances on
different port numbers. If only a single test or few tests are to be
executed, the user can have those executed against live WildFly
instances previously started on the same port numbers expected by the
tests. Arquillian is configured to detect such scenario and use the
available server.</p>
</div>
</div>
<div class="sect3">
<h4 id="port-mapping">7.2.2. Port Mapping</h4>
<div class="paragraph">
<p>To facilitate concurrent testing, a port offset has been defined for each
of the server configurations. The offsets are defined in the
<code>&lt;properties&gt;</code> element of the <code>modules/testsuite/pom.xml</code> file.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="command-line-options">7.3. Command Line Options</h3>
<div class="paragraph">
<p>As any other Maven-based project, JBossWS is built as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mvn -P[profile] -D[options] [phase]</pre>
</div>
</div>
<div class="sect3">
<h4 id="profile">7.3.1. Profile</h4>
<div class="paragraph">
<p>JBossWS uses Maven profiles to declare the target container and other
types of environment setup. Multiple profiles are provided as a comma
separated list of profile names. Only a single target container profile
is allowed at the same time though.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Profile</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>wildflyXYZ</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designates the target container to use, where XYZ is
WildFly&#8217;s three digit version number</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fast</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declares the tests are to be run concurrently</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dist</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Explicitly includes <em>dist</em> module in the build; by default this
is automatically triggered (only) when a <code>wildflyXYZ</code> profile is set.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>testsuite</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Explicitly includes the testsuite modules in the build; by
default this is automatically triggered (only) when a <code>wildflyXYZ</code>
profile is set.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="options">7.3.2. Options</h4>
<div class="paragraph">
<p>Below is a list of the available build / test options:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Option</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">server.home</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declares the absolute path to a given local server
instance.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">exclude-udp-tests</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Force skipping the UDP tests. This option might be
needed when running on a network that does not allow UDP broadcast.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">noprepare</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Skip integration tests preparation phase, which includes
tuning of the server configurations, wsconsume/wsprovide invocations,
etc.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">debug</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Turns on Surefire debugging of integration tests only. Debugging
address is 5005.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">jboss.bind.address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Starts the containers bound to the specified
network interface address.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">arquillian.deploymentExportPath</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instructs Arquillian to write the
actual test deployments to disk in the specified module sub-directory.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">test</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Runs the test in the specified comma-separated list of JUnit
classes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maven.surefire.debug</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Turns on Surefire debugging in any module
including tests.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="examples-9">7.3.3. Examples</h4>
<div class="paragraph">
<p>Build the project, deploy the WS stack to a local copy of WildFly
8.2.0.Final and run the testsuite:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mvn -Pwildfly820 -Dserver.home=/foo/wildfly-8.2.0.Final integration-test</pre>
</div>
</div>
<div class="paragraph">
<p>Use <em>WildFly 8.1.0.Final</em> as the target container (letting the build
fetch it), patch it with current WS stack and run only test
<em>MtomTestCase</em> that is located in the <em>cxf-test</em> module:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mvn -Pwildfly810 integration-test -Dtest="org/jboss/test/ws/jaxws/samples/MtomTestCase"</pre>
</div>
</div>
<div class="paragraph">
<p>Build, deploy, then run the tests concurrently. Run till Maven
post-integration-test phase to trigger test servers shutdown and save
memory at the end of each testsuite module:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mvn -Pfast,wildfly810 post-integration-test</pre>
</div>
</div>
<div class="paragraph">
<p>Clean the project:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mvn -Pdist,testsuite clean</pre>
</div>
</div>
<div class="paragraph">
<p>Build the WS stack and install it on a specified server instance without
running the integration testsuite:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mvn -Pwildfly900 -Dserver.home=/foo/wildfly-9.0.0.Alpha2-SNAPSHOT package</pre>
</div>
</div>
<div class="paragraph">
<p>When a server.home option is not provided, the build creates a zip
archive with a vanilla WildFly server patched with the current WS stack:
the zip file path is modules/dist/target/jbossws-cxf-dist-$\{
<strong>project.version}</strong> -wildflyXYZ.zip</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mvn -Pwildfly810 package</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="container-remote-debugging">7.4. Container remote debugging</h3>
<div class="paragraph">
<p>While debugging a testcase is simply a matter of providing the
-Ddebug option, remote debugging the container code that runs the WS
stack requires few additional setup steps. The suggested approach is to
identify a single test to run; before actually running the test,
manually start a target container in debug mode and specifying the
proper port offset and server configuration (have a look at the
arquillian.xml decriptors in the testsuite), then run the tests with
-Dserver.home=&#8230;&#8203; option pointing to the home dir for the server
currently running.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="legal-notice">8. Legal Notice</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright © 2011 Red Hat, Inc.</p>
</div>
<div class="paragraph">
<p>The text of and illustrations in this document are licensed by Red Hat
under a Creative Commons Attribution&#8212;&#8203;Share Alike 3.0 Unported license
("CC-BY-SA"). An explanation of CC-BY-SA is available at
<a href="http://creativecommons.org/licenses/by-sa/3.0/" class="bare">http://creativecommons.org/licenses/by-sa/3.0/</a> . In accordance with
CC-BY-SA, if you distribute this document or an adaptation of it, you
must provide the URL for the original version.</p>
</div>
<div class="paragraph">
<p>Red Hat, as the licensor of this document, waives the right to enforce,
and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent
permitted by applicable law.</p>
</div>
<div class="paragraph">
<p>Red Hat, Red Hat Enterprise Linux, the Shadowman logo, JBoss,
MetaMatrix, Fedora, the Infinity Logo, and RHCE are trademarks of Red
Hat, Inc., registered in the United States and other countries.</p>
</div>
<div class="paragraph">
<p>Linux® is the registered trademark of Linus Torvalds in the United
States and other countries.</p>
</div>
<div class="paragraph">
<p>Java® is a registered trademark of Oracle and/or its affiliates.</p>
</div>
<div class="paragraph">
<p>XFS® is a trademark of Silicon Graphics International Corp. or its
subsidiaries in the United States and/or other countries.</p>
</div>
<div class="paragraph">
<p>MySQL® is a registered trademark of MySQL AB in the United States, the
European Union and other countries.</p>
</div>
<div class="paragraph">
<p>Apache, Apache CXF, CXF, Apache WSS4J, WSS4J, Apache Maven, Maven and
the Apache feather logo are trademarks of The Apache Software
Foundation.</p>
</div>
<div class="paragraph">
<p>All other trademarks are the property of their respective owners.</p>
</div>
</div>
</div>

                  </div><!-- end main -->
               </div>

    <div id="rightcolumn" class="column">

    <div class="projectpage-socialmedia">
        <span class="st_sharethis_large">&nbsp;</span>
        <span class="st_facebook_large">&nbsp;</span>
        <span class="st_twitter_large">&nbsp;</span>
        <span class="st_linkedin_large">&nbsp;</span>
        <span class="st_email_large">&nbsp;</span>
    </div>


    <div id="proj_quick-start">
        <h3>Useful Links</h3>
        <ul>
            <li><a href="/downloads-latest/">Download</a></li>
            <li><a href="/docs">Documentation</a></li>
            <li><a href="/blogs">Blog</a></li>
            <li><a href="https://issues.redhat.com/browse/JBWS">JIRA</a></li>
            <li><a href="https://github.com/jbossws">Code</a></li>
            <li><a href="https://github.com/jbossws/jbossws-cxf/discussions">Discussion</a></li>
        </ul>
    </div>

    <div class="clear"><br/></div>

    <div class="uploaded-img">

        <a href="https://www.ej-technologies.com/products/jprofiler/overview.html">

            <img width="180" alt="" height="75"
                 src="/img/logo_jprofiler01.gif"
                 style="margin:0 auto;"/>

        </a>
    </div>

    <h5>We use JProfiler for profiling</h5>

    <table>
        <tr>
            <td>
            </td>
        </tr>
    </table>


    <div>
        <a href="https://www.jboss.org/security.html">
            <div class="projectpage-sprite projectpage-sprite-securityimage">&nbsp;</div>
        </a>
    </div>
</div>

</div><!-- end wrapper-3 -->

</div><!-- end wrapper-content -->
<div style="clear: both;"></div>
</div><!-- end wrapper-2 -->
</div>
       <div id="site-info">
      <div>
      </div>

      <div class="footer">
         <div class="container" id="companyfooter">
            <div class="redhatlogo" style="text-align:center;">
               <div id="logospacer"></div>
               <a href="https://www.redhat.com/">
                  <img src="https://static.jboss.org/images/rhbar/redhatlogo.png">
               </a>
            </div>
         </div>
      </div>
   </div><!-- end site-info -->
</div><!-- end wrapper -->

    </body>
</html>
